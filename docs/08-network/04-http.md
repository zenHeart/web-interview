# http

## http 基本流程

## http 缓存控制

## http 缓存 header 中的 Date 与 Last-Modified 有什么不同 {#p1-http-cache-header-date-last-modified}

**关键词**：http 缓存 header

在 HTTP 响应头中，`Date`和`Last-Modified`有以下不同：

**一、含义不同**

* `Date`：表示消息产生的时间。服务器用这个时间来标记响应报文的生成时间，它反映了服务器生成响应的时刻。例如，“Mon, 07 Oct 2024 12:34:56 GMT”，这个时间是服务器根据其自身的时钟生成的。
* `Last-Modified`：指示资源的最后修改时间。它表示服务器上该资源最后被修改的时间。比如，一个网页文件最后一次被编辑的时间就可以通过这个字段告知客户端。例如，“Mon, 01 Sep 2024 10:20:30 GMT”。

**二、用途不同**

* `Date`：
* 客户端可以根据这个时间来判断响应的新鲜度。例如，如果客户端本地有缓存，它可以通过比较缓存的时间和响应中的`Date`来确定是否需要使用缓存。
* 用于计算响应的年龄等缓存相关的参数。
* `Last-Modified`：
* 主要用于缓存控制。客户端在后续的请求中可以通过`If-Modified-Since`请求头将这个时间发送给服务器，询问服务器资源是否在这个时间之后被修改过。如果没有被修改，服务器可以返回一个状态码为 304（Not Modified）的响应，告知客户端可以使用缓存中的资源，从而减少传输的数据量和提高响应速度。
* 有助于客户端判断资源是否已经过期，以便决定是否需要重新获取资源。

综上所述，`Date`主要表示响应的生成时间，而`Last-Modified`表示资源的最后修改时间，它们在 HTTP 通信中起着不同的作用，共同为缓存控制和资源管理提供重要信息。

## http 缓存中 no-cache 与 no-store 的区别是什么 「

在 HTTP 缓存中，`no-cache`和`no-store`是两种不同的缓存指令，它们的区别如下：

**一、`no-cache`**

1. **含义**：

* 当设置了`no-cache`指令时，这并不意味着不使用缓存。相反，它表示在使用缓存之前，必须先与服务器进行验证，以确定缓存的资源是否仍然有效。
* 这意味着浏览器在使用缓存的资源之前，会向服务器发送一个条件请求（通常是使用`If-Modified-Since`或`If-None-Match`头部），询问服务器该资源是否有更新。如果服务器返回 304 Not Modified 状态码，表示资源没有更新，浏览器可以使用缓存的资源；如果服务器返回新的资源内容，表示资源有更新，浏览器需要使用新的资源。

2. **使用场景**：

* 适用于需要确保获取到最新资源，但又不想每次都从服务器获取完整资源的情况。例如，对于一些经常更新但更新频率不高的资源，可以使用`no-cache`指令，以便在资源没有更新时可以快速使用缓存，而在资源有更新时可以获取到最新的资源。
* 对于一些需要根据用户的特定请求参数来生成资源的情况，也可以使用`no-cache`指令，以便在每次请求时都让服务器根据请求参数来确定是否返回缓存的资源还是生成新的资源。

**二、`no-store`**

1. **含义**：

* `no-store`指令表示绝对不允许缓存资源。这意味着浏览器在接收到带有`no-store`指令的响应后，不会将资源存储在任何缓存中，包括浏览器缓存、代理服务器缓存等。每次请求都必须从服务器获取最新的资源。

2. **使用场景**：

* 适用于对安全性要求非常高的资源，例如包含敏感信息的页面或需要严格保证每次都获取到最新数据的资源。
* 对于一些动态生成的资源，其内容可能会根据不同的请求而变化，并且不希望这些资源被缓存，可以使用`no-store`指令。例如，一些在线银行页面、交易系统等可能会使用`no-store`指令来确保用户每次看到的都是最新的信息。

总之，`no-cache`表示在使用缓存之前需要与服务器进行验证，而`no-store`表示绝对不允许缓存资源。根据不同的需求，可以选择合适的缓存指令来控制资源的缓存行为。

## http content-type

在 HTTP 响应头中，如果`Content-Type`为`application/octet-stream`，代表以下含义：

**一、数据类型含义**

1. **通用二进制流**：

* `application/octet-stream`表示这是一个通用的二进制流数据。它没有特定的格式或结构定义，只是表示数据是以二进制形式传输的。
* 这意味着接收方不知道具体的数据格式，需要根据其他信息（如文件名扩展名、特定的协议约定等）来确定如何处理这个数据。

2. **任意二进制数据**：

* 可以用于传输各种类型的二进制文件，如图片、音频、视频、压缩文件、可执行文件等。
* 例如，当下载一个未知类型的文件时，服务器可能会使用这个`Content-Type`来表示文件的内容是二进制数据，但不指定具体的文件类型。

**二、使用场景**

1. **文件下载**：

* 在文件下载场景中，服务器通常会将`Content-Type`设置为`application/octet-stream`，以便让客户端知道这是一个二进制文件，可以进行下载操作。
* 客户端浏览器在接收到这种类型的响应时，通常会根据文件的扩展名或其他信息来决定如何处理这个文件，例如提示用户保存文件或使用特定的应用程序打开文件。

2. **上传和下载未知类型的数据**：

* 当通过 HTTP 上传或下载数据时，如果数据的类型未知或不确定，可以使用`application/octet-stream`来表示数据是二进制形式，而不指定具体的格式。
* 例如，在一些文件上传接口中，如果允许用户上传任意类型的文件，服务器可能会将接收到的文件数据以`application/octet-stream`类型返回给客户端，以便客户端可以根据需要进行处理。

3. **与特定协议或应用程序交互**：

* 某些协议或应用程序可能会使用`application/octet-stream`来表示特定类型的二进制数据。
* 例如，在一些自定义的网络协议中，或者与特定的服务器端应用程序交互时，可能会使用这个`Content-Type`来表示特定格式的二进制数据，但这种格式可能不是标准的 MIME 类型。

总之，`Content-Type`为`application/octet-stream`表示这是一个通用的二进制流数据，没有特定的格式定义，通常用于文件下载、上传未知类型的数据或与特定协议和应用程序交互的场景。

## ETag  {#p1-etag}

如果 HTTP 响应头中的 ETag 值改变了，通常意味着资源（文件或其他内容）很可能发生了变化，但并不绝对意味着文件内容一定已经更改。

**一、可能导致 ETag 变化但文件内容未更改的情况**

1. 生成方式的变化：

* 如果服务器更改了生成 ETag 的方式，即使文件内容没有变化，ETag 也可能不同。例如，服务器原本使用文件的最后修改时间戳作为 ETag，后来改为使用文件内容的哈希值，那么即使文件内容未变，ETag 也会改变。

2. 服务器配置或逻辑变化：

* 服务器的某些配置更改或业务逻辑变化可能导致 ETag 的生成与之前不同，而与文件内容本身的变化无关。
* 比如，服务器在不同的环境中可能有不同的 ETag 生成策略，从开发环境切换到生产环境时，ETag 可能会改变，即使文件内容相同。

3. 动态资源的非内容相关变化：

* 对于动态生成的资源，如由服务器端脚本生成的网页，ETag 可能受到一些与内容无关的因素影响。例如，服务器的负载、请求的时间等因素可能导致动态资源的 ETag 变化，而实际生成的内容可能并没有改变。

**二、ETag 的作用和可靠性**

1. 缓存验证：

* ETag 主要用于缓存验证，客户端在后续请求中通过 `If-None-Match` 请求头将上次接收到的 ETag 发送给服务器，服务器比较 ETag 来判断资源是否发生了变化。如果 ETag 相同，服务器返回 `304 Not Modified`，客户端可以使用缓存中的资源，节省带宽和提高响应速度。

2. 相对可靠性：

* 虽然 ETag 的变化不能绝对确定文件内容的更改，但在大多数情况下，它是一个比较可靠的指示。如果 ETag 发生了变化，客户端应该重新获取资源以确保得到最新的内容。

综上所述，ETag 值的改变不能确凿地证明文件内容一定更改，但它是一个重要的线索，提示客户端可能需要重新获取资源以验证其是否发生了变化。

## http 向 https 做重定向应该使用哪个状态码 {#p1-http-to-https-redirect}

从 HTTP 向 HTTPS 做重定向，既可以使用 301 永久重定向状态码，也可以使用 302 临时重定向状态码。以下是对这两种状态码的具体介绍及使用场景分析：

1. **301 永久重定向**：

* **含义**：表示请求的资源已被永久地移动到了新的 URL，搜索引擎等客户端会更新其索引，将旧的 URL 替换为新的 URL。未来所有对旧 URL 的访问都应该被定向到新 URL。
* **优点**：一旦设置好 301 重定向，搜索引擎会将权重和排名等信息从旧 URL 转移到新 URL，有利于网站的 SEO。并且用户浏览器会缓存这个重定向信息，下次访问时可以直接跳转到新的 HTTPS 地址，减少了服务器的请求处理。
* **缺点**：如果后续需要更改重定向设置，由于浏览器已经缓存了重定向信息，可能会导致一些用户在一段时间内仍然被重定向到旧的设置，直到缓存过期。
* **适用场景**：如果您的网站已经确定永久地从 HTTP 迁移到 HTTPS，并且希望搜索引擎尽快更新索引，那么使用 301 永久重定向是比较合适的。例如，一个已经完成全站 HTTPS 改造，并且不再使用 HTTP 访问的网站，可以使用 301 重定向来引导用户和搜索引擎。

2. **302 临时重定向**：

* **含义**：表示请求的资源暂时被移动到了新的 URL，客户端在后续的请求中应该继续使用旧的 URL 进行访问，直到资源的位置被永久更改。
* **优点**：302 重定向比较灵活，适用于一些临时的情况，比如网站正在进行 HTTPS 的部署或测试，还不确定是否会长期使用 HTTPS，或者在某些特殊情况下需要暂时将用户从 HTTP 引导到 HTTPS。
* **缺点**：由于是临时重定向，搜索引擎可能不会将权重和排名等信息立即转移到新的 URL，并且用户浏览器也可能不会像对待 301 重定向那样缓存重定向信息，这可能会导致每次访问都需要进行重定向操作，增加了服务器的负担。
* **适用场景**：对于一些短期的、过渡性的 HTTP 到 HTTPS 的重定向需求，或者在不确定是否要长期使用 HTTPS 的情况下，可以使用 302 临时重定向。比如，一个新上线的网站，正在测试 HTTPS 的性能和稳定性，此时可以使用 302 重定向来引导用户访问 HTTPS 版本，以便在测试过程中随时切换回 HTTP。

## 什么是跨域资源共享 (CORS)？它用于解决什么问题？

## cookie

如果 Cookie 没有设置 `max-age`，它通常被视为会话 Cookie，其失效时间的计算方式如下：

**一、会话 Cookie 的失效时间**

1. 浏览器关闭时：一般情况下，当用户关闭浏览器时，会话 Cookie 会被删除。这意味着只要浏览器处于打开状态，并且用户在与同一个网站进行交互，会话 Cookie 就会一直有效。

* 例如，你在浏览一个在线购物网站时，登录后服务器设置了一个未设置 `max-age` 的 Cookie 用于标识你的登录状态。只要你不关闭浏览器，这个 Cookie 就会一直有效，让你在不同页面之间切换时保持登录状态。但是一旦你关闭浏览器，再次打开并访问该网站时，你可能需要重新登录，因为会话 Cookie 已经被删除。

2. 特殊情况：有些浏览器可能会在一段时间内保留会话 Cookie，以便在用户重新打开浏览器时恢复会话状态。然而，这种行为并不是标准的，不同的浏览器可能有不同的处理方式。

* 比如，某些浏览器可能会在用户关闭浏览器后几分钟或几小时内保留会话 Cookie。这可能是为了提供更好的用户体验，让用户在短时间内重新打开浏览器时不需要再次登录或重新执行某些操作。但这种保留时间是不确定的，并且可能因浏览器的设置、版本和用户的操作而有所不同。

**二、需要注意的问题**

1. 安全性考虑：由于会话 Cookie 在浏览器关闭时会被删除，相对来说比较安全。但是，如果在公共计算机上使用会话 Cookie，仍然存在被他人获取敏感信息的风险。因此，在使用会话 Cookie 时，要注意保护用户的隐私和安全。

2. 网站功能影响：对于依赖会话 Cookie 来保持用户状态或提供个性化体验的网站，用户关闭浏览器后可能会导致一些功能失效。例如，在线购物车中的商品可能会在浏览器关闭后丢失，或者用户需要重新设置一些个性化的偏好。在设计网站时，需要考虑到会话 Cookie 的特性，以便在用户关闭浏览器后提供适当的提示或恢复机制。

默认情况下，Cookie 不能在不同的顶级域名之间共享数据。

但是，如果两个域名属于同一主域名下的子域名，并且您设置了正确的 `Domain` 属性，那么在这些子域名之间是可以共享 Cookie 的。

例如，对于 `sub1.example.com` 和 `sub2.example.com` 这样的子域名，如果设置 `Cookie` 的 `Domain` 属性为 `.example.com` ，那么在这两个子域名之间，这个 `Cookie` 是可以共享和访问的。

然而，如果是完全不同的顶级域名，如 `example.com` 和 `anotherdomain.com` 之间，Cookie 是不能直接共享的。

此外，还需要注意 `Cookie` 的 `Path` 属性、安全属性（`Secure`）、`HttpOnly` 属性等，这些属性也会影响 `Cookie` 的使用范围和方式。

## 站点是如何保持登录状态 {#p1-how-sites-keep-login-state}

* created_at: 2024-10-07T08:01:33Z
* updated_at: 2024-10-07T08:01:34Z
* labels: 网络, web应用场景, 腾讯
* milestone: 中

**关键词**：http 保持登录态

虽然 HTTP 是无状态协议，但可以通过以下几种方式来保持登录状态：

**一、Cookie**

1. 工作原理：

* 当用户成功登录后，服务器在响应中设置一个 Cookie，通常包含用户的身份标识、会话信息等。
* 客户端（浏览器）会存储这个 Cookie，并在后续的请求中自动将其发送给服务器。
* 服务器通过检查 Cookie 中的信息来识别用户并确定其登录状态。

2. 示例：

* 用户登录时，服务器生成一个唯一的会话 ID，并将其存储在数据库中，同时在响应中设置一个名为“session_id”的 Cookie，值为该会话 ID。
* 后续请求中，浏览器自动发送包含“session_id”的 Cookie，服务器根据这个会话 ID 查找对应的用户信息，从而确定用户已登录。

**二、Session**

1. 结合 Cookie 使用：

* 服务器端创建一个会话（Session）对象来存储用户的登录状态和其他相关信息。
* 与 Cookie 类似，服务器在用户登录成功后设置一个包含会话 ID 的 Cookie，客户端在后续请求中携带这个 Cookie。
* 服务器根据会话 ID 查找对应的 Session 对象，以确定用户的登录状态。

2. 优点：

* 相比直接使用 Cookie 存储用户信息，Session 更加安全，因为敏感信息存储在服务器端，而不是在客户端的 Cookie 中。

**三、Token（令牌）**

1. JWT（JSON Web Token）：

* 用户登录成功后，服务器生成一个包含用户信息和签名的 JWT 令牌，并将其返回给客户端。
* 客户端在后续请求中，将 JWT 令牌作为请求头或参数发送给服务器。
* 服务器通过验证令牌的签名和有效性来确定用户的登录状态。

2. 优点：

* 无状态：服务器不需要存储会话信息，只需要验证令牌的有效性，因此可以轻松地进行水平扩展。
* 跨域支持：JWT 令牌可以在不同的域之间传递，适用于前后端分离的架构。

**四、HTTP 基本认证和摘要认证**

1. 基本认证：

* 客户端在请求中包含用户名和密码，经过 Base64 编码后作为请求头的一部分发送给服务器。
* 服务器验证用户名和密码的正确性，如果正确则认为用户已登录。
* 缺点是密码以明文形式传输（虽然经过 Base64 编码，但仍然可以被轻易解码），不安全。

2. 摘要认证：

* 是对基本认证的改进，通过使用哈希函数对密码进行加密，提高了安全性。
* 但仍然存在一些安全风险，并且在每次请求中都需要发送用户名和密码的哈希值，不够便捷。

## session

## http1、2、3区别 {#p1-http-1-2-3-difference}

1. HTTP/1.1
   * 持久连接（Keep-Alive）
   * 管道化请求
   * 存在队头阻塞问题
2. HTTP/2
   * 多路复用
   * 二进制分帧
   * 服务器推送
   * 头部压缩（HPACK）
3. HTTP/3
   * 基于 QUIC 协议（UDP）
   * 0-RTT 快速握手
   * 避免队头阻塞
   * 内置加密（TLS 1.3）

## url 的长度限制

## ajax 工作原理？

详细的 ajax 学习参看 [ajax](https://developer.mozilla.org/en-US/docs/Web/Guide/AJAX)

## JSONP原理,回调过程？

## http 状态码 {#p2-http-status-code-304-etag-modified}

304 是 HTTP 状态码中的“Not Modified”（未修改）状态码。

当客户端（通常是浏览器）向服务器请求资源时，如果服务器判断该资源自上次客户端获取后没有被修改，就会返回 304 状态码，告诉客户端可以使用其本地缓存的版本，而无需再次传输整个资源。

304 状态码主要与以下 HTTP 响应头有关：

**一、`Last-Modified` 和 `If-Modified-Since`**

1. `Last-Modified`：

* 服务器在首次响应资源时，在响应头中添加这个字段，表明资源的最后修改时间。
* 例如：`Last-Modified: Thu, 12 Oct 2023 10:30:00 GMT`。

2. `If-Modified-Since`：

* 当客户端再次请求该资源时，会在请求头中添加这个字段，其值为上次服务器返回的`Last-Modified`的值。
* 服务器收到请求后，会比较资源的最后修改时间与`If-Modified-Since`的值。如果资源自该时间后没有被修改，就返回 304 状态码。

**二、`ETag` 和 `If-None-Match`**

1. `ETag`：

* 服务器为资源生成的一个唯一标识符，通常基于资源的内容计算得出。
* 例如：`ETag: "abcdef123456"`。

2. `If-None-Match`：

* 当客户端再次请求资源时，会在请求头中添加这个字段，其值为上次服务器返回的`ETag`的值。
* 服务器收到请求后，会比较资源当前的`ETag`与`If-None-Match`的值。如果一致，说明资源未被修改，返回 304 状态码。

HTTP 状态码中 4xx 类状态码表示客户端错误。常见的 4xx 状态码有：

**一、400 Bad Request（错误请求）**

1. **含义**：

* 服务器无法理解客户端的请求，通常是由于请求格式错误、参数错误或缺少必要的信息导致的。
* 例如，请求的 URL 语法错误、请求体格式不正确、缺少必需的请求头等情况都可能导致这个状态码。

2. **可能的原因和解决方法**：

* 检查请求的 URL 是否正确，确保没有拼写错误或无效的路径。
* 检查请求体的格式是否符合服务器的要求，例如 JSON 格式是否正确。
* 确认是否提供了所有必需的请求参数和请求头。

**二、401 Unauthorized（未授权）**

1. **含义**：

* 表示客户端请求需要身份验证，但未提供有效的身份验证信息，或者提供的身份验证信息不正确。
* 例如，访问需要登录的资源但未提供登录凭证，或者登录凭证已过期。

2. **可能的原因和解决方法**：

* 检查是否需要提供登录凭证，如果需要，确保提供了正确的用户名和密码。
* 如果使用了 API 密钥或令牌，确认其是否有效且正确包含在请求中。
* 检查服务器的身份验证机制是否正确配置。

**三、403 Forbidden（禁止访问）**

1. **含义**：

* 服务器理解请求，但拒绝执行，通常是由于客户端没有足够的权限访问请求的资源。
* 与 401 不同，403 表示客户端已经经过身份验证，但仍然没有权限执行请求。

2. **可能的原因和解决方法**：

* 确认客户端是否具有访问请求资源的权限。这可能涉及到用户角色、权限设置等方面的问题。
* 检查服务器的访问控制列表（ACL）是否正确配置，确保客户端的请求在允许的范围内。

**四、404 Not Found（未找到）**

1. **含义**：

* 服务器无法找到请求的资源。这可能是由于请求的 URL 错误、资源已被删除或移动，或者服务器配置问题导致的。

2. **可能的原因和解决方法**：

* 检查请求的 URL 是否正确，确保资源的路径和名称没有错误。
* 如果资源已被删除或移动，可能需要更新链接或进行重定向。
* 确认服务器的配置是否正确，确保资源能够被正确地映射到相应的 URL。

**五、405 Method Not Allowed（方法不被允许）**

1. **含义**：

* 客户端使用了不被服务器支持的 HTTP 方法来请求资源。例如，使用 PUT 方法请求一个只支持 GET 和 POST 方法的资源。

2. **可能的原因和解决方法**：

* 检查请求的方法是否正确，根据服务器的文档或 API 说明，使用正确的 HTTP 方法。
* 如果需要使用特定的方法，确保服务器已正确配置以支持该方法。

**六、408 Request Timeout（请求超时）**

1. **含义**：

* 客户端在规定的时间内没有发送完整的请求，或者服务器在规定的时间内没有响应客户端的请求。

2. **可能的原因和解决方法**：

* 检查网络连接是否稳定，确保客户端能够及时发送请求。
* 如果是服务器响应超时，可能需要优化服务器的性能，减少响应时间。
* 调整超时时间设置，根据实际情况增加客户端或服务器的超时时间。

**七、429 Too Many Requests（请求过多）**

1. **含义**：

* 客户端在一定时间内发送了过多的请求，超出了服务器的限制。

2. **可能的原因和解决方法**：

* 遵循服务器的请求速率限制，减少请求的频率。
* 如果可能，使用缓存或异步处理来减少对服务器的请求次数。
* 检查是否有不必要的重复请求，可以进行优化以减少请求数量。

## 请描述以下 request 和 response headers?

* Diff. between Expires, Date, Age and If-Modified-…
* Do Not Track
* Cache-Control
* Transfer-Encoding
* ETag
* X-Frame-Options

## 什么是 HTTP method？请罗列出你所知道的所有 HTTP method，并给出解释?

## http2 中的首部压缩是什么 {#p1-http2-header-compression}

在 HTTP/2 中，首部压缩是一项重要的特性，它主要是为了减少在网络传输中重复的首部信息所占用的带宽，从而提高网络传输效率。

**一、为什么需要首部压缩**

在 HTTP/1.1 中，每次请求和响应都包含大量的首部信息，这些首部信息可能会重复出现，并且占用不少的网络带宽。例如，每次请求都可能包含的 User-Agent、Accept 等首部字段，在多个请求之间可能是相同的。随着现代网页应用的复杂性增加，请求的数量也越来越多，首部信息的重复传输问题就变得更加突出。

**二、HTTP/2 首部压缩的原理**

HTTP/2 使用了 HPACK（Header Compression for HTTP/2）算法进行首部压缩。HPACK 主要基于以下两个关键概念：

1. 静态表和动态表：

* 静态表是一个预定义的首部名称和值的映射表，其中包含了一些常见的首部字段，如“:method: GET”“:status: 200”等。当在请求或响应中出现这些常见的首部字段时，可以通过索引值来引用静态表中的条目，而不是传输完整的首部名称和值，从而减少传输的数据量。
* 动态表是在通信过程中动态构建的。当出现新的首部字段组合时，可以将其添加到动态表中。后续的请求或响应如果包含相同的首部字段组合，可以通过索引值来引用动态表中的条目。

2. 整数编码和霍夫曼编码：

* 整数编码用于对首部字段的索引值和长度进行编码，减少表示这些值所需的位数。
* 霍夫曼编码是一种可变长度编码技术，它根据字符的出现频率为不同的字符分配不同长度的编码。在 HTTP/2 中，霍夫曼编码用于对首部字段的值进行编码，进一步减少数据量。

**三、首部压缩的效果**

通过首部压缩，HTTP/2 可以显著减少网络传输中的首部信息大小。在实际应用中，首部压缩可以将首部信息的大小减少到原来的几分之一甚至更小，从而提高网络传输效率，降低延迟。特别是对于频繁重复的首部字段，压缩效果更加明显。

例如，在一个包含多个请求和响应的网页应用中，如果每个请求和响应都包含相同的 User-Agent 首部字段，在 HTTP/1.1 中，这个首部字段会在每次请求和响应中重复传输。而在 HTTP/2 中，只需要在第一次出现时传输完整的首部字段，后续可以通过索引值引用动态表中的条目，大大减少了传输的数据量。

## http3 有哪些核心的新特性 {#p3-http3-core-features}

参考 [quic](https://zhuanlan.zhihu.com/p/32553477)

**一、基于 QUIC 协议**

1. **多路复用无队头阻塞**：

* HTTP/3 基于 QUIC（Quick UDP Internet Connections）协议，它继承了 QUIC 的多路复用特性。在 HTTP/2 中，虽然也有多路复用，但由于底层使用 TCP 协议，可能会出现队头阻塞问题。而 QUIC 的多路复用在一个连接上可以同时处理多个独立的流，并且各个流之间不会相互影响，即使某个流出现丢包，也不会阻塞其他流的传输。
* 例如，当同时加载一个网页的多个资源时，如果其中一个资源的数据包丢失，在 HTTP/2 中可能会导致整个连接的传输受阻，直到丢失的数据包被重传成功。而在 HTTP/3 中，其他资源的传输不受影响，大大提高了传输效率。

2. **快速连接建立**：

* QUIC 协议在连接建立方面比传统的 TCP 和 TLS 握手更快。它将 TLS 加密层整合到 QUIC 协议内部，减少了连接建立的往返次数。在首次连接时，虽然也需要一些时间进行密钥交换等操作，但后续连接可以利用之前的连接状态进行快速恢复，实现 0-RTT（Round-Trip Time）或 1-RTT 的连接建立时间。
* 例如，在移动网络环境下，用户频繁切换网络或重新打开应用时，HTTP/3 可以更快地建立连接，减少用户等待时间，提供更流畅的体验。

**二、改进的拥塞控制**

1. **可插拔的拥塞控制算法**：

* HTTP/3 允许使用不同的拥塞控制算法，并且可以根据网络环境动态切换。这使得它能够更好地适应各种网络条件，如高延迟、高丢包率的网络环境。
* 例如，在无线网络环境下，可以选择更适合这种环境的拥塞控制算法，提高数据传输的效率和稳定性。

2. **更精准的拥塞控制**：

* QUIC 协议的拥塞控制机制比 TCP 更加精细。它可以更好地感知网络的拥塞状态，及时调整发送速率，避免网络拥塞的发生。同时，它还可以对不同的流进行独立的拥塞控制，提高整体的网络利用率。
* 例如，当网络出现拥塞时，HTTP/3 可以更快地降低发送速率，避免拥塞进一步恶化。而在网络状况好转时，又能迅速提高发送速率，充分利用网络带宽。

**三、增强的安全性**

1. **内置加密**：

* QUIC 协议在设计上就内置了加密功能，从一开始就对数据进行加密传输，提供了更好的安全性。这避免了像 TCP 那样在连接建立后再进行加密协商的过程，减少了安全风险。
* 例如，在网络中传输的数据更难被窃听或篡改，保护用户的隐私和数据安全。

2. **前向安全**：

* HTTP/3 继承了 QUIC 的前向安全特性。即使一个密钥被泄露，也不会影响之前的通信安全。这意味着攻击者无法通过破解当前的密钥来获取之前的通信内容。
* 例如，如果一个服务器的密钥在某个时间点被泄露，之前通过 HTTP/3 传输的通信内容仍然是安全的，不会被攻击者窃取。

## https {#p0-https}

[https](https://zhuanlan.zhihu.com/p/43789231)

## https 层可以做哪些性能优化 {#p1-https-performance-optimization}

以下是在 HTTPS 层可以进行的一些性能优化：

**一、优化服务器配置**

1. **选择合适的加密套件**：

* 服务器可以配置支持的加密套件。优先选择性能较好且安全的加密算法组合，如具有高效加密和认证的椭圆曲线密码（ECC）算法及现代的对称加密算法（如 AES-GCM）。避免使用老旧、性能低下或存在安全风险的加密套件。
* 例如，可以根据服务器的性能和安全需求，调整 Nginx 或 Apache 服务器的 SSL/TLS 配置，选择合适的加密套件。

2. **启用 HTTP/2 或 HTTP/3**：

* HTTP/2 和 HTTP/3 在 HTTPS 之上提供了更好的性能。HTTP/2 采用多路复用技术，可以在一个连接上同时传输多个请求和响应，减少了连接建立的开销。HTTP/3 则基于 QUIC 协议，进一步提高了连接的可靠性和性能。
* 确保服务器支持并启用 HTTP/2 或 HTTP/3，可以显著提升 HTTPS 网站的性能。

3. **优化服务器硬件**：

* 使用性能强大的服务器硬件，包括更快的 CPU、更多的内存和高速存储设备，可以提高 HTTPS 服务器的处理能力和响应速度。
* 考虑使用固态硬盘（SSD）来存储网站数据，以减少磁盘 I/O 延迟。

**二、证书管理优化**

1. **使用高效的证书颁发机构（CA）**：

* 选择响应速度快、可靠的 CA 来颁发证书。一些知名的 CA 可以提供快速的证书签发和更新服务，减少证书获取的时间。
* 例如，Let's Encrypt 是一个免费、自动化的 CA，提供快速的证书签发服务，适用于小型网站和个人项目。

2. **优化证书链长度**：

* 减少证书链的长度可以降低证书验证的时间开销。确保服务器配置的证书链只包含必要的中间证书，避免过长的证书链。
* 可以通过检查证书链中的证书数量和层级，以及与 CA 沟通来优化证书链的长度。

3. **证书缓存和预取**：

* 客户端和服务器可以利用证书缓存来减少证书验证的次数。浏览器通常会缓存证书一段时间，以避免在后续访问同一网站时重复验证证书。
* 服务器也可以采取一些措施，如预取证书更新，以确保在证书即将过期时能够及时更新，避免因证书过期导致的连接中断。

**三、TLS 会话复用**

1. **会话票证（Session Tickets）**：

* 服务器可以使用会话票证来实现 TLS 会话复用。会话票证是一个加密的令牌，包含了之前建立的 TLS 会话的信息。当客户端再次连接时，它可以提交会话票证，服务器可以使用票证中的信息快速恢复之前的会话，而无需进行完整的 TLS 握手。
* 配置服务器以支持会话票证，并确保会话票证的安全性和有效性。

2. **会话 ID 复用**：

* 类似地，服务器可以使用会话 ID 来实现会话复用。在首次 TLS 握手时，服务器生成一个会话 ID，并将其发送给客户端。客户端在后续连接时可以提交会话 ID，服务器如果识别到该 ID，可以快速恢复之前的会话。
* 确保服务器正确配置会话 ID 的生成和存储，以实现高效的会话复用。

**四、内容压缩和缓存**

1. **启用压缩**：

* 在 HTTPS 层启用内容压缩可以减少传输的数据量，提高传输速度。服务器可以配置支持的压缩算法，如 Gzip 或 Brotli。
* 确保客户端和服务器都支持所选的压缩算法，并正确配置服务器以对响应内容进行压缩。

2. **合理设置缓存策略**：

* 利用浏览器缓存和中间缓存服务器可以减少重复请求，提高性能。设置合适的缓存头，如`Cache-Control`和`Expires`，指示客户端和中间缓存服务器如何缓存资源。
* 对于静态资源，可以设置较长的缓存时间，以减少对服务器的请求次数。

**五、监控和优化**

1. **性能监控**：

* 使用性能监控工具来监测 HTTPS 网站的性能指标，如连接建立时间、数据传输速度、证书验证时间等。常见的性能监控工具包括 WebPageTest、Pingdom 等。
* 根据监控数据，分析性能瓶颈，并采取相应的优化措施。

2. **持续优化**：

* HTTPS 性能优化是一个持续的过程。随着技术的发展和安全需求的变化，不断评估和调整优化策略，以确保网站始终保持良好的性能。
* 关注安全漏洞和新的性能优化技术，及时更新服务器配置和软件版本。

## https 加密协议里面: TLS 和 SSL 分别是什么，有何区别 {#p2-https-encryption-protocol}

在 HTTPS 加密协议中，TLS（Transport Layer Security，传输层安全协议）和 SSL（Secure Sockets Layer，安全套接字层）都是为了实现网络通信安全而设计的协议，它们的主要情况如下：

**一、SSL**

1. **定义与发展**：

* SSL 由网景公司（Netscape）在 20 世纪 90 年代初开发，旨在为网络通信提供加密和安全认证。
* 它经历了几个版本，如 SSL 2.0 和 SSL 3.0，但后来发现了一些安全漏洞。

2. **主要功能**：

* 数据加密：通过使用对称加密算法（如 DES、3DES、AES 等）对数据进行加密，确保数据在传输过程中不被窃取或篡改。
* 身份验证：服务器可以使用数字证书向客户端证明自己的身份，客户端可以验证证书的有效性，以确保连接到的是真实的服务器。

**二、TLS**

1. **定义与发展**：

* TLS 是在 SSL 3.0 的基础上发展而来的，由互联网工程任务组（IETF）进行标准化。
* 它的目的是提供更安全、更可靠的网络通信安全协议，并修复 SSL 中发现的安全漏洞。
* TLS 经历了多个版本的演进，如 TLS 1.0、TLS 1.1、TLS 1.2 和 TLS 1.3。

2. **主要功能**：

* 与 SSL 类似，TLS 也提供数据加密和身份验证功能。但在加密算法、密钥交换机制和安全性能方面进行了改进和增强。
* 支持更先进的加密算法，如 AES-GCM、ChaCha20-Poly1305 等，提供更好的安全性和性能。
* 改进的密钥交换机制，如 Diffie-Hellman Ephemeral（DHE）和 Elliptic Curve Diffie-Hellman Ephemeral（ECDHE），提供前向保密性。

**三、TLS 与 SSL 的区别**

1. **安全性**：

* TLS 通常被认为比 SSL 更安全。TLS 在设计上修复了 SSL 中的一些安全漏洞，并引入了新的安全特性。
* 例如，TLS 1.3 完全移除了对不安全加密算法的支持，提供了更强的加密和认证机制。

2. **性能**：

* TLS 在性能方面也有所改进。它采用了更高效的加密算法和密钥交换机制，减少了连接建立的时间和数据传输的延迟。
* 例如，TLS 1.3 中的 0-RTT（Zero Round-Trip Time）模式可以在某些情况下实现更快的连接建立。

3. **标准化**：

* SSL 是由网景公司开发的，没有经过正式的标准化过程。而 TLS 是由 IETF 进行标准化的，有明确的规范和标准，确保不同的实现之间具有更好的互操作性。

4. **兼容性**：

* 由于 TLS 是在 SSL 的基础上发展而来的，因此在一定程度上与 SSL 兼容。但是，为了获得更好的安全性和性能，建议使用最新版本的 TLS。
* 现代的浏览器和服务器通常都支持 TLS，并逐渐淘汰对 SSL 的支持。

TLS 和 SSL 都是为了实现网络通信安全而设计的协议，但 TLS 在安全性、性能和标准化方面都比 SSL 更优。在现代的网络环境中，建议使用 TLS 来确保通信的安全。

## HTTPS 安全协议 {#p3-https-security-protocol}

HTTPS（Hypertext Transfer Protocol Secure）安全协议主要包括以下几个关键方面：

**一、加密通信**

1. **TLS/SSL 加密**：

* HTTPS 使用传输层安全（TLS）或安全套接层（SSL）协议对数据进行加密。这确保了在客户端（如浏览器）和服务器之间传输的数据是经过加密的，防止数据被窃听、篡改或劫持。
* 加密过程通过使用对称加密算法（如 AES）和非对称加密算法（如 RSA）的组合来实现。在连接建立阶段，使用非对称加密算法交换对称密钥，然后使用对称密钥进行后续的数据加密和解密，以提高效率。

2. **数据完整性保护**：

* HTTPS 还使用消息认证码（MAC）来确保数据的完整性。接收方可以通过验证 MAC 来确定数据在传输过程中是否被篡改。如果 MAC 验证失败，接收方将拒绝接收数据，从而防止恶意篡改的数据被接受。

**二、身份验证**

1. **服务器身份验证**：

* HTTPS 通过服务器提供的数字证书来验证服务器的身份。数字证书由证书颁发机构（CA）签发，包含服务器的公钥和其他身份信息。
* 客户端在连接到服务器时，会验证服务器证书的真实性。这包括检查证书的颁发机构是否可信、证书是否在有效期内以及证书中的域名是否与服务器的域名匹配等。如果证书验证失败，客户端可能会显示警告或拒绝连接。

2. **客户端身份验证（可选）**：

* 在某些情况下，HTTPS 也可以用于客户端身份验证。例如，在企业内部网络或金融交易等场景中，服务器可能要求客户端提供数字证书或其他身份验证信息，以确保只有授权的用户可以访问资源。

**三、安全连接建立**

1. **握手过程**：

* HTTPS 的连接建立过程包括一个称为“握手”的阶段。在握手过程中，客户端和服务器交换信息，协商加密算法、密钥交换方式和其他安全参数。
* 这个过程确保双方都支持相同的安全协议版本，并能够建立一个安全的连接。握手过程还包括服务器身份验证和密钥交换，为后续的数据传输做好准备。

2. **安全参数协商**：

* 在握手过程中，客户端和服务器协商各种安全参数，如加密算法、密钥长度、MAC 算法等。双方选择最强的安全配置，以确保通信的安全性。
* 这个协商过程是动态的，可以根据客户端和服务器的能力以及安全需求进行调整。

**四、安全优势和应用场景**

1. **安全优势**：

* HTTPS 提供了比 HTTP 更高的安全性，保护用户的隐私和数据安全。它可以防止敏感信息（如密码、信用卡号码、个人信息等）在传输过程中被窃取或篡改。
* 此外，HTTPS 还可以防止中间人攻击，确保客户端和服务器之间的通信是直接的，没有被第三方拦截或篡改。

2. **应用场景**：

* HTTPS 广泛应用于各种场景，包括电子商务、网上银行、社交媒体、企业内部网络等。任何涉及敏感信息传输或需要保护用户隐私的网站或应用都应该使用 HTTPS。
* 搜索引擎也越来越重视 HTTPS，将其作为一个排名因素，鼓励网站所有者采用更安全的协议。

## 重定向

## 重定向 code 是多少，区别是啥 {#p2-redirect-code-what-is-the-difference}

HTTP 重定向是指当客户端访问一个页面时，服务器返回一个重定向状态码，告诉客户端去访问另一个 URL。常见的 HTTP 重定向状态码有以下几种，每个状态码都有其特定的意义和使用场景：

 1. **301 Moved Permanently（永久移动）**

* **含义**：请求的资源已被永久移动到新位置，未来任何对此资源的引用都应使用返回的新 URI。
* **使用场景**：当你永久性地更改了网页的 URL 地址，比如网站改版后结构变化导致 URL 变更。

 2. **302 Found（临时移动）/ 307 Temporary Redirect**

* **含义（302）**：请求的资源临时移到了新的 URI 下，客户端应继续使用原有 URI。
* **含义（307）**：与 302 类似，资源临时从不同的 URI 访问，但保证请求方法（如 POST）不变，307 在 HTTP/1.1 中引入，以明确分清与 302 的本意不同。
* **使用场景**：当资源或页面需要临时性地从不同的 URI 访问时使用，且期望方法和消息主体不改变（特别适用 307）。

 3. **303 See Other（查看其他位置）**

* **含义**：这个状态码用于重定向，目的是让客户端访问新 URI 并使用 GET 方法获取资源，无论原始请求是什么方法。
* **使用场景**：通常用于处理表单提交后的重定向，以避免刷新页面时重复提交表单。

 4. **308 Permanent Redirect（永久重定向）**

* **含义**：类似于 301，但它禁止改变请求的方法。因此，例如，应用在一个 POST 请求上时，接下来的请求仍然是一个 POST 请求。
* **使用场景**：对于需要保留相同 HTTP 方法（如 POST）情况下的永久重定向。

 区分 301/302 与 307/308

* **301 和 308**：这两个状态码表示资源已被永久移动。区别在于 308 要求后续请求使用与原始请求相同的方法。
* **302 和 307**：这两个状态码表示资源临时移动。区别在于 307 明确规定客户端后续请求应使用与原始请求相同的方法，而 302 没有这样的强制规定，但在实际使用中客户端一般会将 POST 请求改变为 GET 请求，从而在一些情况下可能与预期不符。

## 如果在网络带宽一定的情况下， 切片上传感觉和整体上传， 消费的时间应该是差不多的。 这种说法正确吗 {#p3-sliced-upload-feels-like-the-whole-upload-and-consumes-the-same-time-is-this-statement-correct}

这种说法在某些情况下是正确的，但实际上，切片上传相较于整体上传，在多种情况下可能更加高效，即使网络带宽固定。切片上传的优势并不仅仅在于可能节约的时间，还包括以下几点：

 1. **提高上传的可靠性**

* 切片上传允许在遇到网络中断或其他传输错误时只重新上传失败的那一部分，而不是重新上传整个文件。这在大文件传输中尤其重要。

 2. **实现上传进度的精确控制**

* 通过切片上传，可以更精确地控制和显示上传进度，提高用户体验。

 3. **带宽利用率**

* 切片上传可以更有效地管理带宽，尤其是在网络条件不稳定的环境中。通过并行上传多个切片，可以更充分地利用可用带宽，从而在理论上减少等待时间，特别是在高延迟的环境中。

 4. **服务器处理**

* 对于服务器来说，处理多个小文件比处理一个大文件具有更高的灵活性和效率，尤其是在服务器负载高的情况下。此外，小文件的处理错误不会影响到整个文件，使得错误恢复更简单。

 5. **安全性**

* 切片上传还可以增强安全性，因为单个切片的加密和传输比一个大文件来得容易和安全；此外，即使攻击者截获了部分数据，也难以重构出原始文件。

 综合考虑

然而，切片上传也有其缺点，例如增加了客户端和服务器端处理的复杂性，需要正确管理和重组文件的各个部分。此外，在某些情况下（尤其是文件较小时），切片上传相较于整体上传并不会带来明显的时间优势，且可能因为初始化多个连接而略微增加总体上传时间。

所以，是否选择切片上传，取决于文件大小、网络稳定性、服务器能力以及应用场景。对于大文件上传、网络条件不佳或需要高可靠性的场景，切片上传通常是更优的选择。
