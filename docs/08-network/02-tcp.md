# tcp

## tcp 传输过程

TCP（传输控制协议）是一种面向连接的协议，它保证了数据的可靠传输。在 TCP 传输数据时，数据会被分割成一个个的数据包进行传输，具体传输过程如下：

* **建立连接**：TCP 通过三次握手建立连接，即客户端向服务器发送 SYN（同步）数据包，服务器接收到 SYN 后回应一个 SYN-ACK（同步-确认）数据包，客户端再回应一个 ACK（确认）数据包，连接建立成功。

* **数据传输**：数据在应用层被拆分成数据段，在传输层被拆分成数据包（也称为报文段），每个数据包包含源端口号、目标端口号、序列号、确认号、标志位等信息。发送方发送数据包后，等待接收方回复确认信息，如果未收到确认信息，则进行重传，直到接收方成功接收数据包。

* **拥塞控制**：当网络拥塞时，TCP 会采取措施来减少数据的传输速率，如减小窗口大小、降低拥塞窗口等。

* **连接终止**：TCP 通过四次挥手来关闭连接，即客户端发送一个 FIN（终止）数据包，服务器回应一个 ACK 数据包表示接收到 FIN，然后服务器再发送一个 FIN 数据包，客户端回应一个 ACK 数据包表示接收到 FIN，连接关闭成功。

总的来说，**TCP 通过三次握手建立连接、数据分段传输、拥塞控制和四次挥手关闭连接来保证数据的可靠传输**。

细说一下 TCP 通过三次握手建立连接？

TCP通过三次握手建立连接的过程如下：

* **第一次握手**：客户端向服务端发送 `SYN`（同步）包，其中 `SYN=1，seq=x`，表示客户端希望与服务端建立连接，同时指定自己的初始序号为`x`。此时客户端处于 `SYN_SENT` 状态。

* **第二次握手**：服务端接收到 SYN 包后，向客户端发送 `SYN-ACK` 包，其中 SYN=1，`ACK=1，ack=x+1，seq=y`，表示服务端已经收到客户端的请求，同意建立连接，同时指定自己的初始序号为y，确认号为`x+1`。此时服务端处于 `SYN_RCVD` 状态。

* **第三次握手**：客户端收到 SYN-ACK 包后，向服务端发送 `ACK` 包，其中 `SYN=0，ACK=1，ack=y+1，seq=x+1`，表示客户端已经收到服务端的确认，连接建立成功。此时客户端处于 `ESTABLISHED` 状态，服务端也处于 `ESTABLISHED` 状态。

这样就完成了三次握手建立连接的过程。在这个过程中，客户端和服务端都可以向对方发送数据。
需要注意的是，如果客户端在等待服务端的 SYN-ACK 包时超时或未收到响应，会重新发送 SYN 包，直到建立连接或达到最大重试次数。同时，在建立连接后，每个数据包都会在传输时带有序号和确认号，以保证数据的可靠传输。

CP数据分段传输的过程是怎么样的？

* 应用层将需要传输的数据分成适当大小的数据段，每个数据段称为一个TCP数据包。

* TCP协议根据MSS（最大报文长度）将TCP数据包分割成更小的IP数据包，以适应底层网络的MTU（最大传输单元）。

* 在传输数据之前，TCP在每个数据包中添加一个包头（header），其中包含序列号（sequence number）和确认号
（acknowledgment number）等信息。

* 发送方将数据包发送到网络，并等待接收方的确认响应。如果发送方没有收到确认响应，它会重新发送数据包。

* 接收方收到数据包后，会对数据包进行确认，向发送方发送确认响应。如果接收方没有收到正确的数据包，它会要求发送方重发数据。

* 发送方收到确认响应后，会将下一个数据包发送到网络，并等待接收方的确认响应。如果发送方没有收到确认响应，它会重新发送数据包。

* 接收方根据收到的数据包的序列号和确认号，组装数据包，然后将数据包传递给上层应用程序。

TCP数据分段传输可以提高网络的可靠性和稳定性，**避免了数据包的丢失和重传，但是也会造成额外的网络开销。**

CP 是如何进行拥塞控制？

TCP使用拥塞控制算法来避免网络中的拥塞现象，并在发生拥塞时减少发送数据的速率，从而避免网络拥塞的加剧。TCP的拥塞控制算法主要包括以下几个方面：

* **慢启动（Slow Start）**：在TCP连接刚建立时，发送方限制了自己的初始发送窗口大小，从而避免发送过多的数据导致网络拥塞。发送方以指数级别的方式增加其发送窗口大小，直到达到一个阈值，然后就会进入拥塞避免状态。

* **拥塞避免（Congestion Avoidance）**：在拥塞避免状态下，TCP发送方每经过一轮的传输，就将其发送窗口大小增加一个MSS（最大报文段长度）的值。这样可以逐渐增加发送窗口大小，从而提高数据传输速率。

**拥塞检测（Congestion Detection）**：当TCP发送方收到一个超时重传的确认消息时，它就认为网络中出现了拥塞，并将其发送窗口大小减半，然后重新进入慢启动状态。

* **拥塞避免（Congestion Avoidance）**：当TCP发送方收到一个失序的确认消息时，它就知道它发送的某些数据包在网络中已经丢失了，此时就不必等到超时重传定时器时间到期，而是立即重传那些丢失的数据包。

* **快速恢复（Fast Recovery）**：在快速重传后，TCP发送方将进入快速恢复状态，其中发送方的发送窗口大小将设置为丢失数据包的数量加上MSS的值，从而避免了发送窗口大小的降低和慢启动状态的重新启动。

次挥手关闭连接流程如何？

TCP 通过四次挥手来关闭连接，具体过程如下：

* 客户端向服务端发送 FIN 报文，表示客户端不再发送数据。

* 服务端收到 FIN 报文后，向客户端发送 ACK 报文，表示收到了客户端的 FIN 报文。

* 服务端向客户端发送 FIN 报文，表示服务端不再发送数据。

* 客户端收到 FIN 报文后，向服务端发送 ACK 报文，表示收到了服务端的 FIN 报文。

图示如下：

```
客户端 服务端
| |
| FIN(seq=x) |
|--------------------->|
| ACK(seq=x+1,ack=y) |
|<---------------------|
| |
| FIN(seq=y) |
|<---------------------|
| ACK(seq=y+1,ack=x+1)|
|--------------------->|
```

其中，`seq` 表示序号，`ack` 表示确认号。第一次握手中，客户端发送的序号 seq=x，表示客户端的数据流的第一个字节的序号。第二次握手中，服务端发送的确认号 ack=y，表示服务端期望下一个收到的字节的序号是 y。第三次握手中，服务端发送的序号 seq=y，表示服务端的数据流的第一个字节的序号。第四次握手中，客户端发送的确认号 ack=x+1，表示客户端期望下一个收到的字节的序号是 x+1。注意，在第四次握手中，客户端发送 ACK 报文后，不再发送数据，但服务端可能还有数据需要发送，因此服务端需要先发送 FIN 报文。

四次挥手的过程中，最后一个 ACK 报文可能会丢失，因此需要等待一段时间后才能确认连接已经关闭。这个等待时间称为 `TIME_WAIT` 状态，一般为 `2MSL`（Maximum Segment Lifetime，最长报文寿命）时间，即一个报文在网络中最长的生命周期，通常为 2 分钟。

值得注意的是，TCP 的四次挥手过程是可靠的，可以确保数据可靠传输。但由于四次挥手需要消耗额外的时间和网络资源，因此在某些情况下，**可以使用 TCP 的强制断开连接方式（RST），通过发送一个 RST 报文来立即中断连接**。但这种方式可能会导致数据的丢失和损坏，因此应该谨慎使用。

## TCP 和 UDP 的区别和应用场景

TCP、UDP和HTTP关系

1、TCP/IP是个协议组，可分为三个层次：网络层、传输层和应用层。

在网络层有IP协议、ICMP协议、ARP协议、RARP协议和BOOTP协议。
在传输层中有TCP协议与UDP协议。
在应用层有FTP、HTTP、TELNET、SMTP、DNS等协议。
因此，HTTP本身就是一个协议，是从Web服务器传输超文本到本地浏览器的传送协议。

TCP 是基于 TCP 协议实现的网络文本协议,属于传输层。
UDP 是和TCP 对等的，属于传输层，UDP 和 TCP 有重要的区别。

2、HTTP协议是建立在请求/响应模型上的。

首先由客户建立一条与服务器的TCP链接，并发送一个请求到服务器，请求中包含请求方法、URI、协议版本以及相关的MIME样式的消息。
服务器响应一个状态行，包含消息的协议版本、一个成功和失败码以及相关的MIME式样的消息。
HTTP/1.0为每一次HTTP的请求/响应建立一条新的TCP链接，因此一个包含HTML内容和图片的页面将需要建立多次的短期的TCP链接。一次TCP链接的建立将需要3次握手。
另外，为了获得适当的传输速度，则需要TCP花费额外的回路链接时间（RTT）。
每一次链接的建立需要这种经常性的开销，而其并不带有实际有用的数据，只是保证链接的可靠性，
因此HTTP/1.1提出了可持续链接的实现方法。HTTP/1.1将只建立一次TCP的链接而重复地使用它传输一系列的请求/响应消息，因此减少了链接建立的次数和经常性的链接开销。

三次握手的过程:
第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。
第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；ACK:确认字符(Acknowledgement)
第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。

3、结论：虽然HTTP本身是一个协议，但其最终还是基于TCP的。

Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。

![02-05-01](https://user-images.githubusercontent.com/22188674/224473152-067c338d-86d5-48ff-8197-85396a77b3c8.jpg)

HTTPS：（全称：Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。
即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。

优点：**协议较成熟，应用广泛、基于TCP/IP，拥有TCP优点、研发成本很低，开发快速、开源软件较多**，nginx,apache,tomact等
缺点：**无状态、无连接**、只有PULL模式，不支持PUSH、数据报文较大
特性：**基于TCP/IP应用层协议、无状态，无连接**、支持C/S模式、适用于文本传输

 TCP

TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。
一个TCP连接必须要经过三次“对话”才能建立起来，其中的过程非常复杂，我们这里只做简单、形象的介绍，你只要做到能够理解这个过程即可。
我们来看看这三次对话的简单过程：主机A向主机B发出连接请求数据包：“我想给你发数据，可以吗？”，
这是第一次对话；主机B向主机A发送同意连接和要求同步（同步就是两台主机一个在发送，一个在接收，协调工作）的数据包：“可以，你什么时候发？”，这是第二次对话；
主机A再发出一个数据包确认主机B的要求同步：“我现在就发，你接着吧！”，这是第三次对话。
三次“对话”的目的是使数据包的发送和接收同步，经过三次“对话”之后，主机A才向主机B正式发送数据。

TCP：（Transmission Control Protocol，传输控制协议）是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。
一个TCP连接必须要经过三次“对话”才能建立起来，其中的过程非常复杂。
建立一个连接需要三次握手，而终止一个连接要经过四次握手，这是由TCP的半关闭（half-close）造成的。

优点：**可靠性 、全双工协议、开源支持多、应用较广泛、面向连接**、研发成本低、报文内容不限制（IP层自动分包，重传，不大于1452bytes）
缺点：操作系统：较耗内存，支持连接数有限、设计：协议较复杂，自定义应用层协议、网络：网络差情况下延迟较高、传输：效率低于UDP协议特性： 面向连接、可靠性、全双工协议、基于IP层、OSI参考模型位于传输层、适用于二进制传输

**三次握手 与 四次挥手**
当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次挥手”。
1.第一次挥手：主机1(可以使客户端，也可以是服务器端)，设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段;此时，主机1进入FIN_WAIT_1状态;这表示主机1没有数据要发送给主机2了;
2.第二次挥手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1;主机1进入FIN_WAIT_2状态;主机2告诉主机1，我也没有数据要发送了，可以进行关闭连接了;
3.第三次挥手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入CLOSE_WAIT状态;
4.第四次挥手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态;主机2收到主机1的ACK报文段以后，就关闭连接;此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。
至此，TCP的四次挥手就这么愉快的完成了。

 UDP

UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！
UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。
比如，我们经常使用“ping”命令来测试两台主机之间TCP/IP通信是否正常，其实“ping”命令的原理就是向对方主机发送UDP数据包，
然后对方主机确认收到数据包，如果数据包是否到达的消息及时反馈回来，那么网络就是通的。
例如，在默认状态下，一次“ping”操作发送4个数据包（如图2所示）。大家可以看到，发送的数据包数量是4包，
收到的也是4包（因为对方主机收到后会发回一个确认收到的数据包）。这充分说明了UDP协议是面向非连接的协议，
没有建立连接的过程。正因为UDP协议没有连接的过程，所以它的通信效果高；但也正因为如此，它的可靠性不如TCP协议高。
QQ就使用UDP发消息，因此有时会出现收不到消息的情况。

UDP：UDP是一个无连接协议，传输数据之前源端和终端不建立连接，当它想传送时就简单地去抓取来自应用程序的数据，
并尽可能快地把它扔到网络上。在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、计算机的能力和传输带宽的限制；
在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。
优点：操作系统：并发高，内存消耗较低、传输：效率高，网络延迟低、传输模型简单，研发成本低
缺点：协议不可靠、单向协议、开源支持少、报文内容有限，不能大于1464bytes、设计：协议设计较复杂、网络：网络差，而且丢数据报文
特性：无连接，不可靠，基于IP协议层，OSI参考模型位于传输层，最大努力交付，适用于二进制传输

 对比

场景 | TCP | UDP
:- | :- |:-
是否连接 | 面向连接 | 面向非连接
传输可靠性 | 可靠 | 不可靠
应用场合 | 传输大量数据 |少量数据
速度 | 慢 | 快

## tcp 三次握手原理,为什么不是两次握手

## TCP 的拥塞处理机制：慢开始、拥塞避免、快重传、快恢复

## TCP三次握手和四次挥手

## TCP粘包了解多少 {#p0-packet-sticking}

TCP粘包（TCP packet sticking）是指在数据传输过程中，发送方连续发送的若干小数据包被接收方组合成较大的数据块或者多个小数据包粘合在一起接收的现象。

TCP是面向流的传输协议，数据在传输过程中会被拆分成TCP数据段，并在接收方重新组装。由于TCP的流式传输特性，发送方连续发送的多个小数据包可能会在接收方一次性接收，从而导致粘包现象。

TCP粘包的原因主要有以下几点：

1. 发送方连续发送的数据包很小，可能不足以填满一个TCP数据段的大小，导致多个数据包合并在一起发送。

2. 发送方发送数据的速率和接收方处理数据的速率不一致，可能会导致多个数据包在传输过程中一起到达接收方。

TCP粘包可能会导致数据解析错误或者数据处理不准确，影响通信的正确性和性能。为了解决TCP粘包问题，可以采用以下方法：

1. 使用固定长度的数据包：发送方在发送数据前，在数据包中添加固定长度的头部，接收方通过读取固定长度的数据来拆分数据包。

2. 使用特殊字符或者标记符号进行分隔：发送方在数据包之间添加特定的字符或者标记符号作为分隔符，接收方通过识别分隔符来拆分数据包。

3. 使用消息长度字段：发送方在数据包中添加表示消息长度的字段，接收方首先读取消息长度字段，然后根据长度来读取相应长度的数据。

通过采用上述方法，可以有效地解决TCP粘包问题，确保数据在传输过程中的正确性和完整性。

## TCP/IP 如何保证数据包传输的有序可靠 {#p1-sequence}

TCP/IP 采用以下几种机制来保证数据包传输的有序可靠：

1. 确认和重传：每当 TCP/IP 协议收到一个数据包时，将向发送方回送一个确认信息。如果接收方未收到数据包，则发送方将重传该数据包。这种确认和重传的机制可以确保数据包能够可靠地传输，即使在网络故障或拥塞的情况下也能保证数据包的可靠性。

2. 滑动窗口：滑动窗口是 TCP/IP 协议用来控制发送方和接收方之间数据流的一种机制。发送方会将窗口大小告知接收方，接收方在收到数据包时，会回送一个告知发送方可以继续发送数据的指令。滑动窗口机制可以通过有效地控制数据包的发送与接收，实现有序的数据传输。

3. 序列号：每个数据包都会附带一个序列号，接收方通过序列号对数据包进行排序，从而实现传输的有序性。

4. 超时重传时间：TCP/IP 建立了一个计时器，如果在指定时间内没有收到确认信息，则会重新发送未确认的数据包。这种机制可以帮助保证数据包传输的可靠性，确保数据包能够及时被送达。

总之，TCP/IP 协议通过确认和重传、滑动窗口、序列号以及超时重传时间等机制，保证了数据包传输的有序可靠性。这些机制可以确保数据包能够被及时送达，有效地防止了数据包丢失、重复和乱序等问题，从而提供了高效可靠的传输服务。

## 197 A、B 机器正常连接后，B 机器突然重启，问 A 此时处于 TCP 什么状态？(了解即可) {#p1-abonormal-close}

当 B 机器重启时，TCP 连接会被断开，此时 A 机器会检测到 TCP 连接异常断开，将 TCP 状态修改为 FIN\_WAIT\_1 状态。A 机器会继续等待来自 B 机器的响应，如果等待的时间超过了一定时间（通常为几分钟），A 机器会放弃等待并关闭 TCP 连接，将 TCP 状态修改为 CLOSED 状态。
