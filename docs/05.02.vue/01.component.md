# 组件

## VUE 生命周期

## render 函数了解吗？ {#p0-render}

在Vue.js中，`render`是一个用于生成虚拟DOM（VNode）树的函数。它是Vue.js的渲染函数，负责将组件的模板转换为可渲染的VNode树。

`render`函数接收一个上下文对象作为参数，该对象包含了渲染过程中需要的数据和方法。在`render`函数中，我们可以使用Vue.js提供的模板语法（如插值表达式、指令等）来描述组件的视图结构。

`render`函数的主要作用是根据模板和组件的状态生成VNode树，其中包含了组件的结构、属性、事件等信息。通过对VNode树的创建和更新，Vue.js能够实现高效的虚拟DOM diff算法，并将变更应用到实际的DOM上，从而实现组件视图的动态更新。

在Vue.js中，`render`函数有两种使用方式：

1. 基于模板编译：Vue.js会将组件的模板编译为`render`函数。这是Vue.js的默认行为，它会在运行时将模板编译成渲染函数，并将其作为组件的`render`选项。这种方式可以方便地使用模板语法来描述组件的视图结构。

2. 手动编写：开发者可以手动编写`render`函数，而不依赖模板编译。手动编写`render`函数需要熟悉Vue.js的虚拟DOM API和JavaScript语法，可以更精细地控制组件的渲染过程。这种方式适用于需要更高级别的自定义和优化的场景。

`render` 函数是Vue.js的渲染函数，用于生成组件的虚拟DOM树。它接收上下文对象作为参数，根据模板或手动编写的代码逻辑，生成VNode树，实现组件的动态更新和渲染。

**使用示例**

当使用基于模板编译的方式时，Vue.js会将模板编译为`render`函数，并将其作为组件的`render`选项。下面是一个简单的示例：

```vue
<template>
 <div>
 <h1>{{ message }}</h1>
 <button @click="increaseCount">Click me</button>
 </div>
</template>

<script>
export default {
 data() {
 return {
 message: 'Hello, Vue!',
 count: 0
 };
 },
 methods: {
 increaseCount() {
 this.count++;
 }
 },
 render() {
 return (
 <div>
 <h1>{this.message}</h1>
 <button onClick={this.increaseCount}>Click me</button>
 </div>
 );
 }
};
</script>
```

在上面的示例中，模板中的`<template>`标签中的内容会被编译为`render`函数。在`render`函数中，使用了Vue.js的模板语法（如插值表达式和事件绑定），并将其转化为JSX语法。

注意，当使用基于模板编译的方式时，模板中的代码会被编译为`render`函数的形式，而不是直接在组件中使用模板字符串。

另外，**如果你想手动编写`render`函数**，可以在组件的`render`选项中直接编写函数逻辑。以下是手动编写`render`函数的示例：

```vue
<script>
export default {
 data() {
 return {
 message: 'Hello, Vue!',
 count: 0
 };
 },
 methods: {
 increaseCount() {
 this.count++;
 }
 },
 render(h) {
 return h('div', [
 h('h1', this.message),
 h('button', {
 on: {
 click: this.increaseCount
 }
 }, 'Click me')
 ]);
 }
};
</script>
```

在上述示例中，我们通过手动编写`render`函数，使用了Vue.js提供的`h`函数（也可以使用`createElement`函数）来创建VNode节点。这样可以更加灵活地控制组件的渲染逻辑。

无论是基于模板编译还是手动编写，`render`函数都是用来描述组件视图结构的关键部分。通过`render`函数，Vue.js能够将组件的模板或手动编写的代码转化为可执行的VNode树，实现组件的渲染和更新。

 render函数 与 template 之间关系是啥

在Vue.js中，`render`和`template`是两种定义组件视图的方式，它们之间有一定的关系。

`template`是一种更高级别的、声明式的定义组件视图的方式。通过`template`，我们可以使用Vue.js提供的模板语法，描述组件的结构、样式和交互等，例如使用插值表达式、指令、条件渲染、循环等。`template`提供了更直观、易于理解的方式来定义组件的视图。

当使用基于模板编译的方式时，Vue.js会将`template`编译为`render`函数。这个编译过程将模板转换为可执行的JavaScript代码，最终生成VNode树用于组件的渲染。所以，可以说`render`函数是由`template`转化而来的。

`render`函数是一种更底层、编程式的定义组件视图的方式。它使用JavaScript代码直接描述组件的结构，通过创建和组装VNode节点来构建组件的虚拟DOM树。通过手动编写`render`函数，我们可以更加灵活地控制组件的渲染逻辑，但也需要对Vue.js的虚拟DOM API和JavaScript语法有一定的了解。

总结来说，`template`是一种声明式的、更高级别的定义组件视图的方式，而`render`函数是一种编程式的、更底层的定义组件视图的方式。`render`函数可以通过编译`template`生成，也可以手动编写。它们都用于定义组件的视图结构，最终生成VNode树用于组件的渲染和更新。

## 生命周期 {#p0-lifecycle}

最基础生命周期直接可以看下面这个图， 如果只能回答下面这个图里面的生命周期， 那么该问题只能是「中等」级别； 之所以是 「高等」级别的问题， 因为还有很多别的生命周期， 大家不一定知道， 但是也很重要；

![image.png](https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/135d7bede61b4423961c2dfb208f44a7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pm05bCP56-G:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiNDEyNTAyMzM1Nzg5OTM2NyJ9&rk3s=e9ecf3d6&x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018&x-orig-expires=1726649822&x-orig-sign=7AZx17uuMqrw4eKTe%2BJoj%2FHSI4c%3D)

 Vue3 新增的生命周期

* `onErrorCaptured()`
* `onRenderTracked()`
* `onRenderTriggered()`
* `onActivated()`
* `onDeactivated()`
* `onServerPrefetch()`

Vue 3 引入了组合式 API，随之而来的是一系列新的生命周期钩子，这些钩子提供了更细粒度的控制方式，尤其是在使用 `setup()` 函数时非常有用。下面简单解释一下你提到的这几个新的生命周期钩子：

**onErrorCaptured()**

* **作用**：捕获组件及其子组件树中发生的错误。它提供了一个句柄来处理错误，并防止错误继续冒泡。
* **使用场景**：当你需要在组件树中某个层级捕获并处理错误时使用，特别适用于构建错误边界。

**onRenderTracked()**

* **作用**：每当一个响应式依赖被访问时调用，允许开发者跟踪渲染过程中依赖的访问。
* **使用场景**：用于调试目的，帮助开发者理解组件如何响应数据变化，以及哪些依赖触发了组件的重新渲染。

**onRenderTriggered()**

* **作用**：每当响应式依赖的变化导致组件重新渲染时调用。
* **使用场景**：同样用于调试目的，让开发者知道是哪个具体的依赖变化导致了组件的更新。

**onActivated() 和 onDeactivated()**

* **作用**：这两个钩子分别在 `<keep-alive>` 缓存的组件激活和停用时被调用。
* **使用场景**：在使用 `<keep-alive>` 时非常有用，可以用来执行如清理或设置相关资源的操作。

**onServerPrefetch()**

* **作用**：允许组件在服务器端渲染（SSR）期间进行数据预取。
* **使用场景**：用于服务器端渲染的 Vue 应用中，可以在组件级别添加数据预取逻辑，提高首屏加载性能和 SEO 优化。

这些新的生命周期钩子为 Vue 应用提供了更多的灵活性和控制力，允许开发者编写更高效、更可靠的代码。特别是在构建大型应用或需要精细管理资源和错误处理的情况下非常有用。

## v-for 时给每项元素绑定事件需要用事件代理吗？为什么？ {#p1-vue-for}

 Vue 并没有在源码中做代理

vue 并没有在源码中做代理， 至少是 2.x 是没有做事件代理的。但是理论上来说使用事件代理性能会更好一点。

阅读 vue 源码的过程中，并没有发现 vue 会自动做事件代理，但是一般给 v-for 绑定事件时，都会让节点指向同一个事件处理程序（第二种情况可以运行，但是 eslint 会警告），一定程度上比每生成一个节点都绑定一个不同的事件处理程序性能好，但是监听器的数量仍不会变，所以使用事件代理会更好一点。

react 是委托到 document 上, 然后自己生成了合成事件, 冒泡到 document 的时候进入合成事件, 然后他通过 getParent() 获取该事件源的所有合成事件, 触发完毕之后继续冒泡。但是一些特殊的比如focus这种必须放在input这些dom上。

 为何事件代理会让性能好一些

说一下我个人理解，先说结论，可以使用

事件代理作用主要是 2 个

1. 将事件处理程序代理到父节点，减少内存占用率
2. 动态生成子节点时能自动绑定事件处理程序到父节点

这里我生成了十万个 span 节点，通过 performance monitor 来监控内存占用率和事件监听器的数量，对比以下 3 种情况

1. 不使用事件代理，每个 span 节点绑定一个 click 事件，并指向同一个事件处理程序

```html
<div>
 <span 
 v-for="(item,index) of 100000" 
 :key="index" 
 @click="handleClick">
 {{item}}
 </span>
</div>
```

2. 不使用事件代理，每个 span 节点绑定一个 click 事件，并指向不同的事件处理程序

```html
<div>
 <span 
 v-for="(item,index) of 100000" 
 :key="index" 
 @click="function () {}">
 {{item}}
 </span>
</div>
```

3. 使用事件代理

```html
<div @click="handleClick">
 <span 
 v-for="(item,index) of 100000" 
 :key="index">
 {{item}}
 </span>
</div>
```

可以通过 chrome devtools performance monitor 查看内存使用情况

可以看到使用事件代理无论是监听器数量和内存占用率都比前两者要少

 为什么 Vue 不适用事件委托

首先我们需要知道事件代理主要有什么作用？

1. 事件代理能够避免我们逐个的去给元素新增和删除事件
2. 事件代理比每一个元素都绑定一个事件性能要更好

从vue的角度上来看上面两点

* 在v-for中，我们直接用一个for循环就能在模板中将每个元素都绑定上事件，并且当组件销毁时，vue也会自动给我们将所有的事件处理器都移除掉。所以事件代理能做到的第一点vue已经给我们做到了
* 在v-for中，给元素绑定的都是相同的事件，所以除非上千行的元素需要加上事件，其实和使用事件代理的性能差别不大，所以也没必要用事件代理

## 组件通信策略和方法 {#p0-component-communicate}

Vue 父子组件通信

* Prop（常用）
* $emit (组件封装用的较多)
* .sync语法糖 （较少）
* $attrs & $listeners (组件封装用的较多)
* provide & inject （高阶组件/组件库用的较多）
* slot-scope & v-slot （vue@2.6.0+）新增
* scopedSlots 属性
* 其他方式通信

具体使用场景参考链接：[资料](https://juejin.cn/post/6844903700243316749)

 在Vue中 组件之间的通信总结

在Vue中，组件之间的通信可以通过以下几种方式实现：

1. Props/Attributes：父组件通过向子组件传递属性（props），子组件通过props接收父组件传递的数据。这是一种单向数据流的方式。

2. Events/Custom Events：子组件可以通过触发自定义事件（$emit），向父组件发送消息。父组件可以监听子组件的自定义事件，在事件回调中处理接收到的消息。

3. $refs：父组件可以通过在子组件上使用ref属性，获取子组件的实例，并直接调用子组件的方法或访问子组件的属性。

4. Event Bus：通过创建一个全局事件总线实例，可以在任何组件中触发和监听事件。组件之间可以通过事件总线进行通信。

5. Vuex：Vuex是Vue官方提供的状态管理库，用于在组件之间共享状态。组件可以通过Vuex的store来进行状态的读取和修改。

6. Provide/Inject：父组件通过provide选项提供数据，子组件通过inject选项注入数据。这样可以在跨层级的组件中进行数据传递。

 Props/Attributes

在Vue中，可以通过props和attributes来实现组件之间的通信。

1. 使用props：
 父组件可以通过props向子组件传递数据。子组件通过在props选项中声明属性来接收父组件传递的数据。

例如，父组件传递一个名为message的属性给子组件：

```html
<template>
 <div>
 <child-component :message="parentMessage"></child-component>
 </div>
</template>

<script>
import ChildComponent from './ChildComponent.vue';

export default {
 components: {
 ChildComponent
 },
 data() {
 return {
 parentMessage: 'Hello from parent'
 };
 }
};
</script>
```

子组件接收并使用父组件传递的属性：

```html
<template>
 <div>
 {{ message }}
 </div>
</template>

<script>
export default {
 props: {
 message: {
 type: String,
 required: true
 }
 }
};
</script>
```

2. 使用attributes：
 父组件可以通过attributes向子组件传递数据。子组件通过$attrs属性来访问父组件传递的所有属性。

例如，父组件传递一个名为message的属性给子组件：

```html
<template>
 <div>
 <child-component message="Hello from parent"></child-component>
 </div>
</template>

<script>
import ChildComponent from './ChildComponent.vue';

export default {
 components: {
 ChildComponent
 }
};
</script>
```

子组件访问父组件传递的属性：

```html
<template>
 <div>
 {{ $attrs.message }}
 </div>
</template>

<script>
export default {
 inheritAttrs: false
};
</script>
```

这些是使用props和attributes在Vue中实现组件之间通信的示例。通过props可以实现父子组件之间的单向数据流，而通过attributes可以实现更灵活的通信方式。

 Events/Custom Events

在Vue中，可以使用Events/Custom Events（事件/自定义事件）来实现组件之间的通信。以下是一个示例：

1. 在父组件中触发事件：

```html
<template>
 <div>
 <button @click="sendMessage">发送消息给子组件</button>
 <child-component @message-received="handleMessage"></child-component>
 </div>
</template>

<script>
import ChildComponent from './ChildComponent.vue';

export default {
 components: {
 ChildComponent
 },
 methods: {
 sendMessage() {
 this.$emit('message-received', 'Hello from parent');
 },
 handleMessage(message) {
 console.log(message);
 }
 }
};
</script>
```

2. 在子组件中监听事件：

```html
<template>
 <div>
 <p>{{ message }}</p>
 </div>
</template>

<script>
export default {
 data() {
 return {
 message: ''
 };
 },
 mounted() {
 this.$on('message-received', this.handleMessage);
 },
 methods: {
 handleMessage(message) {
 this.message = message;
 }
 }
};
</script>
```

在这个示例中，父组件中有一个按钮，当点击按钮时会触发`sendMessage`方法，该方法通过`$emit`触发名为`message-received`的自定义事件，并传递了一个消息作为参数。

子组件中通过`$on`方法监听`message-received`事件，并在事件触发时调用`handleMessage`方法，该方法用于接收并处理接收到的消息。

通过这种方式，父组件可以通过自定义事件向子组件传递数据，子组件则可以通过监听相应的自定义事件来接收并处理父组件传递的数据。

这是使用Events/Custom Events在Vue中实现组件之间通信的示例。通过自定义事件，可以实现父子组件之间的双向通信。

 $refs

在Vue中，可以使用`$refs`来访问子组件的实例，从而进行组件之间的通信。以下是一个示例：

1. 在父组件中访问子组件的实例：

```html
<template>
 <div>
 <child-component ref="child"></child-component>
 <button @click="sendMessage">发送消息给子组件</button>
 </div>
</template>

<script>
import ChildComponent from './ChildComponent.vue';

export default {
 components: {
 ChildComponent
 },
 methods: {
 sendMessage() {
 this.$refs.child.handleMessage('Hello from parent');
 }
 }
};
</script>
```

2. 子组件中的方法处理接收到的消息：

```html
<template>
 <div>
 <p>{{ message }}</p>
 </div>
</template>

<script>
export default {
 data() {
 return {
 message: ''
 };
 },
 methods: {
 handleMessage(message) {
 this.message = message;
 }
 }
};
</script>
```

在这个示例中，父组件通过在子组件上使用`ref`属性来获取子组件的实例。在父组件的`sendMessage`方法中，通过`this.$refs.child`访问子组件的实例，并调用子组件的`handleMessage`方法，将消息作为参数传递给子组件。

子组件的`handleMessage`方法接收到父组件传递的消息，并更新`message`的值。这样，父组件就可以通过`$refs`来访问子组件的实例，并调用子组件中的方法，从而实现组件之间的通信。

需要注意的是，`$refs`只能用于访问子组件的实例，在父组件中直接修改子组件的数据是不推荐的。更好的做法是在子组件中提供相应的方法，父组件通过`$refs`调用这些方法来进行通信。

 Event Bus

在Vue中，可以使用Event Bus（事件总线）来实现组件之间的通信。Event Bus是一个空的Vue实例，可以用于作为中央事件总线，用于组件之间的通信。以下是一个示例：

1. 创建一个Event Bus实例：

```js
// EventBus.js
import Vue from 'vue'
export const EventBus = new Vue()
```

2. 在需要通信的组件中，使用Event Bus来发送和接收事件：

```html
<template>
 <div>
 <button @click="sendMessage">发送消息给另一个组件</button>
 </div>
</template>

<script>
import { EventBus } from './EventBus.js';

export default {
 methods: {
 sendMessage() {
 EventBus.$emit('messageReceived', 'Hello from Component A');
 }
 }
};
</script>
```

```html
<template>
 <div>
 <p>{{ message }}</p>
 </div>
</template>

<script>
import { EventBus } from './EventBus.js';

export default {
 data() {
 return {
 message: ''
 };
 },
 mounted() {
 EventBus.$on('messageReceived', (message) => {
 this.message = message;
 });
 }
};
</script>
```

在这个示例中，我们首先创建了一个Event Bus实例`EventBus`，并将其导出。然后在发送消息的组件中，通过`EventBus.$emit`方法发送一个名为`messageReceived`的事件，并传递消息作为参数。

在接收消息的组件中，通过在`mounted`钩子中使用`EventBus.$on`方法来监听`messageReceived`事件，并定义一个回调函数来处理接收到的消息。

当发送消息的组件点击按钮时，会触发`sendMessage`方法，该方法通过`EventBus.$emit`发送一个事件，并将消息作为参数传递给该事件。

在接收消息的组件中，`mounted`钩子函数会在组件挂载后执行，此时会调用`EventBus.$on`方法来监听事件。当`messageReceived`事件被触发时，回调函数中的逻辑会执行，将接收到的消息更新到`message`的值上。

这样，通过Event Bus实例，可以实现不同组件之间的通信，组件A通过发送事件，组件B通过监听事件来接收消息。

需要注意的是，使用Event Bus时需要确保事件名称唯一，并在适当的生命周期钩子中进行事件监听和解绑操作，以避免内存泄漏和不必要的事件监听。

 Vuex

在Vue中，可以使用Vuex来进行组件之间的通信。Vuex是一个专为Vue.js应用程序开发的状态管理模式。以下是一个使用Vuex进行组件之间通信的示例：

1. 安装并配置Vuex：
 安装Vuex：`npm install vuex --save`
 创建store.js文件：

```js
import Vue from 'vue'
import Vuex from 'vuex'

Vue.use(Vuex)

export default new Vuex.Store({
  state: {
    message: ''
  },
  mutations: {
    setMessage (state, payload) {
      state.message = payload
    }
  }
})
```

在main.js中引入store.js并注册：

```js
import Vue from 'vue'
import App from './App.vue'
import store from './store.js'

new Vue({
  store,
  render: h => h(App)
}).$mount('#app')
```

2. 在需要通信的组件中，使用Vuex来发送和接收数据：

```html
<template>
 <div>
 <button @click="sendMessage">发送消息给另一个组件</button>
 </div>
</template>

<script>
export default {
 methods: {
 sendMessage() {
 this.$store.commit('setMessage', 'Hello from Component A');
 }
 }
};
</script>
```

```html
<template>
 <div>
 <p>{{ message }}</p>
 </div>
</template>

<script>
export default {
 computed: {
 message() {
 return this.$store.state.message;
 }
 }
};
</script>
```

在这个示例中，我们首先安装并配置了Vuex。

然后，在store.js文件中，我们创建了一个store实例，并定义了一个名为message的状态和一个名为setMessage的mutation，用于更新message的值。

在发送消息的组件中，我们通过`this.$store.commit('mutationName', payload)`的形式来调用mutation，从而更新Vuex的状态。

在接收消息的组件中，我们通过计算属性来获取Vuex中的message状态，并在模板中使用该计算属性来展示消息。

这样，通过Vuex的状态管理，可以实现组件之间的通信。组件A通过调用mutation来更新状态，组件B通过计算属性来获取状态并进行展示。

需要注意的是，在实际应用中，可以根据需求来定义更多的状态和mutations，以满足组件之间的通信需求。

 Provide/Inject

在Vue中，可以使用provide/inject来实现组件之间的通信。provide和inject是Vue的高级特性，可以在祖先组件中提供数据，并在后代组件中注入数据。以下是一个使用provide/inject实现组件之间通信的示例：

父组件：

```html
<template>
 <div>
 <child-component></child-component>
 </div>
</template>

<script>
import ChildComponent from './ChildComponent.vue';

export default {
 components: {
 ChildComponent
 },
 provide() {
 return {
 message: 'Hello from Parent Component'
 };
 }
};
</script>
```

子组件：

```html
<template>
 <div>
 <p>{{ injectedMessage }}</p>
 </div>
</template>

<script>
export default {
 inject: ['message'],
 computed: {
 injectedMessage() {
 return this.message;
 }
 }
};
</script>
```

在这个示例中，父组件通过provide属性提供了一个名为message的数据，值为'Hello from Parent Component'。

子组件通过inject属性注入了父组件提供的message数据，并将其存储在一个名为injectedMessage的计算属性中。

最后，子组件通过模板中的`{{ injectedMessage }}`来展示通过provide/inject传递的数据。

这样，通过provide/inject，父组件可以将数据提供给后代组件，并且后代组件可以通过注入的方式来获取这些数据，实现了组件之间的通信。

需要注意的是，provide/inject是一种上下文注入的方式，因此数据的变化会影响到所有注入了该数据的组件。在实际应用中，要谨慎使用provide/inject，确保数据的使用和变化符合预期。

通过provide/inject，可以在组件之间实现数据的传递和共享，从而实现组件之间的通信。

## template {#p0-template}

整体流程图：
![image](https://user-images.githubusercontent.com/22188674/227268064-b92063be-ca08-419b-9241-d23f7980847c.png)

参考文档：

* [Vue 编译三部曲：如何将 template 编译成 AST ?](https://juejin.cn/post/7116296421816418311)
* [Vue 编译三部曲：模型树优化](https://juejin.cn/post/7117085295798911012)
* [Vue 编译三部曲：最后一曲，render code 生成](https://juejin.cn/post/7121504219588198413)

## ref、toRef 和 toRefs 有啥区别？{#p0-ref-toref-torefs}

在 Vue 3 中，`ref`、`toRef` 和 `toRefs` 是 Vue Composition API 提供的函数，用于处理响应式数据。

1. `ref(value: T): Ref<T>`：创建一个响应式数据引用。接收一个初始值作为参数，并返回一个包含该值的响应式引用。`Ref` 是一个包装对象，它的 `.value` 属性用于访问和修改引用的值。

使用 `ref` 创建响应式数据引用：

```js
import { ref } from 'vue'

const count = ref(0) // 创建一个初始值为 0 的响应式引用

console.log(count.value) // 输出: 0

count.value++ // 修改引用的值
console.log(count.value) // 输出: 1
```

2. `toRef(object: object, key: string | symbol): ToRef`：创建一个指向另一个响应式对象的响应式引用。接收一个响应式对象和其属性名作为参数，并返回一个指向该属性的响应式引用。`ToRef` 是一个只读的响应式引用。

使用 `toRef` 创建指向另一个响应式对象的引用：

```js
import { ref, reactive, toRef } from 'vue'

const state = reactive({
  name: 'John',
  age: 30
})

const nameRef = toRef(state, 'name') // 创建指向 state.name 的引用

console.log(nameRef.value) // 输出: "John"

state.name = 'Mike' // 修改原始对象的属性值
console.log(nameRef.value) // 输出: "Mike"

nameRef.value = 'Amy' // 修改引用的值
console.log(state.name) // 输出: "Amy"
```

3. `toRefs(object: T): ToRefs<T>`：将一个响应式对象的所有属性转换为响应式引用。接收一个响应式对象作为参数，并返回一个包含所有属性的响应式引用对象。`ToRefs` 是一个对象，每个属性都是一个只读的响应式引用。

使用 `toRefs` 将对象的所有属性转换为响应式引用：

```js
import { reactive, toRefs } from 'vue'

const state = reactive({
  name: 'John',
  age: 30
})

const refs = toRefs(state) // 将 state 中的所有属性转换为响应式引用

console.log(refs.name.value) // 输出: "John"
console.log(refs.age.value) // 输出: 30

state.name = 'Mike' // 修改原始对象的属性值
console.log(refs.name.value) // 输出: "Mike"

refs.age.value = 25 // 修改引用的值
console.log(state.age) // 输出: 25
```

这些函数是 Vue 3 Composition API 中用于创建和处理响应式数据的重要工具。通过它们，我们可以更灵活地管理和使用响应式数据。

## nextTick {#p2-nextTick}

`$nextTick` 是 Vue.js 提供的一个实例方法，用于在 DOM 更新之后执行一些操作。具体来说，它会将回调函数推迟到下次 DOM 更新循环之后执行。

在 Vue 中，数据变化时，Vue 会异步执行视图更新。例如，当一个数据变化时，Vue 会将这个变化包装成一个更新任务，并将其推入更新队列。Vue 会在下一个事件循环周期中遍历这个队列，并依次执行更新任务，最终将视图更新为最新状态。

在某些情况下，我们需要在 DOM 更新之后执行一些操作，例如在 Vue 中更新 DOM 后获取更新后的元素尺寸、在 Vue 组件中调用子组件的方法等等。如果直接在数据变化后立即执行这些操作，可能会遇到一些问题，例如元素尺寸并未更新，子组件尚未完全挂载等等。这时候，就需要使用 `$nextTick` 方法。

`$nextTick` 的实现原理是利用了 JavaScript 的事件循环机制。具体来说，当调用 `$nextTick` 方法时，Vue 会将回调函数推入一个回调队列中。在下一个事件循环周期中，Vue 会遍历这个回调队列，并依次执行其中的回调函数。由于在这个时候 DOM 已经完成了更新，因此可以安全地执行需要在 DOM 更新之后进行的操作。

需要注意的是，`$nextTick` 是异步执行的，因此不能保证回调函数会立即执行。如果需要等待 `$nextTick` 的回调函数执行完毕后再继续执行某些操作，可以使用 Promise 或 async/await 来等待异步操作的完成。

在 Vue 中，`nextTick`主要有以下作用和工作原理：

**一、作用**

1. 确保 DOM 更新后执行操作：

* Vue 是异步更新 DOM 的。当你在代码中修改了数据，Vue 不会立即更新 DOM，而是将这些更新操作放入一个队列中，等待下一个“tick”（事件循环的一个周期）再统一进行 DOM 更新。
* 如果在数据变化后，你需要立即操作更新后的 DOM，就可以使用`nextTick`。它会在 DOM 更新完成后执行回调函数，确保你能获取到最新的 DOM 状态。
* 例如，你在修改了一个数据后，想要获取某个元素的新尺寸或位置，就可以在`nextTick`的回调函数中进行操作。

2. 处理异步操作后的 DOM 操作：

* 在一些异步操作（如定时器、Ajax 请求等）之后，如果需要操作 DOM，也可以使用`nextTick`来确保 DOM 已经更新。
* 比如，在一个 Ajax 请求成功后，你想要根据返回的数据更新 DOM，这时可以在请求成功的回调函数中使用`nextTick`来确保 DOM 更新已经完成。

**二、原理**

1. 利用事件循环：

* Vue 的`nextTick`实现利用了 JavaScript 的事件循环机制。在浏览器环境中，JavaScript 是单线程执行的，事件循环负责管理异步任务的执行顺序。
* Vue 将`nextTick`的回调函数放入微任务队列（在 Promise.then、MutationObserver 和 process.nextTick 中执行）或宏任务队列（在 setTimeout、setInterval 和 setImmediate 中执行），具体取决于浏览器的支持情况。
* 当当前执行栈为空时，事件循环会从任务队列中取出任务执行。如果微任务队列中有任务，会先执行微任务队列中的任务，然后再执行宏任务队列中的任务。这样可以确保`nextTick`的回调函数在 DOM 更新之后执行。

2. 内部实现：

* Vue 内部维护了一个异步任务队列，用于存储`nextTick`的回调函数。当调用`nextTick`时，回调函数会被添加到这个队列中。
* Vue 在更新 DOM 后，会检查这个异步任务队列是否为空。如果不为空，会取出队列中的第一个任务并执行它。
* 这样就保证了在 DOM 更新完成后，`nextTick`的回调函数能够按照调用的顺序依次执行。

例如：

```html
<!DOCTYPE html>
<html>
<head>
<script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
</head>

<body>
<div id="app">
<p>{{ message }}</p>
<button @click="updateMessage">Update Message</button>
</div>

<script>
const app = Vue.createApp({
data() {
return {
message: "Hello Vue!",
};
},
methods: {
updateMessage() {
this.message = "Updated Message";
console.log("Before nextTick");
Vue.nextTick(() => {
console.log("After DOM update");
const pElement = document.querySelector("p");
console.log(pElement.textContent);
});
},
},
});

app.mount("#app");
</script>
</body>
</html>
```

在这个例子中，点击按钮后，数据被更新，但立即获取`<p>`元素的文本内容时，还是旧的值。而在`nextTick`的回调函数中获取`<p>`元素的文本内容时，就已经是更新后的新值了。

综上所述，`nextTick`在 Vue 中是一个非常有用的工具，用于确保在 DOM 更新后执行特定的操作，其原理是利用 JavaScript 的事件循环机制来实现异步任务的调度。

## 介绍一下 component 动态组件 {#p4-component-dynamic-component}

在 Vue 中，动态组件是一种强大的特性，可以根据不同的条件在运行时动态地切换组件的显示。

**一、基本概念**

动态组件使用特殊的`<component>`标签结合`is`属性来实现。`is`属性可以接受一个字符串或变量，用于指定要渲染的组件名称或组件选项对象。Vue 会根据`is`属性的值来动态地加载和渲染相应的组件。

**二、使用方法**

1. **使用字符串指定组件名称**：

* 可以直接在`is`属性中使用字符串来指定组件的名称。例如：

```html
<template>
<div>
<component :is="currentComponent"></component>
</div>
</template>
<script setup>
import ComponentA from "./ComponentA.vue";
import ComponentB from "./ComponentB.vue";
let currentComponent = "ComponentA";
</script>
```

* 在这个例子中，根据`currentComponent`变量的值，`<component>`标签会动态地渲染`ComponentA`或`ComponentB`组件。

2. **使用变量指定组件选项对象**：

* 也可以使用变量来指定一个组件选项对象。例如：

```html
<template>
<div>
<component :is="currentComponent"></component>
</div>
</template>
<script setup>
import ComponentA from "./ComponentA.vue";
import ComponentB from "./ComponentB.vue";
let currentComponent = ComponentA;
</script>
```

* 这里，`currentComponent`变量可以在运行时被赋值为`ComponentA`或`ComponentB`的组件选项对象，从而实现动态切换组件。

3. **结合`v-if`或`v-show`控制组件显示**：

* 可以结合`v-if`或`v-show`指令来控制动态组件的显示条件。例如：

```html
<template>
<div>
<component :is="currentComponent" v-if="showComponent"></component>
</div>
</template>
<script setup>
import ComponentA from "./ComponentA.vue";
import ComponentB from "./ComponentB.vue";
let currentComponent = "ComponentA";
let showComponent = true;
</script>
```

* 在这个例子中，只有当`showComponent`为`true`时，动态组件才会被渲染。

**三、优势和应用场景**

1. **优势**：

* **灵活性**：可以根据不同的业务逻辑和用户交互动态地切换组件，提高应用的灵活性和可维护性。
* **代码复用**：可以在多个地方使用相同的动态组件机制，减少重复代码。
* **性能优化**：只在需要的时候加载和渲染特定的组件，可以提高应用的性能。

2. **应用场景**：

* **页面布局切换**：根据用户的操作或应用的状态，动态地切换不同的页面布局组件。例如，在一个管理系统中，根据用户的角色显示不同的菜单栏和功能区域。
* **内容展示切换**：根据数据的类型或状态，动态地展示不同的内容组件。例如，在一个新闻应用中，根据新闻的类型显示不同的新闻详情组件。
* **步骤向导**：在一个多步骤的向导流程中，使用动态组件来逐步展示不同的步骤组件。用户可以根据向导的进度动态地切换到不同的步骤，提高用户体验。

## 详细介绍一下 teleport 内置组件 {#p2-teleport-built-in-component}

在 Vue 中，`<teleport>`是一个内置组件，它提供了一种将组件的模板内容渲染到指定 DOM 节点位置的方式，而不是在组件自身的位置渲染。

**一、作用与优势**

1. 灵活布局：允许你将特定的组件内容放置在页面的任何位置，而不受组件层次结构的限制。这对于创建模态框、通知、工具提示等需要在特定位置显示的元素非常有用。
2. 分离关注点：可以将与特定功能相关的模板内容从组件的逻辑中分离出来，并将其渲染到合适的位置。这样可以使组件的代码更加清晰和易于维护。
3. 性能优化：在某些情况下，将某些内容渲染到远离其他组件的位置可以减少不必要的重绘和回流，提高性能。

**二、使用方法**

1. 基本用法：

```vue
<template>
<div>
<teleport to="body">
<div class="modal">This is a modal content.</div>
</teleport>
</div>
</template>

<style>
.modal {
position: fixed;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
background-color: white;
padding: 20px;
border: 1px solid #ccc;
}
</style>
```

在这个例子中，`<teleport>`组件将包含模态框内容的`<div>`渲染到了`<body>`元素中，使其在页面上居中显示。

2. 指定目标选择器：
可以使用任何有效的 CSS 选择器作为`to`属性的值来指定目标位置。例如：

```vue
<template>
<div>
<teleport to="#my-target-element">
<div class="notification">This is a notification.</div>
</teleport>
</div>
</template>
```

这里将通知内容渲染到具有`id`为`my-target-element`的元素中。

3. 动态目标：
可以使用响应式数据来动态地确定`<teleport>`的目标位置。例如：

```vue
<template>
<div>
<input v-model="targetElementId" />
<teleport :to="targetElementId">
<div class="dynamic-content">This content will be teleported to the specified element.</div>
</teleport>
</div>
</template>

<script setup>
import { ref } from "vue";

const targetElementId = ref("body");
</script>
```

在这个例子中，用户可以通过输入框输入目标元素的`id`，从而动态地确定`<teleport>`的目标位置。

**三、注意事项**

1. 事件冒泡：当在`<teleport>`内部的元素上触发事件时，事件会按照正常的 DOM 事件冒泡机制传播到目标位置的父元素中。如果需要处理这些事件，确保在目标位置的父元素中正确地监听和处理这些事件。
2. 样式隔离：如果`<teleport>`内部的内容需要特定的样式，确保这些样式不会影响到目标位置的其他元素。可以使用 CSS 模块化、命名空间或特定的选择器来确保样式的隔离。
3. 响应式数据：如果在`<teleport>`内部使用了响应式数据，确保这些数据在目标位置的上下文中也能正确地更新。可以使用 Vue 的响应式系统来确保数据的一致性。

## vue 如何配置全局使用的定义或者常量 {#p3-how-to-configure-global-definitions-or-constants-in-vue}

在 Vue 中，可以通过以下几种方式配置全局使用的定义或常量：

**一、使用 Vue 原型（不推荐在 Vue 3 中使用）**

在 Vue 2 中，可以通过在`main.js`文件中向 Vue 的原型上添加属性来实现全局定义或常量的访问。但在 Vue 3 中不推荐这种方式，因为它可能会导致一些潜在的问题。

```js
// Vue 2 示例
Vue.prototype.$globalConstant = 'This is a global constant'
```

**二、使用 provide/inject（推荐）**

1. 在根组件中提供全局定义或常量：

```js
import { createApp } from 'vue'

const app = createApp({
  setup () {
    return {
      globalValue: 'Global value'
    }
  },
  provide () {
    return {
      global: this.globalValue
    }
  }
})

app.mount('#app')
```

2. 在子组件中注入并使用：

```vue
<script setup>
import { inject } from "vue";

const global = inject("global");
</script>

<template>
<div>{{ global }}</div>
</template>
```

**三、创建全局变量文件并导入**

1. 创建一个专门的文件用于存储全局定义或常量，例如`globals.js`：

```js
export const globalConstant = 'This is a global constant'
```

2. 在需要使用的地方导入：

```js
import { globalConstant } from './globals.js'
```

**四、使用 Vuex（状态管理）**

如果你的全局定义或常量需要在多个组件之间共享并且可能会发生变化，可以考虑使用 Vuex 进行状态管理。

1. 安装和设置 Vuex：

```bash
npm install vuex@next
```

创建一个`store.js`文件：

```js
import { createStore } from 'vuex'

const store = createStore({
  state: {
    globalValue: 'Global value from Vuex'
  },
  mutations: {},
  actions: {},
  modules: {}
})

export default store
```

2. 在`main.js`中引入并挂载 Vuex：

```js
import { createApp } from 'vue'
import App from './App.vue'
import store from './store'

const app = createApp(App)
app.use(store)
app.mount('#app')
```

3. 在组件中使用：

```vue
<script setup>
import { useStore } from "vuex";

const store = useStore();
</script>

<template>
<div>{{ store.state.globalValue }}</div>
</template>
```

## 如何自定义指令 {#p2-how-to-customize-directives}

在 Vue 中，可以通过以下步骤来自定义指令：

**一、全局自定义指令**

1. 使用`Vue.directive()`方法定义全局指令：

```js
Vue.directive('my-directive', {
// 指令的定义对象
  bind (el, binding, vnode) {
    // 在元素绑定指令时调用
    // el 是指令所绑定的元素
    // binding 包含指令的信息，如 value、arg、modifiers 等
    // vnode 是虚拟节点
  },
  inserted (el, binding, vnode) {
    // 被绑定元素插入父节点时调用
  },
  update (el, binding, vnode, oldVnode) {
    // 当组件更新时调用，包括数据更新和组件本身的更新
  },
  componentUpdated (el, binding, vnode, oldVnode) {
    // 组件及其子组件的 VNode 更新后调用
  },
  unbind (el, binding, vnode) {
    // 指令与元素解绑时调用
  }
})
```

2. 在模板中使用自定义指令：

```html
<div v-my-directive="someValue"></div>
```

**二、局部自定义指令**

1. 在组件中定义局部指令：

```js
export default {
  directives: {
    'my-directive': {
      bind (el, binding, vnode) {
        // 指令定义
      }
    }
  }
}
```

2. 在组件的模板中使用局部自定义指令：

```html
<template>
<div v-my-directive="someValue"></div>
</template>
```

**三、指令定义对象的参数说明**

1. `el`：指令所绑定的元素，可以通过这个参数来操作元素的属性、样式等。
2. `binding`：一个对象，包含以下属性：

* `value`：指令的绑定值，例如在`v-my-directive="someValue"`中，`value`就是`someValue`的值。
* `arg`：指令的参数，如果指令是`v-my-directive:argName`，那么`arg`就是`argName`。
* `modifiers`：一个对象，包含指令的修饰符。

3. `vnode`：虚拟节点，代表指令所绑定的元素的虚拟节点。
4. `oldVnode`：上一个虚拟节点，仅在`update`和`componentUpdated`钩子中可用。

**四、自定义指令的应用场景**

1. 操作 DOM 元素：例如，在特定条件下为元素添加或移除类名、设置样式、监听元素的事件等。
2. 实现复杂的交互效果：比如拖拽、缩放、滚动监听等。
3. 数据格式化：在将数据绑定到元素之前对数据进行格式化处理。

## 介绍一下动态插槽名 {#p2-introduce-dynamic-slot-names}

在 Vue 3 中，动态插槽名允许在运行时根据特定的条件动态地确定插槽的名称，从而为组件的渲染提供了更大的灵活性。

 **一、基本概念**

通常情况下，插槽名在组件定义时是固定的。但在某些场景中，可能需要根据不同的情况动态地选择要渲染的插槽。Vue 3 引入了动态插槽名的特性，使得可以在运行时动态地确定插槽的名称。

 **二、使用方法**

1. 在子组件中接收动态插槽：

 ```vue
 <template>
 <div>
 <slot :name="dynamicSlotName"></slot>
 </div>
 </template>

 <script setup>
 import { ref } from "vue";
 const dynamicSlotName = ref("defaultSlot");
 </script>
 ```

 在这个子组件中，通过`ref`定义了一个名为`dynamicSlotName`的响应式变量，用于动态确定插槽的名称。

2. 在父组件中使用动态插槽名：

 ```vue
 <template>
 <ChildComponent>
 <template v-for="slotName in slotNames" :key="slotName" #[slotName]>
 <!-- 根据不同的插槽名渲染不同的内容 -->
 <p v-if="slotName === 'slot1'">Content for slot1</p>
 <p v-else-if="slotName === 'slot2'">Content for slot2</p>
 </template>
 </ChildComponent>
 </template>

 <script setup>
 import { ref } from "vue";
 const slotNames = ref(["slot1", "slot2"]);
 </script>
 ```

 在父组件中，使用`v-for`循环遍历一个包含插槽名的数组，并根据不同的插槽名渲染不同的内容。通过这种方式，可以动态地将内容传递给子组件的不同插槽。

 **三、优势**

1. 灵活性：可以根据不同的条件动态地选择要渲染的插槽，使得组件能够适应各种复杂的场景。
2. 可扩展性：在需要根据不同的情况展示不同的内容时，动态插槽名提供了一种简洁而强大的方式，无需为每个可能的情况创建单独的组件。
3. 代码复用：通过动态插槽名，可以在不同的组件中复用相同的逻辑，只需要在父组件中根据不同的需求传递不同的插槽名即可。

## 介绍一下条件插槽 {#p2-introduce-conditional-slots}

可以查看官网: [资料](https://cn.vuejs.org/guide/components/slots#conditional-slots)

在 Vue 中，条件插槽可以通过结合使用 `$slots` 属性与 `v-if` 来实现动态地根据特定条件渲染不同的内容到插槽中。

**一、基本概念**

条件插槽允许在父组件向子组件传递内容时，根据一定的条件来决定渲染哪个插槽的内容。通过使用 `$slots` 属性可以访问子组件中的插槽内容，然后结合 `v-if` 进行条件判断来选择要渲染的部分。

**二、使用方法**

1. 在子组件中定义插槽：

 ```html
 <template>
 <div>
 <slot v-if="$slots.conditionalSlot" name="conditionalSlot"></slot>
 <slot v-else name="defaultSlot"></slot>
 </div>
 </template>
 ```

 在这个子组件中，定义了两个插槽，一个名为 `conditionalSlot`，另一个名为 `defaultSlot`。通过判断 `$slots.conditionalSlot` 是否存在来决定渲染哪个插槽。

2. 在父组件中使用条件插槽：

 ```html
 <template>
 <ChildComponent>
 <template v-if="someCondition" #conditionalSlot>
 <!-- 条件成立时要渲染的内容 -->
 <p>Conditional content</p>
 </template>
 <template v-else #defaultSlot>
 <!-- 条件不成立时要渲染的内容 -->
 <p>Default content</p>
 </template>
 </ChildComponent>
 </template>
 ```

 在父组件中，根据 `someCondition` 的值来决定向子组件的插槽中传递不同的内容。当 `someCondition` 为真时，传递名为 `conditionalSlot` 的插槽内容；当 `someCondition` 为假时，传递名为 `defaultSlot` 的插槽内容。

**三、优势**

1. 动态性：可以根据不同的条件动态地渲染不同的内容，使组件更加灵活适应各种场景。
2. 可维护性：将不同情况下的内容分别组织在不同的模板中，使得代码更加清晰易读，便于维护。
3. 代码复用：通过条件插槽，可以在不同的场景下复用同一个子组件，只需要在父组件中根据不同的条件传递不同的内容即可。

## 事件修饰符 {#p2-input-binding-modifiers}

在 Vue 中，事件修饰符是一些由点 (.) 开头的特殊后缀，用于指示 Vue 对 DOM 事件进行某种特殊处理。Vue 提供了一系列的默认事件修饰符来帮助开发者更方便地处理一些常见的 DOM 事件行为。

下面是 Vue 3 中提供的一些默认事件修饰符：

| 事件修饰符 | 描述 |
| ---------- | ------------------------------------------------------------------------ |
| `.stop` | 调用 `event.stopPropagation()` 阻止事件冒泡。 |
| `.prevent` | 调用 `event.preventDefault()` 阻止默认事件行为。 |
| `.capture` | 使用事件捕获模式添加事件监听器，而不是冒泡模式。 |
| `.self` | 仅当事件是从事件绑定的元素本身触发时才触发回调。 |
| `.once` | 事件只触发一次，之后移除事件监听器。 |
| `.passive` | 以 `{ passive: true }` 模式添加监听器，表示不会调用 `preventDefault()`。 |

这些修饰符可以单独使用，也可以组合使用。以下是一些示例：

```html
<!-- 阻止点击事件冒泡 -->
<button @click.stop="doThis">Stop Propagation</button>

<!-- 提交事件不再重载页面 -->
<form @submit.prevent="onSubmit">Prevent Default</form>

<!-- 修饰符链 -->
<a @click.stop.prevent="doThat">Stop Propagation and Prevent Default</a>

<!-- 只在 @click.self 表达式中的元素本身（而非子元素）触发时调用 doThat -->
<div @click.self="doThat">Only Trigger on Self</div>

<!-- 点击事件将只触发一次 -->
<button @click.once="doOnce">Trigger Once</button>
```

使用这些事件修饰符可以使你的事件处理逻辑更简洁和直观，同时也能够实现一些复杂的事件处理方式。

在 Vue 中，`.lazy` 是一个输入绑定修饰符，用于 `v-model` 指令。它的主要作用是改变数据同步的时机：默认情况下，使用 `v-model` 绑定的输入字段会在每次 `input` 事件触发时同步数据（即用户输入时实时同步），而通过添加 `.lazy` 修饰符后，数据同步会改为在 `change` 事件发生时才进行，通常这意味着在输入字段失去焦点或按下回车键后。

 使用 `.lazy` 修饰符的好处

* **性能优化**：对于一些性能敏感的应用，或者当输入操作导致重度计算时，减少数据同步的频率可以提升性能。
* **用户体验**：在一些场景下，可能希望用户完成输入后（例如填写完整的表单字段后）再收集数据，使用 `.lazy` 可以提升这类体验。
* **减少数据校验**：如果你在输入数据时进行校验或处理，使用 `.lazy` 可以减少这种校验的频率，仅在用户完成输入时执行。

 示例

```html
<!-- 在输入框失去焦点或用户按下回车后，才更新 data 的 message 属性 -->
<input v-model.lazy="message" />
```

在这个例子中，不会在每次用户输入时同步 `message` 的值，而是在输入框失去焦点，或用户按下回车键时同步，这可以减少数据同步的次数，适用于不需要实时更新数据，或更新操作比较昂贵的场景。

总之，`.lazy` 修饰符提供了一种简便的方式来优化数据绑定的行为，尤其是在你希望控制数据更新频率，或者当实时更新不是必要时非常有用。

`.exact` 修饰符在 Vue 事件处理中起着非常特定的作用。它允许控制触发事件处理器的确切方式，确保只有在指定的系统修饰键（如 `ctrl`、`alt`、`shift`、`meta`）组合完全匹配时，事件处理函数才会被触发。这意味着，如果你绑定了 `.exact` 修饰符到一个事件上，只有在没有其他未指定的修饰键被按下的情况下，该事件才会被触发。

 使用场景

`.exact` 修饰符非常有用，尤其是在你想要精确控制事件触发条件的时候。例如，你可能有以下场景：

* 当用户严格只按下 `ctrl` 键时触发一个动作，如果用户同时按下了 `ctrl` 和 `shift`，则不触发。

 示例

```html
<!-- 只有当没有任何其他键被同时按下时，点击才会调用 doThis -->
<button @click.exact="doThis">No Modifier Key</button>

<!-- 只有当仅按下 ctrl 键时点击才会调用 doThat -->
<button @click.ctrl.exact="doThat">Ctrl + Click Only</button>
```

在第一个例子中，点击按钮将只在没有按下 `ctrl`、`alt`、`shift` 或 `meta` 键的情况下触发 `doThis` 方法。在第二个例子中，`doThat` 方法只会在严格按下 `ctrl` 键时触发点击事件。

## 如何处理异步加载组件 {#p1-async-loading-components}

在 Vue 应用中，异步组件是指那些在声明时不会立即加载，而是在需要的时候才加载的组件。使用异步组件能够帮助你提高应用的加载速度和性能，特别是在处理大型应用和路由懒加载时。Vue 提供了几种处理异步加载组件的方法。

 Vue 3 中处理异步组件的方法

 使用 `defineAsyncComponent` 方法

Vue 3 提供了 `defineAsyncComponent` 方法，使得定义和使用异步组件变得简单。你可以通过传递一个函数，该函数返回一个 `import()` 调用（返回 Promise），来动态加载组件。

```js
import { defineAsyncComponent } from 'vue'

const AsyncComponent = defineAsyncComponent(() => import('./components/AsyncComponent.vue'))

// 在组件中使用
export default {
  components: {
    AsyncComponent
  }
}
```

 加载状态处理

你还可以使用 `defineAsyncComponent` 的高级用法，提供一个对象来处理加载状态，如显示加载中的提示、错误处理和超时处理。

```js
const AsyncComponent = defineAsyncComponent({
  // 加载异步组件的工厂函数
  loader: () => import('./components/AsyncComponent.vue'),
  // 加载中时要使用的组件
  loadingComponent: LoadingComponent,
  // 加载失败时要使用的组件
  errorComponent: ErrorComponent,
  // 在显示 loadingComponent 之前的延迟 | 默认值：200（毫秒）
  delay: 200,
  // 如果提供了超时时间（毫秒），超时后将显示错误组件 | 默认值：Infinity
  timeout: 3000
})
```

 Vue 2 中处理异步组件的方法

在 Vue 2 中，异步组件的定义略有不同，你可以直接在组件注册时提供一个返回 Promise 的工厂函数。

```js
Vue.component('async-component', () => import('./components/AsyncComponent.vue'))
```

或者为了处理加载状态，可以提供一个高级的对象形式：

```js
Vue.component('async-component', (resolve, reject) => ({
  // 需要加载的组件 (应该是一个 Promise)
  component: import('./components/AsyncComponent.vue'),
  // 异步组件加载时使用的组件
  loading: LoadingComponent,
  // 加载失败时使用的组件
  error: ErrorComponent,
  // 展示加载中组件前的等待时间。默认：200ms。
  delay: 200,
  // 如果提供了超时时间 (毫秒)，超时后会显示错误组件。默认：Infinity
  timeout: 3000
}))
```

## 3.x 中 app.config 有哪些应用配置？ {#p4-app-config-has-which-application-configuration}

确实，在 Vue 3 中，`app.config` 提供了一系列的应用级别的配置选项，用于自定义或调整 Vue 应用的行为。你提到的这些配置项都是 `app.config` 的一部分，下面是关于它们的详细介绍：

 `app.config.errorHandler`

* **作用**：为未捕获的异常定义一个全局的处理函数。这在集中处理组件渲染或观察者(watchers)中的异常时非常有用。
* **示例**：

```js
// app.config.errorHandler = (err, instance, info) => {
//   // 处理错误
//   console.log('nop')
// }
```

 `app.config.warnHandler`

* **作用**：为 Vue 运行时警告定义一个全局的处理函数，允许你在开发过程中自定义处理警告的方式。
* **示例**：

```js
app.config.warnHandler = (msg, instance, trace) => {
  // 处理警告
}
```

 `app.config.performance`

* **作用**：开启性能追踪。在开发模式下启用，能够测量和追踪组件的初始化、编译时间等性能指标。
* **示例**：

```js
app.config.performance = true
```

 `app.config.compilerOptions`

* **作用**：允许自定义编译器选项，如模板中的自定义指令等。这对于更细致地控制模板的编译过程很有帮助。
* **示例**：

```js
app.config.compilerOptions = {
  // 编译器配置
}
```

 `app.config.globalProperties`

* **作用**：定义全局可用的属性。这在 Vue 2 中通过 `Vue.prototype` 实现，Vue 3 中通过 `app.config.globalProperties` 实现。
* **示例**：

```js
app.config.globalProperties.$utils = {
  // 一些全局方法或属性
}
```

 `app.config.optionMergeStrategies`

* **作用**：自定义选项的合并策略。允许你为自定义选项指定如何合并父子选项。
* **示例**：

 ```js
 app.config.optionMergeStrategies.myOption = (parent, child) => {
 // 合并策略
 }
 ```

 `app.config.idPrefix`

* **作用**：配置此应用中通过 useId() 生成的所有 ID 的前缀。由 3.5+ 版本引入。
* **示例**：

```js
app.config.idPrefix = 'custom-'

// 在组件中：
const id1 = useId() // 'my-app:0'
const id2 = useId() // 'my-app:1'
```

 `app.config.throwUnhandledErrorInProduction`

* **作用**：强制在生产模式下抛出未处理的错误。 由 3.5+ 版本引入。

默认情况下，在 Vue 应用中抛出但未显式处理的错误在开发和生产模式下有不同的行为：

在开发模式下，错误会被抛出并可能导致应用崩溃。这是为了使错误更加突出，以便在开发过程中被注意到并修复。

在生产模式下，错误只会被记录到控制台以尽量减少对最终用户的影响。然而，这可能会导致只在生产中发生的错误无法被错误监控服务捕获。

通过将 app.config.throwUnhandledErrorInProduction 设置为 true，即使在生产模式下也会抛出未处理的错误。

这些应用级配置选项提供了对 Vue 应用的高度控制，允许开发者根据实际需要调整 Vue 的默认行为。在使用时，建议根据项目实际情况和需求进行选择性地配置。

## scope 是怎么做的样式隔离的 {#p2-scope}

Vue 中的样式隔离是通过 Vue 单文件组件（Single File Components，简称 SFC）的 `<style>` 标签中的 `scoped` 属性实现的。当你在一个 Vue 组件的 `<style>` 标签上添加 `scoped` 属性时，Vue 会自动将该样式限定在当前组件的范围内，从而防止样式冲突和不必要的样式泄漏。

 实现原理

Vue 在编译带有 `scoped` 属性的 `<style>` 标签时，会按照以下步骤处理样式隔离：

1. **生成唯一的作用域 ID**：Vue 为每个带有 `scoped` 属性的组件生成一个唯一的作用域 ID（如 `data-v-f3f3eg9`）。这个 ID 是随机的，确保每个组件的作用域 ID 是独一无二的。

2. **添加作用域 ID 到模板元素**：Vue 会在编译组件模板的过程中，将这个作用域 ID 作为自定义属性添加到组件模板的所有元素上。例如，如果作用域 ID 是 `data-v-f3f3eg9`，那么在该组件模板的所有元素上都会添加一个属性 `data-v-f3f3eg9`。

3. **修改 CSS 选择器**：对于组件内部的每个 CSS 规则，Vue 会自动转换其选择器，使其仅匹配带有对应作用域 ID 的元素。这是通过在 CSS 选择器的末尾添加相应的作用域 ID 属性选择器来实现的。例如，如果 CSS 规则是 `.button { color: red; }`，并且作用域 ID 是 `data-v-f3f3eg9`，那么该规则会被转换成 `.button[data-v-f3f3eg9] { color: red; }`。

 示例

假设有如下 Vue 单文件组件：

```vue
<template>
 <button class="btn">Click Me</button>
</template>

<style scoped>
.btn {
 background-color: red;
}
</style>
```

编译后，CSS 规则会变成类似于这样（注意：实际的作用域 ID 是随机生成的）：

```css
.btn[data-v-f3f3eg9] {
 background-color: red;
}
```

并且模板里的 `<button>` 元素会被编译为类似这样：

```html
<button class="btn" data-v-f3f3eg9>Click Me</button>
```

这样，`.btn` 样式规则只会应用到当前组件中的 `<button>` 元素上，而不会影响到其他组件中的同类元素，实现了样式隔离。

 注意事项

* 由于样式隔离是通过属性选择器和自定义属性实现的，因此这种方法的性能可能会略低于全局样式规则。
* `scoped` 样式不能影响子组件，仅限于当前的组件。如果需要影响子组件，则需要使用深度选择器（`>>>` 或 `/deep/`）。
* 其他 Web 组件技术如 Shadow DOM 也可以提供样式隔离的功能，但 Vue 选择了这种不需要 polyfill、兼容性更好的实现方式。

在 Vue 中，`.vue` 单文件组件的 `<style>` 标签可以添加一个 `scoped` 属性来实现样式的隔离。通过这个 `scoped` 属性，Vue 会确保样式只应用到当前组件的模板中，而不会泄漏到外部的其他组件中。

这个效果是通过 PostCSS 在构建过程中对 CSS 进行转换来实现的。基本原理如下：

 Scoped Styles 的工作原理

1. 当你为 `<style>` 标签添加 `scoped` 属性时，Vue 的加载器（比如 `vue-loader`）会处理你的组件文件。

2. `vue-loader` 使用 PostCSS 来处理 `scoped` 的 CSS。它为组件模板内的每个元素添加一个独特的属性（如 `data-v-f3f3eg9`）。这个属性是随机生成的，确保唯一性（是在 Vue 项目构建过程中的 hash 值）。

3. 同时，所有的 CSS 规则都会被更新，以仅匹配带有相应属性选择器的元素。例如：如果你有一个 `.button` 类的样式规则，它会被转换成类似 `.button[data-v-f3f3eg9]` 的形式。这确保了样式只会被应用到拥有对应属性的 DOM 元素上。

 示例

假设你在组件 `MyComponent.vue` 内写了如下代码：

```html
<template>
 <button class="btn">Click Me</button>
</template>

<style scoped>
 .btn {
 background-color: blue;
 }
</style>
```

`vue-loader` 将处理上述代码，模板中的 `<button>` 可能会渲染成类似下面的 HTML：

```html
<button class="btn" data-v-f3f3eg9>Click Me</button>
```

CSS 则会被转换成：

```css
.btn[data-v-f3f3eg9] {
 background-color: blue;
}
```

因此，`.btn` 类的样式仅会应用于拥有 `data-v-f3f3eg9` 属性的 `<button>` 元素上。

 注意

* Scoped styles 提供了样式封装，但不是绝对的隔离。子组件的根节点仍然会受到父组件的 `scoped` CSS 的影响。在子组件中使用 `scoped` 可以避免这种情况。
* Scoped CSS 不防止全局样式影响组件。如果其他地方定义了全局样式，它们仍然会应用到组件中。
* 当使用外部库的类名时，`scoped` 可能会导致样式不被应用，因为它会期望所有匹配规则的元素都带有特定的属性。

总的来说，Scoped Styles 是 Vue 单文件组件提供的一种方便且有效的样式封装方式，通过 PostCSS 转换和属性选择器来实现组件之间的样式隔离。

## keepalive {#p0-keepalive}

`<keep-alive>` 是 Vue.js 提供的一个抽象组件，它可以使被包含的组件保留在内存中，而不是每次重新渲染的时候销毁并重建，从而提高了应用的性能。

具体来说，`<keep-alive>` 的实现原理如下：

1. 当一个组件被包裹在 `<keep-alive>` 组件内时，它会被缓存起来，而不是被销毁。
2. 如果这个组件被包裹的父组件从它的视图中移除，那么这个组件不会被销毁，而是被缓存起来。
3. 如果这个组件再次被包裹的父组件添加回视图中，那么它会被重新激活，而不是重新创建。

`<keep-alive>` 组件通过一个内部的缓存对象来缓存组件实例，这个缓存对象会在组件被包裹在 `<keep-alive>` 组件中时创建。当一个被缓存的组件需要被激活时，`<keep-alive>` 组件会从缓存中取出该组件的实例并将其挂载到视图上，从而实现了组件的复用。

需要注意的是，被缓存的组件并不是一直存在于内存中，它们会在一定条件下被销毁，比如缓存的组件数量超过了一定的阈值，或者系统内存占用过高等。

## 异常处理机制有哪些 {#p0-exception-process}

Vue的错误处理机制主要包括以下几个方面：

1. `Error Capturing（错误捕获）`：Vue提供了全局错误处理的钩子函数`errorCaptured`，可以在组件层级中捕获子组件产生的错误。通过在父组件中使用`errorCaptured`钩子函数，可以捕获子组件中的错误，并对其进行处理或展示错误信息。

2. `Error Boundary（错误边界）`：Vue 2.x中没有内置的错误边界机制，但你可以通过自定义组件来实现。错误边界是一种特殊的组件，它可以捕获并处理其子组件中的错误。错误边界组件使用`errorCaptured`钩子函数来捕获子组件中的错误，并使用`v-if`或`v-show`等指令来显示错误信息或替代内容。

3.`异常处理`：在Vue组件的生命周期钩子函数中，可以使用`try-catch`语句捕获并处理可能出现的异常。例如，在`mounted`钩子函数中进行接口请求，可以使用`try-catch`来捕获请求过程中的异常，并进行相应的处理。

4. `错误提示和日志记录`：在开发环境中，Vue会在浏览器的控制台中输出错误信息，以方便开发者进行调试。在生产环境中，可以使用日志记录工具（如Sentry）来记录错误信息，以便及时发现和解决问题。

**代码举例**

以下是使用代码举例说明以上四种Vue错误处理方式的示例：

1. Error Capturing（错误捕获）：

```vue
// ParentComponent.vue
<template>
 <div>
 <ChildComponent />
 <div v-if="error">{{ error }}</div>
 </div>
</template>

<script>
export default {
 data() {
 return {
 error: null
 };
 },
 errorCaptured(err, vm, info) {
 this.error = err.toString(); // 将错误信息存储在父组件的data中
 return false; // 阻止错误继续向上传播
 }
};
</script>
```

2. Error Boundary（错误边界）：

```vue
// ErrorBoundary.vue
<template>
 <div v-if="hasError">
 Oops, something went wrong.
 <button @click="resetError">Retry</button>
 </div>
 <div v-else>
 <slot></slot>
 </div>
</template>

<script>
export default {
 data() {
 return {
 hasError: false
 };
 },
 errorCaptured() {
 this.hasError = true;
 return false;
 },
 methods: {
 resetError() {
 this.hasError = false;
 }
 }
};
</script>

// ParentComponent.vue
<template>
 <div>
 <ErrorBoundary>
 <ChildComponent />
 </ErrorBoundary>
 </div>
</template>
```

3. 异常处理：

```vue
// ChildComponent.vue
<template>
 <div>{{ data }}</div>
</template>

<script>
export default {
 data() {
 return {
 data: null
 };
 },
 mounted() {
 try {
 // 模拟接口请求
 const response = await fetch('/api/data');
 this.data = await response.json();
 } catch (error) {
 console.error(error); // 处理异常，输出错误信息
 }
 }
};
</script>
```

4. 错误提示和日志记录：

```js
// main.js
import Vue from 'vue'
import Sentry from '@sentry/browser'

Vue.config.errorHandler = (err) => {
  console.error(err) // 错误提示
  Sentry.captureException(err) // 错误日志记录
}

new Vue({
  // ...
}).$mount('#app')
```

上述代码中，`Error Capturing`通过在父组件中的`errorCaptured`钩子函数中捕获子组件的错误，并展示在父组件中。`Error Boundary`通过自定义错误边界组件，在子组件发生错误时展示错误信息或替代内容。`异常处理`通过在子组件的生命周期钩子函数中使用`try-catch`语句来捕获异常并进行处理。`错误提示和日志记录`通过在`Vue.config.errorHandler`中定义全局的错误处理函数，将错误信息输出到控制台，并使用Sentry等工具记录错误日志。

这些示例展示了不同的错误处理方式，可以根据实际需求选择合适的方式来处理Vue应用中的错误。

## defineModel {#p2-define-model}

在 Vue 3 中，`defineModel`是一个用于简化双向绑定的函数，通常与组合式函数（composition function）一起使用。

**一、主要作用**

1. **自动解包响应式对象**：

* 当在组合式函数中使用响应式对象时，使用`defineModel`可以自动解包响应式对象的属性，使得这些属性可以在模板中直接使用，无需通过`.value`来访问。
* 例如，如果有一个响应式对象`state`，其中包含属性`count`，在不使用`defineModel`时，在模板中需要使用`state.count.value`来访问`count`的值。但使用`defineModel`后，可以直接在模板中使用`count`。

2. **实现双向绑定**：

* 配合`v-model`指令使用时，`defineModel`可以轻松实现双向绑定。它会自动处理输入事件，并将新的值更新到响应式对象中。
* 例如，在一个自定义组件中，使用`defineModel`可以让组件的`props`中的一个值与组件内部的状态实现双向绑定，使得父组件和子组件之间的数据传递更加方便。

**二、使用方法**

1. **导入`defineModel`**：

* 在组合式函数中，首先需要从`'vue'`模块中导入`defineModel`函数。

 ```js
 import { defineModel } from 'vue'
 ```

2. **使用`defineModel`**：

* 在组合式函数内部，将需要双向绑定的响应式对象作为参数传递给`defineModel`。

 ```js
 import { reactive } from 'vue'
 
 export default function useCounter () {
   const state = reactive({
     count: 0
   })
 
   return defineModel(() => ({
     count: state.count
   }))
 }
 ```

* 在上面的例子中，`state.count`是一个响应式属性，通过`defineModel`函数返回后，可以在模板中直接使用`count`进行双向绑定。

3. **在模板中使用**：

* 在组件的模板中，可以使用`v-model`指令来绑定使用了`defineModel`的属性。

 ```html
 <template>
 <div>
 <input v-model="count" />
 </div>
 </template>

 <script setup>
 import useCounter from "./useCounter";
 const { count } = useCounter();
 </script>
 ```

* 在这个例子中，`input`元素的`v-model`绑定了`count`属性，当用户在输入框中输入内容时，`count`的值会自动更新，实现了双向绑定。

**三、优势和适用场景**

1. **优势**：

* **简化代码**：减少了在模板中访问响应式属性时需要添加`.value`的繁琐操作，使代码更加简洁易读。
* **方便双向绑定**：特别是在自定义组件中，使用`defineModel`可以快速实现双向绑定，提高开发效率。

2. **适用场景**：

* **自定义组件开发**：当开发自定义组件时，如果需要实现双向绑定的属性，使用`defineModel`可以简化代码，提高组件的易用性。
* **复杂业务逻辑处理**：在组合式函数中处理复杂的业务逻辑时，`defineModel`可以帮助更好地管理响应式数据，实现数据的双向绑定。

## useTemplateRef {#p2-use-template-ref}
