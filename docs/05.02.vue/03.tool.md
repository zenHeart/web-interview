# 工具链

## vuex 原理

## vue-router hash 模式和历史模式区别

## vuex 和 Pinia 有什么区别 {#p3-vuex-pinia}

Vuex 和 Pinia 都是用于 Vue 应用程序的状态管理库，它们有一些相似之处，但也存在一些差异。以下是它们的对比：

**一、相似之处**

1. **集中式状态管理**：

* 两者都提供了一种集中式的方式来管理应用程序的状态。这使得状态可以在不同的组件之间共享，并且可以更容易地跟踪和调试状态的变化。
* 例如，在一个电商应用中，用户的购物车状态可以存储在状态管理库中，以便在不同的页面和组件中访问和更新。

2. **响应式状态**：

* Vuex 和 Pinia 都与 Vue 的响应式系统集成，使得状态的变化可以自动触发相关组件的重新渲染。
* 当购物车中的商品数量发生变化时，相关的组件可以自动更新以反映这个变化。

**二、不同之处**

1. **语法和 API**：

* **Pinia**：

* Pinia 提供了一种更加简洁和直观的 API。它使用类似于 Vue 组件的语法来定义状态和操作，使得代码更加易读和易于维护。
* 例如，定义一个 store 可以像这样：

```js
import { defineStore } from 'pinia'

export const useCartStore = defineStore('cart', {
  state: () => ({
    items: []
  }),
  actions: {
    addItem (item) {
      this.items.push(item)
    }
  }
})
```

* **Vuex**：

* Vuex 的语法相对较为复杂，需要定义 mutations、actions 和 getters 等不同的概念来管理状态。
* 例如，定义一个 store 可能如下所示：

```js
import Vuex from 'vuex'

const store = new Vuex.Store({
  state: {
    items: []
  },
  mutations: {
    ADD_ITEM (state, item) {
      state.items.push(item)
    }
  },
  actions: {
    addItem ({ commit }, item) {
      commit('ADD_ITEM', item)
    }
  },
  getters: {
    cartItems: (state) => state.items
  }
})
```

2. **模块系统**：

* **Pinia**：

* Pinia 的模块系统更加灵活和易于使用。可以轻松地将 store 拆分为多个模块，并且可以在不同的模块之间共享状态和操作。
* 例如，可以创建一个名为`user`的模块和一个名为`cart`的模块，并在它们之间共享一些状态和操作：

```js
import { defineStore } from 'pinia'

const useUserStore = defineStore('user', {
// ...
})

const useCartStore = defineStore('cart', {
  state: () => ({
    // ...
  }),
  actions: {
    addItem (item) {
      // 可以访问 userStore 的状态
      if (useUserStore().isLoggedIn) {
        // ...
      }
    }
  }
})
```

* **Vuex**：
* Vuex 的模块系统也很强大，但相对来说更加复杂。需要使用命名空间来区分不同模块的 actions、mutations 和 getters，并且在模块之间共享状态和操作需要一些额外的配置。

3. **类型支持**：

* **Pinia**：

* Pinia 对 TypeScript 的支持非常好，可以轻松地为 store 定义类型，并且在开发过程中可以获得更好的类型提示和错误检查。
* 例如，可以使用 TypeScript 来定义一个 store 的类型：

```ts
import { defineStore } from 'pinia'

interface CartItem {
  id: number;
  name: string;
  price: number;
  }

export const useCartStore = defineStore('cart', {
  state: () => ({
    items: [] as CartItem[]
  })
// ...
})
```

* **Vuex**：
* Vuex 也支持 TypeScript，但相对来说需要一些额外的配置和类型定义文件来获得更好的类型支持。

4. **开发体验**：

* **Pinia**：
* Pinia 提供了一些开发工具，如 Pinia Devtools，可以方便地调试和检查 store 的状态和操作。它还与 Vue Devtools 集成，使得在开发过程中可以更好地跟踪状态的变化。
* Pinia 的 API 更加简洁，使得开发过程更加高效和愉快。
* **Vuex**：
* Vuex 也有一些开发工具，如 Vuex Devtools，但相对来说功能可能没有 Pinia Devtools 那么强大。
* Vuex 的语法相对较为复杂，可能需要一些时间来适应和掌握。

总的来说，Pinia 和 Vuex 都是强大的状态管理库，选择哪一个取决于你的具体需求和个人偏好。如果你喜欢简洁和直观的 API，并且对 TypeScript 有较好的支持需求，那么 Pinia 可能是一个更好的选择。如果你已经熟悉 Vuex 并且对其功能和模块系统有特定的需求，那么 Vuex 也是一个可靠的选择。

## 路由守卫 {#p0-router-guide}

路由守卫是 Vue Router 提供的一种机制，用于在路由导航过程中对路由进行拦截和控制。通过使用路由守卫，我们可以在路由导航前、导航后、导航中断等不同的阶段执行相应的逻辑。

Vue Router 提供了三种类型的路由守卫：

1. 全局前置守卫（Global Before Guards）：在路由切换之前被调用，可以用于进行全局的权限校验或者路由跳转拦截等操作。

2. 路由独享守卫（Per-Route Guards）：在特定的路由配置中定义的守卫。这些守卫只会在当前路由匹配成功时被调用。

3. 组件内的守卫（In-Component Guards）：在组件实例内部定义的守卫。这些守卫可以在组件内部对路由的变化进行相应的处理。

* 全局前置守卫

```js
router.beforeEach((to, from, next) => {
  // to: 即将进入的目标
  // from:当前导航正要离开的路由
  return false // 返回false用于取消导航
  // return { name: 'Login' } // 返回到对应name的页面
  // next({ name: 'Login' }) // 进入到对应的页面
  // next() // 放行
})
```

* 全局解析守卫:类似beforeEach

```js
router.beforeResolve(to => {
  if (to.meta.canCopy) {
    return false // 也可取消导航
  }
})
```

* 全局后置钩子

```js
router.afterEach((to, from) => {
  logInfo(to.fullPath)
})
```

* 导航错误钩子，导航发生错误调用

```js
router.onError(error => {
  logError(error)
})
```

* 路由独享守卫,beforeEnter可以传入单个函数，也可传入多个函数。

```js
function dealParams (to) {
  // ...
}
function dealPermission (to) {
  // ...
}

const routes = [
  {
    path: '/home',
    component: Home,
    beforeEnter: (to, from) => {
      return false // 取消导航
    }
    // beforeEnter: [dealParams, dealPermission]
  }
]
```

组件内的守卫

```js
const Home = {
  template: '...',
  beforeRouteEnter (to, from) {
    // 此时组件实例还未被创建，不能获取this
  },
  beforeRouteUpdate (to, from) {
    // 当前路由改变，但是组件被复用的时候调用，此时组件已挂载好
  },
  beforeRouteLeave (to, from) {
    // 导航离开渲染组件的对应路由时调用
  }
}
```

## Vuex redux {#p0-redux-vuex}

Redux和Vuex都是用于在前端应用中管理状态的JavaScript库。它们的设计思想都基于Flux架构，强调单向数据流的概念，以避免数据的混乱和不可预测的状态变化。

Redux的设计思想可以总结为三个原则：

1. 单一数据源：Redux中所有的状态数据都保存在单一的store对象中，便于管理和维护。

2. 状态只读：Redux的状态数据是只读的，唯一的改变方式是通过dispatch一个action来触发reducer函数对状态进行更新。

3. 纯函数更新状态：Redux的reducer函数必须是纯函数，即接收一个旧的状态和一个action对象，返回一个新的状态。通过这种方式，Redux保证了状态的可控和可预测性。

Vuex的设计思想类似于Redux，但又有所不同：

1. 单一数据源：Vuex也采用了单一数据源的思想，将所有状态保存在store对象中。

2. 显示状态修改：和Redux不同的是，Vuex允许组件直接修改状态，但这必须是通过commit一个mutation来实现的，mutation也必须是同步的。

3. 模块化：Vuex提供了模块化机制，可以将store对象分解成多个模块，以提高可维护性和代码复用性。

Redux和Vuex都是通过一些基本概念来实现状态管理：

1. Store：保存状态的对象，整个应用只有一个Store。

2. Action：描述状态变化的对象，由View层发起。

3. Reducer：一个纯函数，接收旧的状态和一个Action对象，返回新的状态。

4. Dispatch：一个函数，用来触发Action。

5. Mutation：类似于Redux的Reducer，但必须是同步的。用来更新状态。

总之，Redux和Vuex都是优秀的状态管理库，通过它们可以有效地管理前端应用的状态，实现数据的单向流动和可预测性。同时，Redux和Vuex都遵循了Flux架构的设计思想，使得状态管理更加规范化和可控。
