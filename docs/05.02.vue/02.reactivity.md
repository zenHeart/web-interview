# 响应式

## vue3 的响应式库是独立出来的，它单独使用的时候是什么效果 {#p0-vue3-reactivity}

 该话题涉及的相关内容

* 原理：Proxy、track、trigger
* 新增属性
* 遍历后新增
* 遍历后删除或者清空
* 获取 keys
* 删除对象属性
* 判断属性是否存在
* 性能

推荐阅读文档： [资料](https://juejin.cn/post/6844904122479542285)

 响应式仓库

Vue3 不同于 Vue2 也体现在源码结构上，Vue3 把耦合性比较低的包分散在 `packages` 目录下单独发布成 `npm` 包。 这也是目前很流行的一种大型项目管理方式 `Monorepo`。

其中负责响应式部分的仓库就是 `@vue/reactivity`，它不涉及 Vue 的其他的任何部分，是非常非常 「正交」 的一种实现方式。

甚至可以`轻松的集成进 React` [资料](https://juejin.cn/post/6844904095594381325)

 区别

Proxy 和 Object.defineProperty 的使用方法看似很相似，其实 Proxy 是在 「更高维度」 上去拦截属性的修改的，怎么理解呢？

Vue2 中，对于给定的 data，如 `{ count: 1 }`，是需要根据具体的 key 也就是 `count`，去对「修改 data.count 」 和 「读取 data.count」进行拦截，也就是

```jsx
Object.defineProperty(data, 'count', {
  // eslint-disbale-next-line
  get () {
    // nop
  },
  set () {}
})
```

必须预先知道要拦截的 key 是什么，这也就是为什么 Vue2 里对于对象上的新增属性无能为力。

而 Vue3 所使用的 Proxy，则是这样拦截的：

```js
const p = new Proxy(data, {
  get (key) { },
  set (key, value) { }
})
```

可以看到，根本不需要关心具体的 key，它去拦截的是 「修改 data 上的任意 key」 和 「读取 data 上的任意 key」。

所以，不管是已有的 key 还是新增的 key，都逃不过它的魔爪。

但是 Proxy 更加强大的地方还在于 Proxy 除了 get 和 set，还可以拦截更多的操作符。

 简单的例子🌰

先写一个 Vue3 响应式的最小案例，本文的相关案例都只会用 `reactive` 和 `effect` 这两个 api。如果你了解过 React 中的 `useEffect`，相信你会对这个概念秒懂，Vue3 的 `effect` 不过就是去掉了手动声明依赖的「进化版」的 `useEffect`。

React 中手动声明 `[data.count]` 这个依赖的步骤被 Vue3 内部直接做掉了，在 `effect` 函数内部读取到 `data.count` 的时候，它就已经被收集作为依赖了。

Vue3：

```kotlin
// 响应式数据
const data = reactive({
 count: 1
})

// 观测变化
effect(() => console.log('count changed', data.count))

// 触发 console.log('count changed', data.count) 重新执行
data.count = 2

```

React：

```scss
// 数据
const [data, setData] = useState({
 count: 1
})

// 观测变化 需要手动声明依赖
useEffect(() => {
 console.log('count changed', data.count)
}, [data.count])

// 触发 console.log('count changed', data.count) 重新执行
setData({
 count: 2
})

```

也可以把 `effect` 中的回调函数联想到视图的重新渲染、 watch 的回调函数等等…… 它们是同样基于这套响应式机制的。

而本文的核心目的，就是探究这个基于 Proxy 的 reactive api，到底能强大到什么程度，能监听到用户对于什么程度的修改。

 讲讲原理

先最小化的讲解一下响应式的原理，其实就是在 Proxy 第二个参数 `handler` 也就是陷阱操作符中，拦截各种取值、赋值操作，依托 `track` 和 `trigger` 两个函数进行依赖收集和派发更新。

`track` 用来在读取时收集依赖。

`trigger` 用来在更新时触发依赖。

 track

```vbnet
function track(target: object, type: TrackOpTypes, key: unknown) {
 const depsMap = targetMap.get(target);
 // 收集依赖时 通过 key 建立一个 set
 let dep = new Set()
 targetMap.set(ITERATE_KEY, dep)
 // 这个 effect 可以先理解为更新函数 存放在 dep 里
 dep.add(effect)
}

```

`target` 是原对象。

`type` 是本次收集的类型，也就是收集依赖的时候用来标识是什么类型的操作，比如上文依赖中的类型就是 `get`，这个后续会详细讲解。

`key` 是指本次访问的是数据中的哪个 key，比如上文例子中收集依赖的 key 就是 `count`

首先全局会存在一个 `targetMap`，它用来建立 `数据 -> 依赖` 的映射，它是一个 WeakMap 数据结构。

而 `targetMap` 通过数据 `target`，可以获取到 `depsMap`，它用来存放这个数据对应的所有响应式依赖。

`depsMap` 的每一项则是一个 Set 数据结构，而这个 Set 就存放着对应 key 的更新函数。

是不是有点绕？我们用一个具体的例子来举例吧。

```ini
const target = { count: 1}
const data = reactive(target)

const effection = effect(() => {
 console.log(data.count)
})

```

对于这个例子的依赖关系，

1. 全局的 `targetMap` 是：

```js
// targetMap: {
//  { count: 1 }: dep
// }
```

2. dep 则是

```js
// dep: {
//  count: Set { effection }
// }
```

这样一层层的下去，就可以通过 `target` 找到 `count` 对应的更新函数 `effection` 了。

 trigger

这里是最小化的实现，仅仅为了便于理解原理，实际上要复杂很多，

其实 `type` 的作用很关键，先记住，后面会详细讲。

```typescript
export function trigger (
  target: object,
  type: TriggerOpTypes,
  key?: unknown
) {
  // 简化来说 就是通过 key 找到所有更新函数 依次执行
  const dep = targetMap.get(target)
  dep.get(key).forEach(effect => effect())
}
```

vue3 的响应式库是独立出来的，它可以很方便的集成进 React， 作为 React 的状态管理库使用！

 使用示范

定义 store

```typescript
// store.ts
import { reactive, computed, effect } from '@vue/reactivity'

export const state = reactive({
  count: 0
})

const plusOne = computed(() => state.count + 1)

effect(() => {
  console.log('plusOne changed: ', plusOne)
})

const add = () => (state.count += 1)

export const mutations = {
  // mutation
  add
}

export const store = {
  state,
  computed: {
    plusOne
  }
}

export type Store = typeof store;
```

消费使用

```tsx
// Index.tsx
import { Provider, useStore } from 'rxv'
import { mutations, store, Store } from './store.ts'
function Count () {
  const countState = useStore((store: Store) => {
    const { state, computed } = store
    const { count } = state
    const { plusOne } = computed

    return {
      count,
      plusOne
    }
  })

  return (
 <Card hoverable style={{ marginBottom: 24 }}>
 <h1>计数器</h1>
 <div className="chunk">
 <div className="chunk">store中的count现在是 {countState.count}</div>
 <div className="chunk">computed值中的plusOne现在是 {countState.plusOne.value}</div>
 <Button onClick={mutations.add}>add</Button>
 </div>
 </Card>
  )
}

export default () => {
  return (
 <Provider value={store}>
 <Count />
 </Provider>
  )
}
```

可以看出，store的定义只用到了@vue/reactivity，而rxv只是在组件中做了一层桥接，连通了Vue3和React，正如它名字的含义：React x Vue。

 如何实现

只要effect能接入到React系统中，那么其他的api都没什么问题，因为它们只是去收集effect的依赖，去通知effect触发更新。

effect接受的是一个函数，而且effect还支持通过传入schedule参数来自定义依赖更新的时候需要触发什么函数，

而rxv的核心api: useStore接受的也是一个函数selector，它会让用户自己选择在组件中需要访问的数据。

把selector包装在effect中执行，去收集依赖。

指定依赖发生更新时，需要调用的函数是当前正在使用useStore的这个组件的forceUpdate强制渲染函数。

简单的看一下核心实现

share.ts

```typescript
export const useForceUpdate = () => {
  const [, forceUpdate] = useReducer(s => s + 1, 0)
  return forceUpdate
}

export const useEffection = (...effectArgs: Parameters<typeof effect>) => {
  // 用一个ref存储effection
  // effect函数只需要初始化执行一遍
  const effectionRef = useRef<ReactiveEffect>()
  if (!effectionRef.current) {
    effectionRef.current = effect(...effectArgs)
  }

  // 卸载组件后取消effect
  const stopEffect = () => {
    stop(effectionRef.current!)
  }
  useEffect(() => stopEffect, [])

  return effectionRef.current
}
```

核心逻辑在此

```typescript
import React, { useContext } from 'react'
import { useForceUpdate, useEffection } from './share'

type Selector<T, S> = (store: T) => S;

const StoreContext = React.createContext<any>(null)

const useStoreContext = () => {
  const contextValue = useContext(StoreContext)
  if (!contextValue) {
    throw new Error(
      'could not find store context value; please ensure the component is wrapped in a <Provider>'
    )
  }
  return contextValue
}

/**
在组件中读取全局状态
需要通过传入的函数收集依赖
 */
export const useStore = <T, S>(selector: Selector<T, S>): S => {
  const forceUpdate = useForceUpdate()
  const store = useStoreContext()

  const effection = useEffection(() => selector(store), {
    scheduler: job => {
      if (job() === undefined) return
      forceUpdate()
    },
    lazy: true
  })

  const value = effection()
  return value
}

export const Provider = StoreContext.Provider
```

参考文档：

* [资料](https://github.com/sl1673495/react-composition-api)
* [资料](https://juejin.cn/post/6844904054192078855)

## data  {#p1-data}

`vue` 实例的时候定义`data`属性既可以是一个对象，也可以是一个函数

```js
const app = new Vue({
  el: '#app',
  // 对象格式
  data: {
    foo: 'foo'
  }
  // 函数格式
  // data () {
  //   return {
  //     foo: 'foo'
  //   }
  // }
})
```

组件中定义data属性，只能是一个函数

如果为组件data直接定义为一个对象

```js
Vue.component('component1', {
  template: '<div>组件</div>',
  data: {
    foo: 'foo'
  }
})
```

则会得到警告信息

警告说明：返回的data应该是一个函数在每一个组件实例中

**组件data定义函数与对象的区别**

上面讲到组件data必须是一个函数，不知道大家有没有思考过这是为什么呢？

在我们定义好一个组件的时候，vue最终都会通过Vue.extend()构成组件实例

这里我们模仿组件构造函数，定义data属性，采用对象的形式

```js
function Component () {

}

Component.prototype.data = {
  count: 0
}
```

创建两个组件实例

```js
const componentA = new Component()
const componentB = new Component()
```

产生这样的原因这是两者共用了同一个内存地址，componentA修改的内容，同样对componentB产生了影响

如果我们采用函数的形式，则不会出现这种情况（函数返回的对象内存地址并不相同）

```js
function Component () {
  this.data = this.data()
}

Component.prototype.data = function () {
  return {
    count: 0
  }
}
```

修改componentA组件data属性的值，componentB中的值不受影响

```js
console.log(componentB.data.count) // 0
componentA.data.count = 1
console.log(componentB.data.count) // 0
```

vue组件可能会有很多个实例，采用函数返回一个全新data形式，使每个实例对象的数据不会受到其他实例对象数据的污染

**原理分析**

首先可以看看vue初始化data的代码，data的定义可以是函数也可以是对象

源码位置：`/vue-dev/src/core/instance/state.js`

```ts
function initData (vm: Component) {
  let data = vm.$options.data
  data = vm._data = typeof data === 'function'
    ? getData(data, vm)
    : data || {}
  // ...
}
```

`data`既能是`object`也能是`function`，那为什么还会出现上文警告呢？

别急，继续看下文

组件在创建的时候，会进行选项的合并

源码位置：`/vue-dev/src/core/util/options.js`

自定义组件会进入`mergeOptions`进行选项合并

```ts
Vue.prototype._init = function (options?: object) {
  // ...
  // merge options
  if (options && options._isComponent) {
    // optimize internal component instantiation
    // since dynamic options merging is pretty slow, and none of the
    // internal component options needs special treatment.
    initInternalComponent(vm, options)
  } else {
    vm.$options = mergeOptions(
      resolveConstructorOptions(vm.constructor),
      options || {},
      vm
    )
  }
  // ...
}
```

定义data会进行数据校验

源码位置：`/vue-dev/src/core/instance/init.js`

这时候`vm`实例为`undefined`，进入if判断，若`data`类型不是`function`，则出现警告提示

```tsx
strats.data = function (
  parentVal: any,
  childVal: any,
  vm?: Component
): () => any {
  if (!vm) {
    if (childVal && typeof childVal !== 'function') {
      process.env.NODE_ENV !== 'production' &&
 warn(
   'The "data" option should be a function ' +
 'that returns a per-instance value in component ' +
 'definitions.',
   vm
 )

      return parentVal
    }
    return mergeDataOrFn(parentVal, childVal)
  }
  return mergeDataOrFn(parentVal, childVal, vm)
}
```

**结论**

* 根实例对象`data`可以是对象也可以是函数（根实例是单例），不会产生数据污染情况
* 组件实例对象`data`必须为函数，目的是为了防止多个组件实例对象之间共用一个`data`，产生数据污染。采用函数的形式，`initData`时会将其作为工厂函数都会返回全新`data`对象

**关键词**：vue更改data属性

**直接添加属性的问题**

我们从一个例子开始

定义一个`p`标签，通过`v-for`指令进行遍历

然后给`botton`标签绑定点击事件，我们预期点击按钮时，数据新增一个属性，界面也 新增一行

```vue

<template>
 <p v-for="(value,key) in item" :key="key">
 {{ value }}
 </p>
 <button @click="addProperty">动态添加新属性</button>
</template>
```

实例化一个`vue`实例，定义`data`属性和`methods`方法

```js
const app = new Vue({
  el: '#app',
  data: () => ({
    // '旧属性'
  }
  ),
  methods: {
    addProperty () {
      this.items.newProperty = '新属性' // 为items添加新属性
      console.log(this.items) // 输出带有newProperty的items
    }
  }
})
```

点击按钮，发现结果不及预期，数据虽然更新了（console打印出了新属性），但页面并没有更新

**原理分析**

为什么产生上面的情况呢？

下面来分析一下

`vue2`是用过`Object.defineProperty`实现数据响应式

```js
const obj = {}
Object.defineProperty(obj, 'foo', {
  get () {
    console.log(`get foo:${val}`)
    return val
  },
  set (newVal) {
    if (newVal !== val) {
      console.log(`set foo:${newVal}`)
      val = newVal
    }
  }
})
```

当我们访问`foo`属性或者设置`foo`值的时候都能够触发`setter与getter`

```js
obj.foo
obj.foo = 'new'
```

但是我们为`obj`添加新属性的时候，却无法触发事件属性的拦截

```js
obj.bar = '新属性'
```

原因是一开始`obj`的`foo`属性被设成了响应式数据，而`bar`是后面新增的属性，并没有通过`Object.defineProperty`设置成响应式数据

**解决方案**

`Vue` 不允许在已经创建的实例上动态添加新的响应式属性

若想实现数据与视图同步更新，可采取下面三种解决方案：

* `Vue.set()`
* `Object.assign()`
* `$forcecUpdated()`

**`Vue.set()`**

`Vue.set( target, propertyName/index, value )`

参数

* `{Object | Array} target`
* `{string | number} propertyName/index`
* `{any} value`

返回值：设置的值

通过`Vue.set`向响应式对象中添加一个`property`，并确保这个新 `property` 同样是响应式的，且触发视图更新

关于`Vue.set`源码（省略了很多与本节不相关的代码）

源码位置：`src\core\observer\index.js`

```ts
function set (target: Array<any> | object, key: any, val: any): any {
  // ...
  defineReactive(ob.value, key, val)
  ob.dep.notify()
  return val
}
```

这里无非再次调用 `defineReactive` 方法，实现新增属性的响应式

关于 `defineReactive` 方法，内部还是通过 `Object.defineProperty` 实现属性拦截

```js
function defineReactive (obj, key, val) {
  Object.defineProperty(obj, key, {
    get () {
      console.log(`get ${key}:${val}`)
      return val
    },
    set (newVal) {
      if (newVal !== val) {
        console.log(`set ${key}:${newVal}`)
        val = newVal
      }
    }
  })
}
```

**`Object.assign()`**

直接使用Object.assign()添加到对象的新属性不会触发更新

应创建一个新的对象，合并原对象和混入对象的属性

```js
this.someObject = Object.assign({}, this.someObject, { newProperty1: 1, newProperty2: 2 })
```

**`$forceUpdate`**

如果你发现你自己需要在 Vue 中做一次强制更新，99.9% 的情况，是你在某个地方做错了事

`$forceUpdate` 迫使 Vue 实例重新渲染

PS：仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。

**小结**

如果为对象添加少量的新属性，可以直接采用`Vue.set()`

如果需要为新对象添加大量的新属性，则通过`Object.assign()`创建新对象

如果你实在不知道怎么操作时，可采取`$forceUpdate()`进行强制刷新 (不建议)

## ref 和 reactive 有何区别吗 {#p1-ref-reactive}

在 Vue 3 中，`ref` 和 `reactive` 是创建响应式数据的两种不同方法，它们都是 Vue 的响应式系统的一部分，但在使用方式和适用场景上有一些区别。下面是 `ref` 和 `reactive` 的主要区别：

 `ref`

* **用法**：`ref` 用于创建一个响应式的引用类型数据。当你需要使基本数据类型（例如：string, number, boolean）变得响应式时，`ref` 是一个很好的选择。
* **返回值**：`ref` 返回一个包含 `value` 属性的对象。你需要通过 `.value` 属性来访问或修改其内部值。
* **适用场景**：适用于基本数据类型，也可以用于对象和数组，但主要是为了基本数据类型设计的。

```js
import { ref } from 'vue'

const count = ref(0)
console.log(count.value) // 访问值
count.value++ // 修改值
```

 `reactive`

* **用法**：`reactive` 用于创建一个响应式的复杂类型数据，如对象或数组。
* **返回值**：直接返回原始对象的响应式代理，不需要通过 `.value` 属性来访问或修改。
* **适用场景**：是为了使对象或数组这样的引用数据类型变得响应式而设计的。

```js
import { reactive } from 'vue'

const state = reactive({ count: 0 })
console.log(state.count) // 访问值
state.count++ // 修改值
```

 主要区别

1. **数据类型**：`ref` 主要用于基本数据类型，但也可以用于对象和数组；`reactive` 适用于对象或数组等引用数据类型。
2. **返回值**：`ref` 返回一个对象，这个对象包含一个 `value` 属性，这意味着你需要通过 `.value` 来获取或设置值；而 `reactive` 返回的是对象或数组的响应式代理，可以直接操作。
3. **模板中使用**：在模板中使用时，`ref` 创建的响应式数据访问时不需要 `.value`，Vue 模板会自动解包；`reactive` 对象在模板中的行为与普通对象相同。

 使用建议

* 当你处理基本数据类型时，使用 `ref`；
* 当你需要管理一个复杂的数据结构（如对象或数组），使用 `reactive` 以保持代码的简洁和直观。

在 Vue 3 的响应式系统中，处理深层嵌套的数据时，`ref` 和 `reactive` 在行为上有一些细微但重要的区别，特别是当涉及到对象、数组以及 JavaScript 内置的数据结构（如 Map 和 Set）时。这些区别主要体现在如何使嵌套的数据成为响应式的，以及如何维护这些响应性。

 处理深层嵌套的数据

无论是使用 `ref` 还是 `reactive`，Vue 会尝试使给定的数据结构及其嵌套的所有子结构变成响应式的。但是，具体的实现机制有所不同。

 `reactive`

* `reactive` 对象默认深度响应式。当你使用 `reactive` 使一个对象变成响应式时，这个对象的所有嵌套对象和数组也会自动变成响应式的。这意味着你可以在任意深度的嵌套数据上进行修改，并且这些修改将会触发视图更新。
* 对于 JavaScript 的内置数据结构，如 Map 和 Set，Vue 3 也提供了响应式支持，但它们必须通过 `reactive` 方法来创建或转换为响应式的。

```js
const state = reactive({
  nested: {
    count: 0
  },
  numbers: [1, 2, 3],
  map: new Map()
})

state.nested.count++ // 触发视图更新
state.numbers.push(4) // 触发视图更新
state.map.set('key', 'value') // 触发视图更新
```

 `ref`

* 使用 `ref` 创建响应式数据时，如果 `ref` 被赋值为一个对象或数组，Vue 会将该对象或数组内部转换为深度响应式。然而，这种转换仅发生在赋值操作时，如果后续对该对象或数组进行再嵌套，新增的嵌套不会自动转换为响应式。
* 对于内置数据结构如 Map 和 Set，`ref` 可以存储它们，但不会使它们或其内容变成响应式的。如果你需要在模板中直接绑定这些数据结构的响应式变化，使用 `reactive` 会是更好的选择。

```js
const nestedObj = ref({
  nested: {
    count: 0
  }
})

nestedObj.value.nested.count++ // 触发视图更新

const map = ref(new Map())
map.value.set('key', 'value') // 不会触发视图更新，除非重新赋值给 map.value
```

总结

当处理深层嵌套的对象、数组或内置数据结构时：

* `reactive` 默认提供深度响应式，并且可以使 Map、Set 等内置数据结构变为响应式。
* `ref` 在赋值对象或数组时自动将其转换为响应式，但不适用于 Map 或 Set 等内置数据结构的深度响应。

一般情况下，对于复杂或深层嵌套的数据结构，`reactive` 更加适合。对于基本数据类型或不太复杂的嵌套数据，`ref` 可以提供方便的响应式转换。

## computed 和 watch 的区别 {#p0-computed-watch}

1. 支持缓存，只有依赖数据发生改变，才会重新进行计算，计算属性可用于快速计算视图（View）中显示的属性。这些计算将被缓存，并且只在需要时更新。computed是计算属性的; 它会根据所依赖的数据动态显示新的计算结果, 该计算结果会被缓存起来。computed的值在getter执行后是会被缓存的。如果所依赖的数据发生改变时候, 就会重新调用getter来计算最新的结果。

2. 不支持异步，当computed内有异步操作时无效，无法监听数据的变化

3. computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值

4. 如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed

5. 如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。

6. 适用于一些重复使用数据或复杂及费时的运算。我们可以把它放入computed中进行计算, 然后会在computed中缓存起来, 下次就可以直接获取了。

7. 如果我们需要的数据依赖于其他的数据的话, 我们可以把该数据设计为computed中。

8. computed 是基于响应性依赖来进行缓存的。只有在响应式依赖发生改变时它们才会重新求值, 也就是说, 当msg属性值没有发生改变时, 多次访问 reversedMsg 计算属性会立即返回之前缓存的计算结果, 而不会再次执行computed中的函数。但是methods方法中是每次调用, 都会执行函数的, methods它不是响应式的。

9. computed中的成员可以只定义一个函数作为只读属性, 也可以定义成 get/set变成可读写属性, 但是methods中的成员没有这样的。

**侦听属性watch：**

1.watch它是一个对data的数据监听回调, 当依赖的data的数据变化时, 会执行回调。在回调中会传入newVal和oldVal两个参数。Vue实列将会在实例化时调用$watch(), 他会遍历watch对象的每一个属性。watch的使用场景是：当在data中的某个数据发生变化时, 我们需要做一些操作, 或者当需要在数据变化时执行异步或开销较大的操作时. 我们就可以使用watch来进行监听。watch普通监听和深度监听不支持缓存，数据变，直接会触发相应的操作；

2.watch里面有一个属性为deep，含义是：是否深度监听某个对象的值, 该值默认为false。watch支持异步；

3.监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；

4.当一个属性发生变化时，需要执行对应的操作；一对多；

5.监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数，

**watch 和 computed的区别是：**

相同点：他们两者都是观察页面数据变化的。

不同点：computed只有当依赖的数据变化时才会计算, 当数据没有变化时, 它会读取缓存数据。 watch每次都需要执行函数。watch更适用于数据变化时的异步操作。

当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。这是和computed最大的区别，请勿滥用。

在 Vue 中，`computed` 和 `watch` 是两种用于监听和响应数据变化的方式。

`computed` 是计算属性，它是基于响应式数据进行计算得到的一个新的派生属性。计算属性可以接收其他响应式数据作为依赖，并且只有当依赖数据发生变化时，计算属性才会重新计算。计算属性的值会被缓存，只有在依赖数据变化时才会重新计算，这样可以提高性能。计算属性的定义方式是使用 `computed` 函数或者在 Vue 组件中使用 `get` 和 `set` 方法。

下面是一个使用计算属性的示例：

```js
import { reactive, computed } from 'vue'

const state = reactive({
  firstName: 'John',
  lastName: 'Doe'
})

const fullName = computed(() => {
  return `${state.firstName} ${state.lastName}`
})

console.log(fullName.value) // 输出: "John Doe"

state.firstName = 'Mike' // 修改firstName
console.log(fullName.value) // 输出: "Mike Doe"
```

`watch` 是用于监听特定响应式数据的变化，并在数据变化时执行相应的操作。`watch` 可以监听单个数据的变化，也可以监听多个数据的变化。当被监听的数据发生变化时，`watch` 的回调函数会被执行。`watch` 还支持深度监听对象的变化以及异步操作。

下面是一个使用 `watch` 的示例：

```js
import { reactive, watch } from 'vue'

const state = reactive({
  count: 0
})

watch(() => state.count, (newVal, oldVal) => {
  console.log(`count 从 ${oldVal} 变为 ${newVal}`)
})

state.count++ // 输出: "count 从 0 变为 1"
```

以上是 `computed` 和 `watch` 的基本用法。通过使用这两种方式，我们可以根据需要监听和响应数据的变化，实现更加灵活的逻辑和交互。

下面是一个表格，对比了 Vue 3 中的 `computed` 计算属性和普通函数方法的主要差异：

| 特性 | 计算属性 (`computed`) | 普通函数方法 (`methods`) |
| ------------ | -------------------------------------------------------- | ------------------------------------------------------ |
| **缓存** | 是。只有当依赖数据变化时，才会重新计算。 | 否。每次调用都会执行函数逻辑。 |
| **性能** | 高。避免了不必要的计算，只在依赖变化时重新计算。 | 较低。不区分是否有数据更新，都会执行。 |
| **触发更新** | 依赖数据变化时自动更新。 | 需要手动触发或组件重新渲染时才更新。 |
| **使用场景** | 当数据变化需要进行复杂运算时，且结果要被多次引用。 | 每次都需执行新逻辑或操作不依赖响应式数据时。 |
| **访问方式** | 如访问属性一样，不需要加括号。 | 在模板中调用时需要加括号。 |
| **返回值** | 调用时返回计算后的结果，不需要执行任何函数。 | 必须执行函数以获取结果。 |
| **更新性能** | 只在依赖变化时重新求值，如果依赖未变化则返回上次的结果。 | 在每次访问或调用时无条件执行，不考虑依赖数据是否变化。 |

通过对比，我们可以看到两者在 Vue 应用中各自的优势和应用场景。`computed` 适合用于基于数据变化需要重新计算的场景，特别是当这些计算比较昂贵，或者计算结果会被多处使用时。而普通函数方法更适合用于执行不依赖响应式数据的操作，或者当操作每次都需要产生不同结果时。正确地选择使用计算属性还是普通方法，可以优化你的 Vue 应用的性能和可维护性。

* computed 是计算属性，有缓存，依赖变化才会重新计算
* watch 是监听器，用于响应数据变化执行回调
* computed 适合多个数据影响一个数据的场景

```js
// computed 示例：计算总价
const config = {
  computed: {
    total () {
      return this.price * this.quantity
    }
  }
}
```

* watch 适合一个数据变化影响多个数据的场景

```js
// watch 示例：数据变化执行多个操作
const config = {
  watch: {
    username (newVal) {
      this.validateUsername(newVal)
      this.checkAvailability(newVal)
      this.updateUserProfile(newVal)
    }
  }
}
```

1. scoped style 原理:

* 通过给组件添加唯一的属性标识符(data-v-hash)
* 编译时给 css 选择器添加对应的属性选择器
* 确保样式只作用于当前组件

5. 垂直居中实现:

```css
/* Flex 方式 */
.parent {
display: flex;
align-items: center;
justify-content: center;
}

/* Grid 方式 */
.parent {
display: grid;
place-items: center;
}

/* 绝对定位方式 */
.child {
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
}
```

6. flex: 1 的含义:
相当于设置:

```css
flex-grow: 1;
flex-shrink: 1;
flex-basis: 0%;
```

表示元素可以伸展和收缩，占据剩余空间

7. 单行文本省略:

```css
.ellipsis {
white-space: nowrap;
overflow: hidden;
text-overflow: ellipsis;
}
```

8. apply 和 call 的区别:

* 都是用来改变函数的 this 指向
* call 接受参数列表
* apply 接受参数数组

```js
fn.call(obj, arg1, arg2)
fn.apply(obj, [arg1, arg2])
```

9. this 指向:

* 普通函数中，this 指向调用者
* 箭头函数中，this 指向定义时的上下文
* call/apply/bind 可以改变 this 指向
* 构造函数中，this 指向新创建的实例

10. 闭包及场景:
闭包是函数能够访问其定义时所在的词法作用域
常见场景:

```js
// 数据私有化
function counter () {
  let count = 0
  return {
    add () { count++ },
    get () { return count }
  }
}

// 函数柯里化
function curry (fn) {
  return function curried (...args) {
    if (args.length >= fn.length) {
      return fn.apply(this, args)
    }
    return function (...moreArgs) {
      return curried.apply(this, args.concat(moreArgs))
    }
  }
}
```

11. 节流防抖:

```js
// 防抖: 延迟执行，重复触发重新计时
function debounce (fn, delay) {
  let timer = null
  return function (...args) {
    clearTimeout(timer)
    timer = setTimeout(() => {
      fn.apply(this, args)
    }, delay)
  }
}

// 节流: 规定时间内只执行一次
function throttle (fn, delay) {
  let timer = null
  return function (...args) {
    if (!timer) {
      timer = setTimeout(() => {
        fn.apply(this, args)
        timer = null
      }, delay)
    }
  }
}
```

12. 宏任务与微任务:

* 宏任务: setTimeout, setInterval, requestAnimationFrame
* 微任务: Promise, MutationObserver, process.nextTick
* 执行顺序: 同步代码 -> 微任务队列 -> 宏任务队列

13. async/await:

* async 函数返回 Promise
* await 等待 Promise 完成
* 用同步的写法实现异步操作

```js
async function example () {
  try {
    const result = await someAsyncOperation()
    return result
  } catch (error) {
    console.error(error)
  }
}
```

14. 生成器:

```js
function * generator () {
  yield 1
  yield 2
  return 3
}

const gen = generator()
console.log(gen.next()) // {value: 1, done: false}
console.log(gen.next()) // {value: 2, done: false}
console.log(gen.next()) // {value: 3, done: true}
```

15. TypeScript 中 type 和 interface 的区别:

* interface 可以声明合并，type 不行
* interface 只能声明对象类型，type 可以声明任意类型
* type 可以使用联合类型和交叉类型
* interface 可以 extends 和 implements

```typescript
// interface 合并
interface User {
name: string;
}
interface User {
age: number;
}

// type 联合类型
type Status = 'pending' | 'fulfilled' | 'rejected';
```

16. Vue 响应式原理及 Vue2/Vue3 区别:

**响应式定义**：

* 数据的变化自动触发相关联的更新操作
* 实现了数据与视图的同步

**Vue2 实现 (Object.defineProperty)**:

```js
Object.defineProperty(obj, 'key', {
  get () {
  // 依赖收集
    track()
    return value
  },
  set (newValue) {
    value = newValue
    // 触发更新
    trigger()
  }
})
```

**Vue3 实现 (Proxy)**:

```js
const proxy = new Proxy(target, {
  get (target, key) {
  // 依赖收集
    track(target, key)
    return target[key]
  },
  set (target, key, value) {
    target[key] = value
    // 触发更新
    trigger(target, key)
    return true
  }
})
```

**Vue2 局限性**:

* 无法检测对象属性的添加和删除
* 无法直接监听数组索引和长度变化
* 需要递归遍历对象的所有属性
* 需要使用 Vue.set 或 this.$set 添加响应式属性

**Vue3 优势**:

* 可以监听动态添加的属性
* 可以监听数组的索引和长度变化
* 支持 Map、Set、WeakMap、WeakSet
* 性能更好，不需要初始化时递归
* 更好的类型推导支持

**实际应用示例**:

```js
// Vue2 的局限
const vm = new Vue({
  data: {
    items: ['a', 'b']
  }
})
vm.items[0] = 'x' // 不会触发响应
vm.items.length = 1 // 不会触发响应

// Vue3 的优势
const proxy = reactive({
  items: ['a', 'b']
})
proxy.items[0] = 'x' // 可以触发响应
proxy.items.length = 1 // 可以触发响应
```

## Provide inject {#p2-provide-inject}

Vue 3 中的 `provide` 和 `inject` 功能提供了一种方法，允许祖先组件将数据“提供”给它的所有后代组件，无论后代组件位于组件树的何处，而不必通过所有的组件层层传递属性（props）。这对于深层嵌套的组件或跨多个组件共享状态特别有用。

 基本用法

 在祖先组件中提供数据

你可以在任何组件中使用 `provide` 选项来提供数据。`provide` 选项应该是一个对象或返回对象的函数，其中的每个属性都可以被子组件注入。从 Vue 3 开始，`provide` 和 `inject` 绑定现在是响应式的。

在 Vue 3 中，建议在 `setup()` 函数中使用 `provide` 函数，因为 `setup` 是组合式 API 的入口点。

```js
import { provide } from 'vue'

export default {
  setup () {
    // 提供 'theme' 数据
    provide('theme', 'dark')
  }
}
```

 在后代组件中注入数据

后代组件可以使用 `inject` 选项来接收数据。`inject` 选项应该是一个字符串数组，列出需要注入的属性名。

```js
import { inject } from 'vue'

export default {
  setup () {
    const theme = inject('theme')
    return { theme }
  }
}
```

 案例

假设你正在开发一个应用，该应用有一个主题切换功能，你可以在顶层组件中提供当前主题，而所有子组件都可以注入这个主题信息，而不必通过层层传递。

 响应式提供

如果要提供的数据是响应式的，并且希望后代组件能够响应数据的变化，你需要使用 Vue 的响应式系统函数，例如 `reactive` 或 `ref`。

```js
import { provide, reactive } from 'vue'

export default {
  setup () {
    const theme = reactive({ color: 'dark' })
    provide('theme', theme)
  }
}
```

后代组件同样可以如上所示通过 `inject` 获取这个响应式的数据。

 注意事项

* `provide` 和 `inject` 提供的依赖关系不是可靠的，并且不应该在业务逻辑中频繁使用，以避免复杂的跨组件通讯导致应用难以维护。它通常被用于开发可复用的插件或高阶组件。
* 使用这两个选项时，注入的数据在后代组件中并不是响应式的，除非使用了 Vue 的响应式系统（如 `reactive`、`ref`）来提供这些数据。
* 如果 `inject` 未找到提供的键，则它默认返回 `undefined`。你可以通过提供第二个参数作为默认值来改变这一行为。

总的来说，`provide` 和 `inject` 是 Vue 3 中解决跨多个组件共享状态问题的一个非常有用的功能，尤其适用于开发高阶组件或插件时使用。

## watchEffect {#p2-wactheffect}

## watch 和 watchEffect 场景上有何区别 {#p2-watch-and-watcheffect}

`watch` 和 `watchEffect` 在 Vue 3 中都是强大的响应式特性，用于侦听响应式状态的变化并执行一些副作用（如调用函数）。虽然它们很相似，但在使用场景和行为上有一些关键的区别，了解这些区别可以帮助你选择最合适的工具来实现你的需求。

 watch

* **精确性**：`watch` 允许你明确指定要侦听的数据源，并且可以分别访问其新值和旧值。这让 `watch` 在需要对特定数据变化做出响应时非常精确和灵活。
* **惰性执行**：`watch` 默认情况下是惰性执行的，即它需要数据发生变化后才执行回调。这意味着在初始化时，`watch` 的回调不会执行，除非你通过配置使其立即执行。
* **使用场景**：当你需要明确知道数据何时改变以及如何改变时（例如对比新旧值），或者需要侦听一个或多个特定的响应式引用时，`watch` 是更好的选择。

 watchEffect

* **自动侦测**：`watchEffect` 会自动侦测其回调函数中用到的响应式状态，并在这些状态改变时重新执行。这意味着你不需要明确指定侦听的状态，让侦听副作用的编写更简单直接。
* **立即执行**：`watchEffect` 回调会在初始时立即执行一次，然后再每次依赖的响应式状态变化时再次执行。这适合于不需要初始条件判断且希望立即根据响应式状态渲染或执行逻辑的场景。
* **使用场景**：当你需要自动追踪并响应所有使用到的响应式状态变化时，`watchEffect` 是更便捷的选项。它适用于依赖项不明确或者希望自动追踪依赖并执行副作用的场合。

 如何选择

1. **如果你的副作用逻辑需要明确侦听特定的数据源，并且需要区分初始执行和依赖更新时的逻辑**，那么使用 `watch` 更合适。`watch` 提供了对侦听数据和执行逻辑的细粒度控制。
2. **如果你的逻辑只是单纯地需要对使用到的任何响应式状态的改变做出响应，且希望简化依赖跟踪**，`watchEffect` 更简单、更易于使用。它自动收集依赖项，简化了代码，使你的副作用逻辑更容易编写和维护。

通常，选择依赖于你想要的控制级别和特定的使用情况。`watch` 提供了更高的灵活性和控制力，`watchEffect` 则为常见的自动响应逻辑提供了便利。了解这些区别和使用场景可以帮助你更合理地使用 Vue 3 的响应式系统。
