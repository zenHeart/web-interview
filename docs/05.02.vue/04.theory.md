# 原理

## MVC 和 MVVM {#p0-mvvm}

```html
<body>
<div>
 <input type="text" name="" id="txt-title"> <br>
 <button id="btn-submit">submit</button>
</div>
<div>
 <ul id="ul-list"></ul>
</div>
<script>
 let $txtTitle = document.getElementById('txt-title');
 let $buttonSubmit = document.getElementById('btn-submit');
 let $ulList = document.getElementById('ul-list');
 $buttonSubmit.addEventListener('click', function () {
 let title = $txtTitle.value;
 if(!title) return false;

 let $li = document.createElement('li');
 $li.innerText = title;

 $ulList.appendChild($li);
 $txtTitle.value = '';
 })
</script>
</body>
```

 vue实现todo-list

```html
<body>
<div id="app">
 <div>
 <input v-model="title"> <br>
 <button id="btn-submit" v-on:click="add">submit</button>
 </div>
 <div>
 <ul id="ul-list">
 <li v-for="item in list">{{item}}</li>
 </ul>
 </div>
</div>
<script>
 let vm = new window.Vue({
 el: '#app',
 data: {
 title: '',
 list: []
 },
 methods: {
 add: function () {
 this.list.push(this.title);
 this.title = '';
 }
 }
 })
</script>
</body>
```

 两者之间的区别

* 数据和视图分离(开放封闭原则： 扩展开放，修改封闭)

* 数据驱动视图

 对mvvm的理解

具体的理解自己再去整理

MVVM框架的三大要素：
响应式、模板引擎、渲染

应式的实现

修改data属性之后，立马就能监听到。
data属性挂在到vm实例上面。

有下面的一个问题，我们是如何监听属性的获取和属性的赋值的。

```js
const obj = {
  name: 'yanle',
  age: 25
}
console.log(obj.name)
obj.age = 26
```

是通过**Object.defineProperty** 实现的, 下面的代码就可以实现一个完整的属性修改和获取的监听。

```js
const vm = {}
const data = {
  name: 'yanle',
  age: 25
}
let key, value
for (key in data) {
  (function (key) {
    Object.defineProperty(vm, key, {
      get: function () {
        console.log('get', data[key])
        return data[key] // data的属性代理到vm 上
      },
      set: function (newValue) {
        console.log('set', newValue)
        data[key] = newValue
      }
    })
  })(key)
}
```

ue中的模板

**模板**
本质就是字符串；
有逻辑： if for 等；
跟html格式很像， 但是区别很大;
最终要转为HTML来现实；
模板需要用JS代码来实现， 因为有逻辑，只能用JS来实现；

**render函数-with用法**：

```js
const obj = {
  name: 'yanle',
  age: 20,
  getAddress: function () {
    alert('重庆')
  }
}
// 不用with 的情况
// function fn() {
// alert(obj.name);
// alert(obj.age);
// obj.getAddress();
// }
// fn();

// 使用with的情况
// function fn1() {
//  with (obj) {
//  alert(name);
//  alert(age);
//  getAddress();
//  }
// }
fn1()
```

这种with 的使用方法就如上所述。但是尽量不要用，因为《JavaScript语言精粹》中，作者说过，这种使用方式会给代码的调试带来非常大的困难。
但是vue源码中的render 就是用的这个;

**render函数**:

<img width="274" alt="02-12-1" src="https://user-images.githubusercontent.com/22188674/224475416-9567c516-981f-4399-9128-4efcb70e8502.png"/>

![02-12-2](https://user-images.githubusercontent.com/22188674/224475405-34baf640-f897-4a26-9817-109e8b4c1bde.png)

模板中的所有信息都包含在了render 函数中。
一个特别简单的示例:

```js
const vm = new Vue({
  el: '#app',
  data: {
    price: 200
  }
})

function render1 () {
  return vm._c(
    'div',
    {
      attr: { id: 'app' }
    },
    [
      _c('p', [vm._v(vm._s(vm.price))]) // vm._v 是创建文本， _s 就是toString
    ]
  )
}
```

如果我们用一个复杂的例子来描述这个东西。在源码中， 搜索code.render, 然后在在此之前打印render 函数，就可以看看这个到底是什么东西了。

```js
const createCompiler = createCompilerCreator(function baseCompile (
  template,
  options
) {
  const ast = parse(template.trim(), options)
  if (options.optimize !== false) {
    optimize(ast, options)
  }
  const code = generate(ast, options)
  console.log(code.render)
  return {
    ast,
    render: code.render,
    staticRenderFns: code.staticRenderFns
  }
})
```

然后运行， 就可以看到到底render 函数是什么东西了。 就可以截取源码出来看了。
相对应的模板如下:

```html
<div id="app">
 <div>
 <input v-model="title"> <br>
 <button id="btn-submit" v-on:click="add">submit</button>
 </div>
 <div>
 <ul id="ul-list">
 <li v-for="item in list">{{item}}</li>
 </ul>
 </div>
</div>
```

截取的render函数如下：

从vue2.0开始支持预编译， 我们在开发环境下，写模板， 编译打包之后， 模板就变成了JS代码了。vue已经有工具支持这个过程。

ue中的渲染

vue的渲染是直接渲染为虚拟dom ,这一块儿的内容，其实是借鉴的snabbdom, 非常相似，可以去看看snabbdom 就可以一目了然了。
vue中的具体渲染实现:
![02-12-03](https://user-images.githubusercontent.com/22188674/224475434-c4e33700-d223-4472-8e96-5cc7b6c04d70.png)

体流程的实现

第一步： 解析模板形成render 函数

* with 用法
* 模板中的所有数据都被render 函数包含
* 模板中data的属性，变成了JS变量
* 模板中的v-model、v-for、v-on都变成了JS的逻辑
* render函数返回vnode

第二步： 响应式开始监听数据变化

* Object.defineProperty 的使用
* 讲data中的属性代理到vm 上

第三步： 首次渲染，显示页面，而且绑定数据和依赖

* 初次渲染， 执行updateComponent, 执行vm._render();
* 执行render函数， 会访问到vm.list和vm.title等已经绑定好了的数据；
* 会被详情是的get 方法监听到
 为何一定要监听get, 直接监听set 不行吗？ data中有很多的属性，有的被用到了，有的没有被用到。被用到的会走get, 不被用到的不会走get。
 没有被get监听的属性，set的时候也不会被坚挺。为的就是减少不必要的重复渲染，节省性能。
* 执行updateComponent的时候，会执行vdom的patch方法
* patch 讲vnode渲染为DOM， 初次渲染完成

第四步： data属性变化，出发render

* 修改属性值， 会被响应式的set监听到
* set中会执行updateComponent， 重新执行vm.render()
* 生成vnode和prevVnode, 通过patch进行对比
* 渲染到html中

## vdom {#p0-vdom}

vue2.0就是使用的snabbdom
一个简单的使用实例：

```jsx
const snabbdom = require('snabbdom')
const patch = snabbdom.init([ // Init patch function with chosen modules
  require('snabbdom/modules/class').default, // makes it easy to toggle classes
  require('snabbdom/modules/props').default, // for setting properties on DOM elements
  require('snabbdom/modules/style').default, // handles styling on elements with support for animations
  require('snabbdom/modules/eventlisteners').default // attaches event listeners
])
const h = require('snabbdom/h').default // helper function for creating vnodes

const container = document.getElementById('container')

const vnode = h('div#container.two.classes', { on: { click: someFn } }, [
  h('span', { style: { fontWeight: 'bold' } }, 'This is bold'),
  ' and this is just normal text',
  h('a', { props: { href: '/foo' } }, 'I\'ll take you places!')
])
// Patch into empty DOM element – this modifies the DOM as a side effect
patch(container, vnode)

const newVnode = h('div#container.two.classes', { on: { click: anotherEventHandler } }, [
  h('span', { style: { fontWeight: 'normal', fontStyle: 'italic' } }, 'This is now italic type'),
  ' and this is still just normal text',
  h('a', { props: { href: '/bar' } }, 'I\'ll take you places!')
])
// Second `patch` invocation
patch(vnode, newVnode) // Snabbdom efficiently updates the old view to the new state
```

 snabbdom 核心api

* snabbdom.init:
 The core exposes only one single function snabbdom.init. This init takes a list of modules and returns a patch function that uses the specified set of modules.

```js
const patch = snabbdom.init([
  require('snabbdom/modules/class').default,
  require('snabbdom/modules/style').default
])
```

* patch:

```js
patch(oldVnode, newVnode)
```

* snabbdom/h:
 It is recommended that you use snabbdom/h to create vnodes. h accepts a tag/selector as a string, an optional data object and an optional string or array of children.

```js
const h = require('snabbdom/h').default
const vnode = h('div', { style: { color: '#000' } }, [
  h('h1', 'Headline'),
  h('p', 'A paragraph')
])
```

* snabbdom/tovnode:
 Converts a DOM node into a virtual node. Especially good for patching over an pre-existing, server-side generated content.

```js
const snabbdom = require('snabbdom')
const patch = snabbdom.init([ // Init patch function with chosen modules
  require('snabbdom/modules/class').default, // makes it easy to toggle classes
  require('snabbdom/modules/props').default, // for setting properties on DOM elements
  require('snabbdom/modules/style').default, // handles styling on elements with support for animations
  require('snabbdom/modules/eventlisteners').default // attaches event listeners
])
const h = require('snabbdom/h').default // helper function for creating vnodes
const toVNode = require('snabbdom/tovnode').default

const newVNode = h('div', { style: { color: '#000' } }, [
  h('h1', 'Headline'),
  h('p', 'A paragraph')
])

patch(toVNode(document.querySelector('.container')), newVNode)
```

 h函数 和 patch 的使用

例如下面的一个dom 结构：

```html
<ul id="list">
 <li class="item">item1</li>
 <li class="item">item2</li>
</ul>
```

用h函数来表示，就如下形式：

```js
const vnode = h('ul#list', {}, [
  h('li.item', {}, 'item1'),
  h('li.item', {}, 'item2')
])
```

作用就是模拟的一个真实节点。

patch的使用方式：
第一种方式 patch('容器', vnode); // 这种使用方式是直接渲染dom
第二种是用方式: patch(oldVnode, newVnode); // 这种方式会自动对比dom的差异性，然后只渲染我们需要dom;

一个简单的使用实例：

```html
<!DOCTYPE html>
<html lang="en">
<head>
 <meta charset="UTF-8">
 <title>snabbdom</title>
 <script src="https://cdn.bootcss.com/snabbdom/0.7.1/snabbdom.js"></script>
 <script src="https://cdn.bootcss.com/snabbdom/0.7.1/snabbdom-class.js"></script>
 <script src="https://cdn.bootcss.com/snabbdom/0.7.1/snabbdom-props.js"></script>
 <script src="https://cdn.bootcss.com/snabbdom/0.7.1/snabbdom-style.js"></script>
 <script src="https://cdn.bootcss.com/snabbdom/0.7.1/snabbdom-eventlisteners.js"></script>
 <script src="https://cdn.bootcss.com/snabbdom/0.7.1/h.js"></script>
</head>
<body>
<div id="container"></div><br>

<button id="btn-change">change</button>


<script>
 let snabbdom = window.snabbdom;
 let container = document.getElementById('container');
 let buttonChange = document.getElementById('btn-change');

 // 定义patch
 let patch = snabbdom.init([
 snabbdom_class,
 snabbdom_props,
 snabbdom_style,
 snabbdom_eventlisteners
 ]);

 // 定义h
 let h = snabbdom.h;

 // 生成vnode
 let vnode = h('ul#list', {}, [
 h('li.item', {}, 'item1'),
 h('li.item', {}, 'item2')
 ]);
 patch(container, vnode);

 // 模拟一个修改的情况
 buttonChange.addEventListener('click', function () {
 let newVnode = h('ul#list', {}, [
 h('li.item', {}, 'item1'),
 h('li.item', {}, 'item B'),
 h('li.item', {}, 'item 3')
 ]);
 patch(vnode, newVnode);
 })
</script>
</body>
</html>
```

 snabbdom 的使用实例

```html
<body>
<div id="container"></div>
<br>
<button id="btn-change">change</button>
<script>
 let snabbdom = window.snabbdom;
 let container = document.getElementById('container');
 let buttonChange = document.getElementById('btn-change');

 // 定义patch
 let patch = snabbdom.init([
 snabbdom_class,
 snabbdom_props,
 snabbdom_style,
 snabbdom_eventlisteners
 ]);

 // 定义h
 let h = snabbdom.h;
 let data = [
 {
 name: 'yanle',
 age: '20',
 address: '重庆'
 },
 {
 name: 'yanle2',
 age: '25',
 address: '成都'
 },
 {
 name: 'yanle3',
 age: '27',
 address: '深圳'
 }
 ];

 data.unshift({
 name: '姓名',
 age: '年龄',
 address: '地址'
 });

 let vnode;
 function render(data) {
 let newVnode = h('table', {style: {'font-size': '16px'}}, data.map(function (item) {
 let tds = [];
 let i ;
 for (i in item) {
 if(item.hasOwnProperty(i)) {
 tds.push(h('td', {}, h('a', {props: {href: '/foo'}}, item[i])))
 }
 }
 return h('tr', {}, tds)
 }));

 if(vnode) {
 patch(vnode, newVnode);
 } else {
 patch(container, newVnode);
 }

 vnode = newVnode;
 }

 // 初次渲染
 render(data);
 buttonChange.addEventListener('click', function () {
 data[1].age=30;
 data[1].address = '非洲';
 render(data);
 });
</script>
</body>
```

iff算法

 概念

就是找出两个文件的不同

diff 算法是非常复杂的，实现难度非常大， 源码两非常大。 所以需要去繁就简，明白流程，不关心细节。
在vdom中，需要找出本次dom 必须更新的节点来更新，其他的不用更新。找出这个过程就是diff算法实现的。找出前后两个虚拟dom的差异。

 diff实现的过程

这里以snabbdom为例子：
patch(container, vnode); patch(vnode, newVnode); 这两个方法里面就使用到了diff算法。 用patch方法来解析diff算法流程核心。

**patch(container, vnode)**
![02-11-1](https://user-images.githubusercontent.com/22188674/224475327-0b8f19b3-7a35-40ec-960b-6040852f1a7d.png)

如果上面的数据， 我们怎么构建真正的dom 结构：

```js
const createElement = function (vnode) {
  const tag = vnode.tag
  const attrs = vnode.attrs || {}
  const children = vnode.children || {}

  if (!tag) return null

  // 创建元素
  const elem = document.createElement(tag)

  // 属性
  let attrName
  for (attrName in attrs) {
    // eslint-disable-next-line
    if (attrs.hasOwnProperty(attrName)) {
      elem.setAttribute(attrName, attrs[attrName])
    }
  }

  // 子元素
  children.forEach(function (childVnode) {
    // 给 elem 添加元素
    elem.appendChild(createElement(childVnode))
  })

  return elem
}
```

**patch(vnode, newVnode)**
![02-11-2](https://user-images.githubusercontent.com/22188674/224475289-d2f8b10a-1f02-4126-9f2e-b813b0387c84.png)
![02-11-3](https://user-images.githubusercontent.com/22188674/224475309-45c68933-3aa8-402a-8353-d09b506e0d46.png)

伪代码实现如下

```js
const createElement = function (vnode) {
  const tag = vnode.tag
  const attrs = vnode.attrs || {}
  const children = vnode.children || {}

  if (!tag) return null

  // 创建元素
  const elem = document.createElement(tag)

  // 属性
  let attrName
  for (attrName in attrs) {
    // eslint-disable-next-line
    if (attrs.hasOwnProperty(attrName)) {
      elem.setAttribute(attrName, attrs[attrName])
    }
  }

  // 子元素
  children.forEach(function (childVnode) {
    // 给 elem 添加元素
    elem.appendChild(createElement(childVnode))
  })

  return elem
}
```

 diff算法的其他内容

* 节点的新增和删除

* 节点重新排序
* 节点属性、样式、事件绑定
* 如果极致压榨性能

dom 概念

用JS模拟DOM结构。
DOM变化的对比，放在JS层来做。
提升重绘性能。

比如有abc 三个dom， 如果我们要删除b dom, 以前浏览器的做法是 全部删除abc dom ， 然后 在添加b dom 。这样做的成本会非常高。

JS模拟 dom

例如下面的一个dom 结构：

```html
<ul id="list">
 <li class="item">item1</li>
 <li class="item">item2</li>
</ul>
```

这样的dom 结构，可以模拟为下面的JS :

```js
const dom = {
  tag: 'ul',
  attrs: {
    id: 'list'
  },
  children: [
    {
      tag: 'li',
      attrs: { className: 'item' },
      children: ['item1']
    },
    {
      tag: 'li',
      attrs: { className: 'item' },
      children: ['item2']
    }
  ]
}
```

浏览器操作dom 是花销非常大的。执行JS花销要小非常多，所以这就是为什么虚拟dom 出现的一个根本原因。

query实现virtual-dom

 一个需求场景

1、数据生成表格。 2、随便修改一个信息，表格也会跟着修改。

```html
<body>
<div id="container"></div>
<br>
<button id="btn-change">change</button>
<script>
 let data = [
 {
 name: 'yanle',
 age: '20',
 address: '重庆'
 },
 {
 name: 'yanle2',
 age: '25',
 address: '成都'
 },
 {
 name: 'yanle3',
 age: '27',
 address: '深圳'
 }
 ];

 // 渲染函数
 function render(data) {
 let $container = document.getElementById('container');
 $container.innerHTML = '';

 let $table = document.createElement('table');
 $table.setAttribute('border', true);
 $table.insertAdjacentHTML('beforeEnd', `<tr>
 <td>name</td>
 <td>age</td>
 <td>address</td>
 </tr>`);

 data.forEach(function (item) {
 $table.insertAdjacentHTML('beforeEnd',
 `<tr>
 <td>${item.name}</td>
 <td>${item.age}</td>
 <td>${item.address}</td>
 </tr>`
 )
 });

 $container.appendChild($table);
 }

 // 修改信息
 let button = document.getElementById('btn-change');
 button.addEventListener('click', function () {
 data[1].name = '徐老毕';
 data[1].age = 30;
 data[1].address = '深圳';
 render(data);
 });
 render(data);
</script>
</body>
```

实际上上面的这段代码也是不符合预期的，因为每次使用render 方法，都会全部渲染整个table, 但是并未没有只渲染我们想要的第二行。

**遇到的问题**：
DOM 操作是非常 "昂贵" 的， JS 运行效率高。虚拟dom 的核心就是diff算法，对比出不同的dom数据，定点渲染不同的数据。

## vue3 的 diff 算法是什么 {#p0-diff}

Vue3的diff算法是一种用于比较虚拟DOM树之间差异的算法。它用于确定需要更新的部分，以便最小化对实际DOM的操作，从而提高性能。

Vue3的diff算法采用了一种称为"逐层比较"的策略，即从根节点开始逐层比较虚拟DOM树的节点。具体的比较过程如下：

1. 对比两棵虚拟DOM树的根节点，判断它们是否相同。如果不相同，则直接替换整个根节点及其子节点，无需进一步比较。
2. 如果根节点相同，则对比它们的子节点。这里采用了一种称为"双端比较"的策略，即同时从两棵树的头部和尾部开始比较子节点。
3. 从头部开始，依次对比两棵树的相同位置的子节点。如果两个子节点相同，则继续比较它们的子节点。
4. 如果两个子节点不同，根据一些启发式规则（如节点类型、key值等），判断是否需要替换、删除或插入子节点。
5. 继续比较下一个位置的子节点，直到两棵树的所有子节点都被比较完。

通过逐层比较和双端比较的策略，Vue3的diff算法能够高效地找到虚拟DOM树之间的差异，并只对需要更新的部分进行操作，从而减少了对实际DOM的操作次数，提高了性能。

值得注意的是，Vue3还引入了一种称为"静态标记"的优化策略，用于在编译阶段将一些静态节点标记出来，从而在diff算法中更快地跳过这些静态节点的比较，进一步提升性能。这一优化策略在处理大型列表、静态内容等场景下特别有效。

## key 的作用

* 用于 Vue 的虚拟 DOM diff 算法，帮助 Vue 准确找到对应的节点，高效地更新虚拟 DOM
* 避免"就地复用"带来的副作用，特别是在列表渲染时
* 触发组件的重新渲染

## v-if 和 v-show 差别

## 响应式原理 {#p0-reactivity-theory}

如果一个对象中有属性有方法，那么调用属性可以直接. 就可以调用，但是如果是调用方法的时候，是通过入参来决定key的值来调用的话，请用[]来表示：

```html
<!DOCTYPE html>
<html lang="en" xmlns:v-on="http://www.w3.org/1999/xhtml">
 <head>
 <meta charset="UTF-8">
 <title>MVVM 双项绑定</title>
 <style>
 #app {
 text-align: center;
 margin-top: 100px;
 color: #888;
 }

 h1 {
 color: #aaa;
 }

 input {
 padding: 0 10px;
 width: 600px;
 line-height: 2.5;
 border: 1px solid #ccc;
 border-radius: 2px;
 }

 .bind {
 color: #766;
 }

 strong {
 color: #05BC00;
 }

 button {
 padding: 5px 10px;
 border: 1px solid #777777;
 border-radius: 5px;
 background: #ffffff;
 color: #777777;
 cursor: pointer;

 }
 </style>
 </head>
 <body>
 <div id="app">
 <h1>Hi，MVVM</h1>
 <input v-model="name" placeholder="请输入内容" type="text">
 <h1 class="bind">{{name}} 's age is <strong>{{age}}</strong></h1>
 <button v-on:click="sayHi">点击欢迎您</button>
 </div>
 <script>
 function observe(data) {
 //如果不是一个对象，直接终止程序
 if (!data || typeof data !== 'object') {
 return false;
 }
 for (let key in data) {
 let val = data[key];
 let subject = new Subject();
 Object.defineProperty(data, key, {
 enumerable: true,
 configurable: true,
 get: function () {
 if (currentObserver) {
 currentObserver.subscribeTo(subject)
 }
 return val
 },
 set: function (newVal) {
 val = newVal;
 subject.notify()
 }
 });
 if (typeof val === 'object') {
 observe(val)
 }
 }
 }

 let id = 0;
 let currentObserver = null;

 /bin /sbin订阅者对象
 */
 class Subject {
 constructor() {
 this.id = id++;
 this.observers = []
 }

 addObserver(observer) {
 this.observers.push(observer)
 }

 removeObserver(observer) {
 let index = this.observers.indexOf(observer)
 if (index > -1) {
 this.observers.splice(index, 1)
 }
 }

 notify() {
 this.observers.forEach(observer => {
 observer.update()
 })
 }
 }

 /bin /sbin观察者对象
 */
 class Observer {
 constructor(vm, key, cb) {
 this.subjects = {};
 this.vm = vm;
 this.key = key;
 this.cb = cb;
 this.value = this.getValue()
 }

 //如果新旧数据不相同，就直接调用cb方法
 update() {
 let oldVal = this.value;
 let value = this.getValue();
 if (value !== oldVal) {
 this.value = value;
 this.cb.bind(this.vm)(value, oldVal)
 }
 }

 //添加观察者
 subscribeTo(subject) {
 if (!this.subjects[subject.id]) { //如果当前换擦着中不存在这个当前id的一个对象，那么吧这个对象添加为观察者
 subject.addObserver(this);
 this.subjects[subject.id] = subject //放在观察者对象中，根据自增id来区分
 }
 }

 getValue() {
 currentObserver = this;
 let value = this.vm.$data[this.key]; //获取vm实例兑现中的data数据
 currentObserver = null;
 return value
 }
 }

 /bin /sbin编译对象
 */
 class Compile {
 constructor(vm) {
 this.vm = vm; //vm对象
 this.node = vm.$el; //获取挂载的元素dom
 this.compile();//执行核心功能
 }

 compile() {
 this.traverse(this.node);//传入的参数是挂载元素dom
 }

 traverse(node) {
 if (node.nodeType === 1) { //节点类型1：element元素
 this.compileNode(node); //触发节点事件 双向绑定和事件触发
 node.childNodes.forEach(childNode => {
 this.traverse(childNode); // 递归调用，如果是有子节点，重新递归
 })
 } else if (node.nodeType === 3) { // 节点类型3： 文本元素
 this.compileText(node); // 处理文本元素的编译
 }
 }

 // 文本编译入口
 compileText(node) {
 let reg = /{{(.+?)}}/g;
 let match;
 while (match = reg.exec(node.nodeValue)) { //获取到文本内容
 let raw = match[0]
 let key = match[1].trim()
 node.nodeValue = node.nodeValue.replace(raw, this.vm.$data[key]);
 new Observer(this.vm, key, function (val, oldVal) { // 订阅者核心方法
 node.nodeValue = node.nodeValue.replace(oldVal, val)
 })
 }
 }

 // 节点编译入口
 compileNode(node) {
 let attrs = [...node.attributes];//获取标签属性
 attrs.forEach(attr => {
 if (this.isModelDirective(attr.name)) { //截取是绑定数据的情况
 this.bindModel(node, attr); //绑定数据
 } else if (this.isEventDirective(attr.name)) { //截取是绑定事件的情况
 this.bindEventHander(node, attr); //触发事件
 }
 })
 }

 /bin /sbin双向绑定数据
@param node 标签节点
@param attr 标签节点的属性名
 */
 bindModel(node, attr) {
 let key = attr.value;// 获取到传递过来的属性的key的值
 node.value = this.vm.$data[key]; //给节点绑定值，对应的值就是vm实例里面data对应key的值
 new Observer(this.vm, key, function (newVal) {
 node.value = newVal
 });
 node.oninput = (e) => { //监听节点的input事件
 this.vm.$data[key] = e.target.value //过去输入框中输入的value值，把这个值放入到vm的data实例中去
 }
 }

 /bin /sbin *
@param node
@param attr
 */
 bindEventHander(node, attr) {
 let eventType = attr.name.substr(5); //获取节点属性,从第五个下标开始截取后面的字符串作为：key(事件类型)
 let methodName = attr.value; //获取节点的属性的value
 node.addEventListener(eventType, this.vm.$methods[methodName]);//通过事件类型，来触发事件，事件就是vm实例中方法
 }

 //赛选出传入的node属性是v-model的情况
 isModelDirective(attrName) {
 return attrName === 'v-model'
 }

 //赛选出传入的node属性是 v-on的情况
 isEventDirective(attrName) {
 return attrName.indexOf('v-on') === 0
 }
 }

 class mvvm {
 constructor(opts) { //这里面的函数是实例化的时候执行的
 this.init(opts);
 observe(this.$data);
 new Compile(this); //变异当前对象
 }

 init(opts) {
 if (opts.el.nodeType === 1) {
 this.$el = opts.el
 } else {
 this.$el = document.querySelector(opts.el)
 }

 this.$data = opts.data || {};
 this.$methods = opts.methods || {};
 //把$data 中的数据直接代理到当前 vm 对象
 for (let key in this.$data) {
 Object.defineProperty(this, key, {
 enumerable: true,
 configurable: true,
 get: () => {
 return this.$data[key]
 },
 set: newVal => {
 this.$data[key] = newVal
 }
 })
 }
 //让 this.$methods 里面的函数中的 this，都指向当前的 this，也就是 vm对象实例
 for (let key in this.$methods) {
 this.$methods[key] = this.$methods[key].bind(this);
 }
 }
 }


 /bin /sbin实例化MVVM对象， 主入口
@type {mvvm}
 */
 let vm = new mvvm({
 el: '#app',
 data: {
 name: 'YanLe',
 age: 3
 },
 methods: {
 sayHi: function () {
 alert(`hi ${this.name}`)
 }
 }
 });

 let clock = setInterval(function () {
 vm.age++; //等同于 vm.$data.age

 if (vm.age === 10) clearInterval(clock)
 }, 1000)
 </script>
 </body>
</html>
```

Vue3.0 通过使用 Composition API 中的 `reactive` 和 `ref` 函数来实现数据双向绑定。

1. reactive 函数

`reactive` 函数是 Vue3.0 中用来创建响应式对象的函数。将一个 JavaScript 对象传递给 `reactive` 函数，它会返回一个新的响应式对象。响应式对象是一个 Proxy 对象，可以在应用程序中使用它来自动追踪数据的变化。

例如，我们可以这样使用 `reactive` 函数来创建一个响应式对象：

```js
import { reactive } from 'vue'

const state = reactive({
  message: 'Hello, world!'
})
```

在上面的示例中，我们使用 `reactive` 函数创建了一个包含一个 `message` 属性的响应式对象。

2. ref 函数

`ref` 函数是 Vue3.0 中用来创建一个包含单个值的响应式对象的函数。将一个初始值传递给 `ref` 函数，它会返回一个新的响应式对象。响应式对象是一个普通对象，它有一个名为 `value` 的属性，该属性保存了当前值。当 `value` 属性的值发生改变时，Vue3.0 会自动更新应用程序的界面。

例如，我们可以这样使用 `ref` 函数来创建一个响应式对象：

```js
import { ref } from 'vue'

const count = ref(0)
```

在上面的示例中，我们使用 `ref` 函数创建了一个包含初始值为 0 的响应式对象。

3. 双向绑定的实现

Vue3.0 中的双向绑定可以通过在模板中使用 `v-model` 指令来实现。`v-model` 指令是 Vue3.0 中用来实现表单元素和组件的双向数据绑定的指令。例如，我们可以这样使用 `v-model` 指令来实现一个表单输入框的双向绑定：

```html
htmlCopy code<template>
 <input v-model="message" />
 <p>{{ message }}</p>
</template>

<script>
 import { ref } from 'vue';

 export default {
 setup() {
 const message = ref('');

 return {
 message
 };
 }
 };
</script>
```

在上面的示例中，我们在模板中使用 `v-model` 指令将输入框和 `message` 响应式对象进行双向绑定。当用户在输入框中输入文本时，`message` 响应式对象的值会自动更新，当 `message` 响应式对象的值发生改变时，界面上的文本也会自动更新。

总之，Vue3.0 使用 `reactive` 和 `ref` 函数来实现数据双向绑定。使用 `reactive` 函数可以创建包含多个属性的响应式对象，使用 `ref` 函数可以创建包含单个值的响应式对象。通过在模板中使用 \`v-model

指令可以实现表单元素和组件的双向数据绑定，将表单元素的值绑定到响应式对象的属性上，当响应式对象的属性值变化时，自动更新绑定的表单元素的值。

除了使用 `v-model` 指令实现双向绑定，Vue3.0 也提供了 `watch` 函数和 `watchEffect` 函数来实现响应式数据的监听和副作用函数的执行。这些函数可以用来监听响应式数据的变化，从而执行特定的操作。下面是一个使用 `watch` 函数监听响应式数据变化的示例：

```html
htmlCopy code<template>
 <div>{{ count }}</div>
 <button @click="increment">Increment</button>
</template>

<script>
 import { ref, watch } from 'vue';

 export default {
 setup() {
 const count = ref(0);

 watch(count, (newVal, oldVal) => {
 console.log(`count changed from ${oldVal} to ${newVal}`);
 });

 const increment = () => {
 count.value++;
 };

 return {
 count,
 increment
 };
 }
 };
</script>
```

在上面的示例中，我们使用 `watch` 函数监听 `count` 响应式对象的变化，当 `count` 响应式对象的值发生变化时，会自动调用回调函数，打印出 `count` 变化前和变化后的值。

另外，Vue3.0 中还提供了 `computed` 函数用来计算一个响应式对象的值，`toRefs` 函数用来将一个响应式对象转换为普通的对象，并且在 TypeScript 中使用时可以使用 `defineComponent` 函数来定义组件的类型，从而提高代码的可读性和可维护性。

Vue.js 的响应式原理主要是通过数据劫持（Object.defineProperty()）实现。当我们在Vue实例中定义了一个 data 属性时，Vue 会对这个属性进行劫持，即在getter和setter时做一些操作。

具体实现流程如下：

1. 在Vue实例化时，Vue 会对 data 对象进行遍历，使用 Object.defineProperty() 方法将每个属性转换为 getter 和 setter。
2. 当数据发生变化时，setter 会被调用，并通知所有相关联的视图进行更新。
3. 当视图进行更新时，Vue 会对新旧 VNode 进行比对（diff）, 只对发生了变化的部分进行更新，从而提高效率。

这种数据劫持的方式能够让开发者以声明式的方式来编写代码，同时又能够监测到数据的变化，并及时地通知相关视图进行更新。

Vue 的响应式原理还包括了watcher和dep的概念。Watcher 用于监听数据的变化，并在变化时触发相应的回调函数，而 Dep 则用于收集 Watcher，当数据发生变化时通知所有相关的 Watcher 去更新视图。

Vue 的响应式原理是一种通过数据劫持实现的观察者模式，通过对数据的监听和更新，实现了数据驱动视图的变化，提高了代码的可维护性和开发效率。

响应式流程:

1. Observe：Vue 在实例化时会对 data 对象进行遍历，将每个属性转换为 getter 和 setter，以进行数据劫持。当数据发生变化时，setter 会被调用。在 setter 中，Vue 会通知所有相关的 Watcher 去更新视图。

2. Compile：Compile 是 Vue 的编译器，用于编译模板，将模板转换为 VNode。在编译模板时，Compile 会根据模板中的指令和表达式创建对应的 Watcher。当数据发生变化时，相关的 Watcher 会被触发，从而更新视图。

3. Watcher：Watcher 是订阅者，用于监听数据的变化，并在变化时触发相应的回调函数。每个 Watcher 都会对应一个数据项和一个表达式。当数据发生变化时，Watcher 会重新计算表达式的值，并触发回调函数。

4. Dep：Dep 用于收集 Watcher，当数据发生变化时通知所有相关的 Watcher 去更新视图。在 Observe 中，每个属性都会对应一个 Dep。在 getter 中，如果当前 Watcher 存在，则会将该 Watcher 添加到 Dep 中。在 setter 中，如果数据发生变化，则会通知 Dep 中所有的 Watcher 去更新视图。

综上所述，Observe、Compile、Watcher 和 Dep 一起构成了 Vue 的响应式流程。这一流程包括了数据劫持、模板编译、订阅者监听和更新视图等多个环节，从而实现了 Vue 的数据驱动视图的特性。

Vue 在早期版本中使用了 `Object.defineProperty` 来实现响应式系统。但是，在 `Object.defineProperty` 中存在一些限制和局限性，导致在某些场景下无法完全满足需求。因此，Vue 在最新的版本中引入了 `Proxy` 来替代 `Object.defineProperty`。

以下是一些 `Proxy` 相对于 `Object.defineProperty` 的优势：

1. 功能更强大：`Proxy` 可以代理整个对象，而 `Object.defineProperty` 只能对已存在的属性进行拦截。使用 `Proxy` 可以在对象级别上进行拦截、代理、验证等操作。

2. 更易于使用和理解：`Proxy` 提供了一组更直观和易于理解的 API，使开发者可以更容易地创建和管理代理。

3. 性能优化：`Proxy` 针对属性的访问和修改都提供了更佳的性能优化。而 `Object.defineProperty` 在拦截属性访问和修改时会有一定的性能损耗。

4. 更好的嵌套支持：`Proxy` 可以代理嵌套对象的属性，而 `Object.defineProperty` 只能对顶层对象的属性进行拦截。

总的来说，`Proxy` 相对于 `Object.defineProperty` 在功能上更强大、使用更便捷、性能更优，并且在更复杂的场景下也能提供更好的支持。因此，Vue 在新版本中选择了使用 `Proxy` 来实现响应式系统。

> 在目前的前端面试中，vue的双向数据绑定已经成为了一个非常容易考到的点，即使不能当场写出来，至少也要能说出原理。本篇文章中我将会仿照vue写一个双向数据绑定的实例，名字就叫myVue吧。结合注释，希望能让大家有所收获。

 1、原理

Vue的双向数据绑定的原理相信大家也都十分了解了，主要是通过`Object对象的defineProperty属性，重写data的set和get函数来实现的`,这里对原理不做过多描述，主要还是来实现一个实例。为了使代码更加的清晰，这里只会实现最基本的内容，主要实现v-model，v-bind 和v-click三个命令，其他命令也可以自行补充。

添加网上的一张图

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/4/10/162ad3d5be3e5105~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image)

 2、实现

页面结构很简单，如下

```xml
<div id="app">
 <form>
 <input type="text" v-model="number">
 <button type="button" v-click="increment">增加</button>
 </form>
 <h3 v-bind="number"></h3>
 </div>

```

包含：

```css
1. 一个input，使用v-model指令
2. 一个button，使用v-click指令
3. 一个h3，使用v-bind指令。

```

我们最后会通过类似于vue的方式来使用我们的双向数据绑定，结合我们的数据结构添加注释

```php
var app = new myVue({
 el:'#app',
 data: {
 number: 0
 },
 methods: {
 increment: function() {
 this.number ++;
 },
 }
 })

```

首先我们需要定义一个myVue构造函数：

```js
function myVue (options) {

}
```

为了初始化这个构造函数，给它添加一 个\_init属性

```kotlin
function myVue(options) {
 this._init(options);
}
myVue.prototype._init = function (options) {
 this.$options = options; // options 为上面使用时传入的结构体，包括el,data,methods
 this.$el = document.querySelector(options.el); // el是 #app, this.$el是id为app的Element元素
 this.$data = options.data; // this.$data = {number: 0}
 this.$methods = options.methods; // this.$methods = {increment: function(){}}
 }

```

接下来实现\_obverse函数，对data进行处理，重写data的set和get函数

并改造\_init函数

```jsx
myVue.prototype._obverse = function (obj) { // obj = {number: 0}
  let value
  for (key in obj) { // 遍历obj对象
    if (obj.hasOwnProperty(key)) {
      value = obj[key]
      if (typeof value === 'object') { // 如果值还是对象，则遍历处理
        this._obverse(value)
      }
      Object.defineProperty(this.$data, key, { // 关键
        enumerable: true,
        configurable: true,
        get: function () {
          console.log(`获取${value}`)
          return value
        },
        set: function (newVal) {
          console.log(`更新${newVal}`)
          if (value !== newVal) {
            value = newVal
          }
        }
      })
    }
  }
}

myVue.prototype._init = function (options) {
  this.$options = options
  this.$el = document.querySelector(options.el)
  this.$data = options.data
  this.$methods = options.methods

  this._obverse(this.$data)
}
```

接下来我们写一个指令类Watcher，用来绑定更新函数，实现对DOM元素的更新

```kotlin
function Watcher(name, el, vm, exp, attr) {
 this.name = name; //指令名称，例如文本节点，该值设为"text"
 this.el = el; //指令对应的DOM元素
 this.vm = vm; //指令所属myVue实例
 this.exp = exp; //指令对应的值，本例如"number"
 this.attr = attr; //绑定的属性值，本例为"innerHTML"

 this.update();
 }

 Watcher.prototype.update = function () {
 this.el[this.attr] = this.vm.$data[this.exp]; //比如 H3.innerHTML = this.data.number; 当number改变时，会触发这个update函数，保证对应的DOM内容进行了更新。
 }

```

更新\_init函数以及\_obverse函数

那么如何将view与model进行绑定呢？接下来我们定义一个\_compile函数，用来解析我们的指令（v-bind,v-model,v-clickde）等，并在这个过程中对view与model进行绑定。

```ini
 myVue.prototype._init = function (options) {
 //...
 this._complie(this.$el);
 }

myVue.prototype._complie = function (root) { root 为 id为app的Element元素，也就是我们的根元素
 var _this = this;
 var nodes = root.children;
 for (var i = 0; i < nodes.length; i++) {
 var node = nodes[i];
 if (node.children.length) { // 对所有元素进行遍历，并进行处理
 this._complie(node);
 }

 if (node.hasAttribute('v-click')) { // 如果有v-click属性，我们监听它的onclick事件，触发increment事件，即number++
 node.onclick = (function () {
 var attrVal = nodes[i].getAttribute('v-click');
 return _this.$methods[attrVal].bind(_this.$data); //bind是使data的作用域与method函数的作用域保持一致
 })();
 }

 if (node.hasAttribute('v-model') && (node.tagName == 'INPUT' || node.tagName == 'TEXTAREA')) { // 如果有v-model属性，并且元素是INPUT或者TEXTAREA，我们监听它的input事件
 node.addEventListener('input', (function(key) {
 var attrVal = node.getAttribute('v-model');
 //_this._binding['number']._directives = [一个Watcher实例]
 // 其中Watcher.prototype.update = function () {
 // node['vaule'] = _this.$data['number']; 这就将node的值保持与number一致
 // }
 _this._binding[attrVal]._directives.push(new Watcher(
 'input',
 node,
 _this,
 attrVal,
 'value'
 ))

 return function() {
 _this.$data[attrVal] = nodes[key].value; // 使number 的值与 node的value保持一致，已经实现了双向绑定
 }
 })(i));
 }

 if (node.hasAttribute('v-bind')) { // 如果有v-bind属性，我们只要使node的值及时更新为data中number的值即可
 var attrVal = node.getAttribute('v-bind');
 _this._binding[attrVal]._directives.push(new Watcher(
 'text',
 node,
 _this,
 attrVal,
 'innerHTML'
 ))
 }
 }
 }

```

至此，我们已经实现了一个简单vue的双向绑定功能，包括v-bind, v-model, v-click三个指令。效果如下图

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/4/10/162ad3d5beb544b6~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image)

附上全部代码，不到150行

```html
<!DOCTYPE html>
<head>
 <title>myVue</title>
</head>
<style>
 #app {
 text-align: center;
 }
</style>
<body>
 <div id="app">
 <form>
 <input type="text" v-model="number">
 <button type="button" v-click="increment">增加</button>
 </form>
 <h3 v-bind="number"></h3>
 <form>
 <input type="text" v-model="count">
 <button type="button" v-click="incre">增加</button>
 </form>
 <h3 v-bind="count"></h3>
 </div>
</body>

<script>

 function myVue(options) {
 this._init(options);
 }

 myVue.prototype._init = function (options) {
 this.$options = options;
 this.$el = document.querySelector(options.el);
 this.$data = options.data;
 this.$methods = options.methods;

 this._binding = {};
 this._obverse(this.$data);
 this._complie(this.$el);
 }

 myVue.prototype._obverse = function (obj) {
 var _this = this;
 Object.keys(obj).forEach(function (key) {
 if (obj.hasOwnProperty(key)) {
 _this._binding[key] = {
 _directives: []
 };
 console.log(_this._binding[key])
 var value = obj[key];
 if (typeof value === 'object') {
 _this._obverse(value);
 }
 var binding = _this._binding[key];
 Object.defineProperty(_this.$data, key, {
 enumerable: true,
 configurable: true,
 get: function () {
 console.log(`${key}获取${value}`);
 return value;
 },
 set: function (newVal) {
 console.log(`${key}更新${newVal}`);
 if (value !== newVal) {
 value = newVal;
 binding._directives.forEach(function (item) {
 item.update();
 })
 }
 }
 })
 }
 })
 }

 myVue.prototype._complie = function (root) {
 var _this = this;
 var nodes = root.children;
 for (var i = 0; i < nodes.length; i++) {
 var node = nodes[i];
 if (node.children.length) {
 this._complie(node);
 }

 if (node.hasAttribute('v-click')) {
 node.onclick = (function () {
 var attrVal = nodes[i].getAttribute('v-click');
 return _this.$methods[attrVal].bind(_this.$data);
 })();
 }

 if (node.hasAttribute('v-model') && (node.tagName = 'INPUT' || node.tagName == 'TEXTAREA')) {
 node.addEventListener('input', (function(key) {
 var attrVal = node.getAttribute('v-model');
 _this._binding[attrVal]._directives.push(new Watcher(
 'input',
 node,
 _this,
 attrVal,
 'value'
 ))

 return function() {
 _this.$data[attrVal] = nodes[key].value;
 }
 })(i));
 }

 if (node.hasAttribute('v-bind')) {
 var attrVal = node.getAttribute('v-bind');
 _this._binding[attrVal]._directives.push(new Watcher(
 'text',
 node,
 _this,
 attrVal,
 'innerHTML'
 ))
 }
 }
 }

 function Watcher(name, el, vm, exp, attr) {
 this.name = name; //指令名称，例如文本节点，该值设为"text"
 this.el = el; //指令对应的DOM元素
 this.vm = vm; //指令所属myVue实例
 this.exp = exp; //指令对应的值，本例如"number"
 this.attr = attr; //绑定的属性值，本例为"innerHTML"

 this.update();
 }

 Watcher.prototype.update = function () {
 this.el[this.attr] = this.vm.$data[this.exp];
 }

 window.onload = function() {
 var app = new myVue({
 el:'#app',
 data: {
 number: 0,
 count: 0,
 },
 methods: {
 increment: function() {
 this.number ++;
 },
 incre: function() {
 this.count ++;
 }
 }
 })
 }
 </script>
```

如果喜欢请关注我的[Github](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Flouzhedong%2Fblog "https://github.com/louzhedong/blog")，给个[Star](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Flouzhedong%2Fblog "https://github.com/louzhedong/blog")吧，我会定期分享一些JS中的知识，^\_^

## Vue2 与 Vue3 的主要区别

1. 响应式系统的重新配置，使用proxy替换Object.defineProperty
2. typescript支持
3. 新增组合API，更好的逻辑重用和代码组织
4. v-if和v-for的优先级
5. 静态元素提升
6. 虚拟节点静态标记
7. 生命周期变化
8. 打包体积优化
9. ssr渲染性能提升
10. 支持多个根节点

* 参考文档: [资料](https://juejin.cn/post/6858558735695937544)

* 响应式系统: Vue3 使用 Proxy 替代了 Vue2 的 Object.defineProperty，提供了更好的性能和数组监听
* Composition API: Vue3 引入组合式 API，更好地支持代码复用和逻辑组织
* 性能提升: Vue3 通过静态标记、TreeShaking 等优化提升了性能
* TypeScript 支持: Vue3 使用 TypeScript 重写，提供更好的类型支持
* Fragment: Vue3 支持多根节点组件

## vue2 和 vue3 数组变化是如何处理的

数组拦截包括

1. vue3
1. get、set 代理拦截存取
2. apply 拦截方法
2. vue2
1. get/set 拦截存取
2. 重写原型拦截方法，**动态添加无法拦截**

## vue3 对虚拟 dom 做了哪些优化 {#p0-vue3-vdom}

Vue 3 对虚拟 DOM 进行了多方面的优化，主要包括以下几点：

**一、静态提升（Static Hoisting）**

1. 原理与作用：

* 在 Vue 3 的编译阶段，会分析模板中的静态内容，将静态的节点提升到渲染函数之外。这意味着对于静态的元素和文本，不会在每次渲染时都重新创建虚拟 DOM 节点，而是在组件首次渲染时创建一次，然后在后续的渲染中直接复用。
* 例如，如果一个组件的模板中有一个静态的标题文本，在 Vue 2 中，每次渲染都会为这个文本创建一个新的虚拟 DOM 节点。而在 Vue 3 中，这个静态文本会被提升，只在组件首次渲染时创建虚拟 DOM 节点，后续渲染直接使用已创建的节点。

2. 性能提升：

* 减少了虚拟 DOM 的创建和比较开销，特别是在组件频繁渲染时，效果尤为明显。因为静态内容通常不会改变，避免了不必要的重复操作，提高了渲染性能。

**二、补丁算法优化**

1. 更高效的比较策略：

* Vue 3 改进了虚拟 DOM 的补丁算法，能够更快速地找到新旧虚拟 DOM 树之间的差异。新的算法在比较节点时更加智能，能够准确判断节点的类型和属性变化，只对真正发生变化的节点进行更新操作。
* 例如，当一个列表中的某个元素的文本内容发生变化时，Vue 3 能够快速定位到这个变化的节点，而不会像 Vue 2 那样对整个列表进行逐一比较。

2. 减少不必要的操作：

* 通过更精确的比较，Vue 3 避免了一些不必要的 DOM 操作。例如，如果一个元素的样式属性没有发生变化，Vue 3 不会触发样式的重新设置，从而减少了对浏览器渲染引擎的压力。

**三、事件处理优化**

1. 静态事件提升：

* 对于静态的事件监听器，Vue 3 也会在编译阶段进行提升。如果一个组件的模板中有一个静态的点击事件监听器，在 Vue 3 中，这个事件监听器会被提取出来，在组件首次渲染时进行绑定，后续渲染中不再重复绑定。
* 例如，一个按钮的点击事件在组件的整个生命周期中都不会改变，那么在 Vue 3 中，这个事件监听器只会在首次渲染时绑定一次，提高了性能。

2. 事件缓存：

* Vue 3 还对事件进行了缓存处理。当一个组件被销毁时，它的事件监听器不会立即被移除，而是被缓存起来。如果这个组件在后续的渲染中再次出现，Vue 3 可以直接复用缓存的事件监听器，而不需要重新绑定，进一步提高了性能。

**四、编译器优化**

1. 更好的代码生成：

* Vue 3 的编译器能够生成更高效的渲染函数代码。通过对模板的分析和优化，编译器可以生成更加简洁、高效的虚拟 DOM 创建和更新代码。
* 例如，编译器可以根据模板中的条件判断和循环结构，生成更加优化的虚拟 DOM 操作代码，减少不必要的计算和操作。

2. 类型推断：

* Vue 3 的编译器支持类型推断，这使得在开发过程中可以获得更好的类型提示和错误检查。同时，类型推断也可以帮助编译器生成更加高效的代码，因为编译器可以根据类型信息进行一些优化操作。
* 例如，如果一个组件的 props 定义了明确的类型，编译器可以在生成虚拟 DOM 代码时，针对这些类型进行优化，提高代码的执行效率。

Vue 3 仍然使用虚拟 DOM（Virtual DOM）。

**一、虚拟 DOM 在 Vue 3 中的重要性**

1. 高效的 DOM 操作：虚拟 DOM 是一种在内存中表示真实 DOM 结构的树形数据结构。在 Vue 3 中，当数据发生变化时，首先会在虚拟 DOM 上进行比较和计算，确定最小化的 DOM 操作集合，然后再将这些操作应用到真实 DOM 上。这样可以避免直接频繁地操作真实 DOM，从而提高性能。

* 例如，当一个组件中的数据发生变化时，Vue 3 会先更新虚拟 DOM 树，然后通过对比新旧虚拟 DOM 树的差异，找出需要更新的真实 DOM 节点，最后只对这些节点进行实际的 DOM 操作。

2. 跨平台开发支持：虚拟 DOM 使得 Vue 3 不仅可以在浏览器中运行，还可以通过一些工具和技术进行跨平台开发。例如，使用 Vue Native 可以将 Vue 3 应用编译为原生移动应用，在移动平台上运行。这是因为虚拟 DOM 可以在不同的平台上进行渲染，而不需要依赖特定平台的 DOM 操作。

* 比如，在开发一个同时支持 Web 和移动平台的应用时，可以使用 Vue 3 的虚拟 DOM 来实现一套代码在多个平台上的运行，提高开发效率和代码复用性。

**二、Vue 3 对虚拟 DOM 的优化**

1. 静态提升（Static Hoisting）：Vue 3 在编译阶段会分析组件的模板，将静态的节点提升到渲染函数之外。这样在每次渲染时，不需要为静态节点创建新的虚拟 DOM 节点，从而减少了虚拟 DOM 的创建和比较开销。

* 例如，如果一个组件的模板中有一些静态的文本节点或元素，Vue 3 会在编译时将这些静态节点提取出来，在渲染时直接复用，而不是每次都重新创建虚拟 DOM 节点。

2. 补丁算法优化：Vue 3 对虚拟 DOM 的补丁算法进行了优化，使得在更新 DOM 时更加高效。新的补丁算法可以更快地找到需要更新的节点，减少不必要的比较和操作。

* 比如，在对比新旧虚拟 DOM 树时，Vue 3 可以更准确地判断节点的类型和属性变化，只对真正发生变化的节点进行更新，提高了渲染性能。

3. 事件处理优化：在 Vue 3 中，事件处理也进行了优化。对于静态的事件监听器，同样会在编译阶段进行提升，减少了每次渲染时的创建和绑定开销。

* 例如，如果一个组件中有一个静态的点击事件监听器，Vue 3 会在编译时将这个事件监听器提取出来，在渲染时直接复用，而不是每次都重新绑定。

## 实现一个简单的 i18n (国际化 (Internationalization) 的缩写) 插件 {#p3-implement-a-simple-i18n-internationalization-plugin}

实现下面的这样的一个插件 `<h1>{{ $translate('greetings.hello') }}</h1>`

以下是一个简单的 Vue 3 的国际化插件实现：

1. 创建一个名为`i18nPlugin.js`的文件：

```js
const i18nPlugin = {
  install (app, options) {
    const translations = options.translations
    app.config.globalProperties.$translate = (key) => {
      const parts = key.split('.')
      let value = translations[parts[0]]
      for (let i = 1; i < parts.length && value; i++) {
        value = value[parts[i]]
      }
      return value || key
    }
  }
}

export default i18nPlugin
```

2. 在你的 Vue 3 项目中使用这个插件：

假设你有以下的语言翻译对象：

```ts
// en.js
const enTranslations = {
  greetings: {
    hello: 'Hello!'
  }
}

// export default enTranslations

// zh.js
const zhTranslations = {
  greetings: {
    hello: '你好！'
  }
}

// export default zhTranslations
```

在项目的入口文件（通常是`main.js`或`main.ts`）中：

```js
import { createApp } from 'vue'
import App from './App.vue'
import enTranslations from './locales/en'
import i18nPlugin from './i18nPlugin'

const app = createApp(App)

app.use(i18nPlugin, { translations: enTranslations })

app.mount('#app')
```

这样，在你的组件中就可以使用`{{ $translate('greetings.hello') }}`来获取翻译后的文本，并且可以通过修改传入插件的翻译对象来切换不同的语言。

## 插件是什么概念，有什么作用，该怎么用 {#p4-what-is-the-plugin-what-is-its-purpose-and-how-to-use-it}

在 Vue 中，插件是一种用于增强 Vue 功能的工具。

**一、概念**

Vue 插件是一个包含`install`方法的对象，或者是一个函数，这个函数接收 Vue 的构造函数作为参数。插件可以为 Vue 添加全局的功能，如全局组件、全局指令、全局过滤器、全局混入（mixin）等，也可以扩展 Vue 的实例方法或原型属性。

**二、作用**

1. **添加全局功能**：

* **全局组件**：可以通过插件注册全局组件，使得在整个项目的任何组件中都可以直接使用这个组件，无需在每个组件中单独引入。例如，一个弹窗组件可以作为插件注册为全局组件，方便在项目中的各个地方弹出统一风格的弹窗。
* **全局指令**：插件可以添加全局指令，用于在模板中对元素进行特定的操作。比如，一个`v-focus`指令可以在元素挂载时自动聚焦该元素，提高用户体验。
* **全局过滤器**：用于对数据进行格式化处理。例如，一个全局过滤器可以将日期格式化为特定的字符串格式，方便在模板中显示日期数据。
* **全局混入**：可以在多个组件之间共享一些通用的选项或方法。例如，一个全局混入可以为多个组件添加相同的生命周期钩子函数或方法，减少重复代码。

2. **扩展 Vue 实例**：

* 插件可以向 Vue 实例添加新的方法或属性，使得在项目中的任何地方都可以通过`this`访问这些方法或属性。例如，一个插件可以添加一个`$http`方法，用于发送 HTTP 请求，方便在组件中进行数据获取。

3. **集成第三方库**：

* 可以将第三方库包装成 Vue 插件，使其与 Vue 更好地集成。例如，将 Vue Router（路由库）和 Vuex（状态管理库）作为插件使用，方便在 Vue 项目中进行路由管理和状态管理。

**三、使用方法**

1. **创建插件**：

* 插件可以是一个对象，包含`install`方法：

```js
const myPlugin = {
  install (Vue) {
  // 在这里添加全局功能或扩展 Vue 实例
    Vue.prototype.$myMethod = function () {
      console.log('This is a custom method added by the plugin.')
    }
  }
}
```

* 也可以是一个函数，接收 Vue 构造函数作为参数：

```js
function myPlugin (Vue) {
  Vue.prototype.$myMethod = function () {
    console.log('This is a custom method added by the plugin.')
  }
}
```

2. **使用插件**：

* 在 Vue 项目中，可以通过`Vue.use()`方法来使用插件。通常在项目的入口文件（如`main.js`）中进行插件的安装。

```js
import Vue from 'vue'
import App from './App.vue'
// 引入插件
import myPlugin from './myPlugin'

Vue.use(myPlugin)

new Vue({
  render: (h) => h(App)
}).$mount('#app')
```

3. **在组件中使用插件提供的功能**：

* 在组件的方法、生命周期钩子函数或模板中，可以通过`this.$myMethod()`来调用插件添加的方法。

```html
<template>
<div @click="callPluginMethod">Click me</div>
</template>
<script>
export default {
methods: {
callPluginMethod() {
this.$myMethod();
},
},
};
</script>
```

通过使用插件，可以将一些通用的功能封装起来，提高代码的可维护性和可复用性，同时也方便在项目中进行功能的扩展和集成第三方库。

## vue 是如何识别和解析指令 {#p0-diretive}

vue 是如何识别和解析指令的， 详细解释一下

Vue.js在识别和解析指令时，使用了编译器（Compiler）来完成这个过程。下面是Vue.js识别和解析指令的详细步骤：

1. 解析模板：首先，Vue.js会将模板代码转换为抽象语法树（AST）。这个过程由Vue.js的编译器完成。编译器会遍历模板代码，将其解析成一棵抽象语法树，该树表示了模板的结构和各个元素之间的关系。

2. 识别指令：在遍历抽象语法树的过程中，编译器会识别出模板中的指令。指令通常以`v-`开头，例如`v-if`、`v-for`、`v-bind`、`v-on`等。编译器会根据指令的名称和位置来确定它们的作用。

3. 提取指令参数和修饰符：对于识别出的指令，编译器会进一步提取指令的参数和修饰符。指令参数通常是指令名称后面的表达式或变量，用于指定指令的具体行为。修饰符是一些额外的标识符，用于修改指令的行为或增加一些特定功能。

4. 解析指令表达式：针对具有表达式的指令，编译器会解析指令表达式并生成对应的代码。指令表达式通常是模板中的变量或计算属性，用于动态地绑定数据到指令上。编译器会将指令表达式转化为可执行的JavaScript代码，以便在运行时进行数据绑定。

5. 生成渲染函数：最后，编译器将解析后的模板和指令转换为渲染函数。渲染函数是一个JavaScript函数，它接收数据作为参数，并返回一个虚拟DOM（VNode）树，用于渲染组件的视图。渲染函数包含了对指令的执行逻辑和对模板变量的处理。

Vue.js通过编译器对模板进行解析，识别和解析指令，并将其转化为渲染函数。这个过程包括解析模板、识别指令、提取参数和修饰符、解析指令表达式，最终生成渲染函数。通过渲染函数，Vue.js能够根据数据的变化动态更新组件的视图。

 上述指令中，例如 v-bind 是如何映射到具体可执行方法的？

在 Vue.js 中，指令的执行是通过渲染函数来实现的。指令对应的可执行方法会在渲染函数中生成，并在组件渲染时执行。下面以`v-bind`指令为例，解释它是如何映射到具体可执行方法的：

1. 解析指令：在编译模板时，Vue.js的编译器会识别到`v-bind`指令。

2. 提取指令参数和修饰符：编译器会进一步提取`v-bind`指令的参数和修饰符。对于`v-bind`，参数通常是要绑定的属性名或表达式，用于将数据绑定到对应的属性上。

3. 解析指令表达式：对于`v-bind`指令，表达式通常是要绑定的数据或计算属性。编译器会解析指令表达式，并生成对应的代码。

4. 生成渲染函数：在生成渲染函数的过程中，编译器会根据解析得到的指令信息生成可执行的JavaScript代码。对于`v-bind`，编译器会在渲染函数中生成一个函数调用，该函数会将指令参数和表达式所代表的值绑定到对应的属性上。

5. 渲染时执行：在组件渲染时，渲染函数会被调用，并执行其中的代码。对于`v-bind`，生成的函数调用会在渲染函数执行时被触发，将绑定的数据或计算属性的值应用到对应的属性上。

在渲染函数执行时，生成的函数调用会被触发，将绑定的数据或计算属性的值应用到对应的属性上。通过这种方式，`v-bind`指令实现了将数据动态绑定到属性上的功能。其他指令的执行原理也类似，通过编译器将指令解析为可执行的代码，并在渲染函数执行时进行相应的操作。

## vue3 相比较于 vue2 在编译阶段有哪些改进 {#p0-vue-compiler}

Vue 3 在编译阶段相对于 Vue 2 进行了一些重要的改进，主要包括以下几个方面：

1. 静态模板提升（Static Template Hoisting）：Vue 3 引入了静态模板提升技术，通过对模板进行分析和优化，将模板编译为更简洁、更高效的渲染函数。这种优化可以减少不必要的运行时开销，并提高组件的渲染性能。

2. Fragments 片段支持：Vue 3 支持使用 Fragments 片段来包裹多个根级元素，而不需要额外的父元素。这样可以避免在编译阶段为每个组件生成额外的包裹元素，减少了虚拟 DOM 树的层级，提高了渲染性能。

3. 静态属性提升（Static Props Hoisting）：Vue 3 在编译阶段对静态属性进行了优化，将静态属性从渲染函数中提取出来，只在组件初始化时计算一次，并在后续的渲染中重用。这样可以减少不必要的属性计算和传递，提高了组件的渲染性能。

4. 事件处理函数的内联化：Vue 3 在编译阶段对事件处理函数进行了内联化，将事件处理函数直接写入模板中，而不是在运行时动态生成。这样可以减少运行时的事件绑定和查找开销，提高了事件处理的性能。

5. 静态节点提升（Static Node Hoisting）：Vue 3 通过静态节点提升技术，将静态的节点在编译阶段进行处理，避免了在每次渲染时对静态节点的比对和更新操作，提高了渲染性能。

6. 缓存事件处理器（Cached Event Handlers）：Vue 3 在编译阶段对事件处理器进行了缓存，避免了重复创建事件处理函数的开销。对于相同的事件处理器，只会创建一次，并在组件的生命周期中重复使用，减少了内存占用和运行时开销。

7. 更细粒度的组件分割（Fine-Grained Component Splitting）：Vue 3 支持更细粒度的组件分割，可以将组件的模板、脚本和样式进行独立的编译和加载，以实现更好的代码拆分和按需加载，提高了应用的加载速度和性能。

这些改进使得 Vue 3 在编译阶段能够生成更优化的代码，减少了不必要的运行时开销，并提高了组件的渲染性能和整体的运行效率。

## 中为何不要把 v-if 和 v-for 同时用在同一个元素上， 原理是什么？ {#p0-v-if-v-for}

确实，将`v-if`和`v-for`同时用在同一个元素上可能会导致性能问题。**原因在于`v-for`具有比`v-if`更高的优先级，它会在每次渲染的时候都会运行**。这意味着，即使在某些情况下`v-if`的条件为`false`，`v-for`仍然会对数据进行遍历和渲染。

这样会导致一些不必要的性能消耗，特别是当数据量较大时。Vue在渲染时会尽量复用已经存在的元素，而不是重新创建和销毁它们。但是当`v-for`遍历的数据项发生变化时，Vue会使用具有相同`key`的元素，此时`v-if`的条件可能会影响到之前的元素，导致一些不符合预期的行为。

让我们来看一个具体的例子来说明这个问题。

假设我们有以下的Vue模板代码：

```html
<ul>
 <li v-for="item in items" v-if="item.isActive">{{ item.name }}</li>
</ul>
```

这里我们使用`v-for`来循环渲染`items`数组，并且使用`v-if`来判断每个数组项是否是活动状态。现在，让我们看一下Vue的源码，特别是与渲染相关的部分。

在Vue的渲染过程中，它会将模板解析为AST（抽象语法树），然后将AST转换为渲染函数。对于上面的模板，渲染函数大致如下：

```js
function render () {
  return _c(
    'ul',
    null,
    _l(items, function (item) {
      return item.isActive ? _c('li', null, _v(_s(item.name))) : _e()
    })
  )
}
```

上面的代码中，`_l`是由`v-for`指令生成的渲染函数。它接收一个数组和一个回调函数，并在每个数组项上调用回调函数。回调函数根据`v-if`条件来决定是否渲染`li`元素。

问题出在这里：由于`v-for`的优先级比`v-if`高，所以每次渲染时都会执行`v-for`循环，无论`v-if`的条件是否为`false`。这意味着即使`item.isActive`为`false`，Vue仍然会对它进行遍历和渲染。

此外，Vue在渲染时会尽量复用已经存在的元素，而不是重新创建和销毁它们。但是当`v-for`遍历的数据项发生变化时，Vue会使用具有相同`key`的元素。在上面的例子中，如果`item.isActive`从`true`变为`false`，Vue会尝试复用之前的`li`元素，并在其上应用`v-if`条件。这可能会导致一些不符合预期的行为。

为了避免这种性能问题，Vue官方推荐在同一个元素上不要同时使用`v-if`和`v-for`。如果需要根据条件来决定是否渲染循环的元素，可以考虑使用计算属性或者`v-for`的过滤器来处理数据。或者，将条件判断放在外层元素上，内层元素使用`v-for`进行循环渲染，以确保每次渲染时都能正确地应用`v-if`条件。

## 你做过哪些性能优化 {#vue-profile}

1、`v-if`和`v-show`

* 频繁切换时使用`v-show`，利用其缓存特性
* 首屏渲染时使用`v-if`，如果为`false`则不进行渲染

2、`v-for`的`key`

* 列表变化时，循环时使用唯一不变的`key`，借助其本地复用策略
* 列表只进行一次渲染时，`key`可以采用循环的`index`

3、侦听器和计算属性

* 侦听器`watch`用于数据变化时引起其他行为
* 多使用`compouter`计算属性顾名思义就是新计算而来的属性，如果依赖的数据未发生变化，不会触发重新计算

4、合理使用生命周期

* 在`destroyed`阶段进行绑定事件或者定时器的销毁
* 使用动态组件的时候通过`keep-alive`包裹进行缓存处理，相关的操作可以在`actived`阶段激活

5、数据响应式处理

* 不需要响应式处理的数据可以通过`Object.freeze`处理，或者直接通过`this.xxx = xxx`的方式进行定义
* 需要响应式处理的属性可以通过`this.$set`的方式处理，而不是`JSON.parse(JSON.stringify(XXX))`的方式

6、路由加载方式

* 页面组件可以采用异步加载的方式

7、插件引入

* 第三方插件可以采用按需加载的方式，比如`element-ui`。

8、减少代码量

* 采用`mixin`的方式抽离公共方法
* 抽离公共组件
* 定义公共方法至公共`js`中
* 抽离公共`css`

9、编译方式

* 如果线上需要`template`的编译，可以采用完成版`vue.esm.js`
* 如果线上无需`template`的编译，可采用运行时版本`vue.runtime.esm.js`，相比完整版体积要小大约`30%`

10、渲染方式

* 服务端渲染，如果是需要`SEO`的网站可以采用服务端渲染的方式
* 前端渲染，一些企业内部使用的后端管理系统可以采用前端渲染的方式

11、字体图标的使用

* 有些图片图标尽可能使用字体图标
