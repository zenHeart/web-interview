
# 杂项

## 如何使用 node 做一个全局命令行工具 {#p2-node-cli}

**一、创建项目结构**

1. 创建一个新的文件夹作为项目目录，例如`my-cli-tool`。
2. 在项目目录中，初始化一个新的 Node.js 项目，可以使用`npm init`或`yarn init`命令，根据提示填写项目的基本信息。

**二、安装必要的模块**

1. 安装`commander`模块，这是一个用于构建命令行界面的流行工具。

* 使用 npm：`npm install commander --save`
* 使用 yarn：`yarn add commander`

**三、编写命令行工具代码**

1. 创建一个主入口文件，例如`index.js`。
2. 在入口文件中，引入`commander`模块并进行配置：

 ```javascript
 const program = require('commander')
 
 program
   .version('1.0.0')
   .description('My awesome CLI tool')
   .option('-n, --name <value>', 'Your name')
   .action((options) => {
     console.log(`Hello, ${options.name || 'World'}!`)
   })
 
 program.parse(process.argv)
 ```

 在这个例子中，我们创建了一个命令行工具，它接受一个`--name`选项，并在执行时打印出问候语。

**四、设置全局安装**

1. 在项目的`package.json`文件中，添加一个`bin`字段，指定命令行工具的入口文件：

 ```json
 {
 "name": "my-cli-tool",
 "version": "1.0.0",
 "description": "My awesome CLI tool",
 "main": "index.js",
 "bin": {
 "my-tool": "./index.js"
 },
 "dependencies": {
 "commander": "^9.4.0"
 }
 }
 ```

 这里将命令行工具的名称设置为`my-tool`，对应的入口文件是`index.js`。

2. 使用`npm link`或`yarn link`命令将项目链接到全局环境中。这将使你的命令行工具在系统中可用。

* 使用 npm：`npm link`
* 使用 yarn：`yarn link`

**五、测试命令行工具**

1. 打开终端，输入`my-tool --name John`，如果一切正常，应该会看到输出`Hello, John!`。

## node 如何处理循环依赖 {#p2-node-circular-dependency}

在前端工程中，可以通过以下方法检测并避免循环依赖：

**一、检测循环依赖**

1. 手动审查代码：

* 仔细检查项目中的模块导入关系。查看每个模块的导入语句，确定是否存在一个模块被另一个模块导入，而后者又反过来导入前者的情况。
* 对于大型项目，可以使用工具辅助手动审查，如代码编辑器的搜索功能或一些专门的代码分析工具，来快速查找可能的循环依赖。

2. 使用静态分析工具：

* 有一些静态分析工具可以帮助检测循环依赖。例如，ESLint 的插件`eslint-plugin-import`可以配置规则来检测模块之间的循环依赖。
* 使用这些工具可以在开发过程中自动检测循环依赖，并给出明确的错误提示，帮助开发者及时发现和修复问题。

**二、避免循环依赖**

1. 优化模块设计：

* 重新审视项目的模块结构，确保模块之间的依赖关系清晰且单向。避免设计出相互依赖的模块结构。
* 例如，如果模块 A 和模块 B 相互依赖，可以考虑将它们共同依赖的部分提取出来，创建一个新的模块 C，然后让 A 和 B 分别依赖于 C，而不是直接相互依赖。

2. 采用依赖注入：

* 依赖注入是一种设计模式，可以帮助减少模块之间的直接依赖。通过将依赖项作为参数传递给函数或构造函数，可以在运行时动态地注入依赖项，而不是在模块内部直接导入它们。
* 这样可以降低模块之间的耦合度，减少循环依赖的可能性。

3. 延迟加载：

* 在某些情况下，可以使用延迟加载（lazy loading）来避免循环依赖。延迟加载是指在实际需要的时候才加载模块，而不是在应用程序启动时就加载所有模块。
* 例如，可以使用动态导入（dynamic import）来实现延迟加载。这样可以避免在模块加载时立即出现循环依赖的问题，因为模块只有在需要的时候才会被加载。

4. 建立清晰的模块边界：

* 每个模块应该有明确的职责和功能范围。避免模块之间的职责重叠，这样可以减少模块之间的相互依赖。
* 同时，尽量保持模块的独立性，使得模块可以独立开发、测试和维护。
