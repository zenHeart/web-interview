# npm

## package.json 依赖申明的方式有哪些， 他们有何却别 {#p2-package-json-dependencies}

**一、`dependencies`（生产依赖）**

1. **定义和用途**：

* `dependencies`用于声明项目在生产环境中运行所必需的依赖项。
* 这些依赖项是项目正常运行所不可或缺的，无论是在开发阶段还是在部署到生产环境后。

2. **示例**：

* 比如，如果你的项目使用了 Express.js 框架来构建服务器，那么 Express.js 就应该被声明在`dependencies`中。
* `"express": "^4.17.1"`表示安装 Express 版本 4.17.1 或更高的兼容版本。

3. **安装和使用**：

* 当你运行`npm install`或`yarn install`时，这些依赖项会被自动安装到项目的`node_modules`目录中。
* 在生产环境中部署项目时，这些依赖项也会被一同部署。

**二、`devDependencies`（开发依赖）**

1. **定义和用途**：

* `devDependencies`用于声明仅在开发过程中需要的依赖项。
* 这些依赖项通常包括开发工具、测试框架、代码格式化工具等，它们不是项目在生产环境中运行所必需的。

2. **示例**：

* 例如，Jest 是一个流行的 JavaScript 测试框架，如果你的项目使用 Jest 进行测试，那么 Jest 应该被声明在`devDependencies`中。
* `"jest": "^26.6.3"`表示安装 Jest 版本 26.6.3 或更高的兼容版本。

3. **安装和使用**：

* 同样，当你运行`npm install`或`yarn install`时，这些依赖项会被安装到项目的`node_modules`目录中。
* 但是，在生产环境中部署项目时，通常不会部署这些开发依赖项，以减小项目的体积和复杂性。

**区别总结**：

1. **使用场景不同**：

* `dependencies`中的依赖项是项目在生产环境中运行所必需的，而`devDependencies`中的依赖项仅在开发过程中使用。

2. **部署方式不同**：

* 生产环境部署时，通常只部署`dependencies`中的依赖项，而不部署`devDependencies`中的依赖项。

3. **影响项目体积和复杂性**：

* 将不必要的依赖项放在`devDependencies`中可以减小项目在生产环境中的体积和复杂性，提高性能和安全性。

**三、`peerDependencies`（对等依赖）**

1. **定义和用途**：

* `peerDependencies` 用于声明当前包所依赖的其他包，但这些依赖项不会被自动安装。
* 它通常用于插件或扩展的场景，表明当前包与特定版本的其他包兼容，并且期望宿主环境已经安装了这些对等依赖。

2. **示例**：

* 假设你正在开发一个 React 插件，你的插件可能需要特定版本的 React 才能正常工作。在这种情况下，你可以在 `package.json` 的 `peerDependencies` 中声明对 React 的依赖。
* `"peerDependencies": { "react": "^17.0.2" }` 表示这个插件期望宿主环境安装了 React 17.0.2 或更高的兼容版本。

3. **安装和使用**：

* 当用户安装你的包时，他们需要确保在自己的项目中手动安装了满足 `peerDependencies` 要求的包。如果没有安装或版本不匹配，可能会导致运行时错误。

**区别总结**：

* **与 `dependencies` 的区别**：
* `dependencies` 中的依赖项会在安装当前包时自动安装，而 `peerDependencies` 中的依赖项不会自动安装，需要用户在宿主项目中自行安装。
* **与 `devDependencies` 的区别**：
* `devDependencies` 是仅在开发过程中使用的依赖项，而 `peerDependencies` 是与当前包在运行时的兼容性相关的依赖项，不一定只在开发过程中使用。

## package.json 里面，表示导出包内容的配置有哪些 {#p1-package-json-export-config}

**一、`main`字段**

1. 作用：

* 指定当你的包被引入时，模块系统应该加载的主要入口文件。
* 对于 CommonJS 和 ES6 模块系统，这个文件将作为默认的入口点。

2. 示例：

* `"main": "dist/index.js"`表示当你的包被引入时，会加载`dist`目录下的`index.js`文件作为主要入口。

**二、`module`字段**

1. 作用：

* 专门为 ES6 模块系统指定入口文件。
* 一些现代的构建工具和环境（如 Webpack、Rollup 等）会优先使用这个字段来确定 ES6 模块的入口点。

2. 示例：

* `"module": "esm/index.js"`表示对于支持 ES6 模块的环境，会加载`esm`目录下的`index.js`文件。

**三、`exports`字段（在 Node.js 12+ 和一些现代构建工具中支持）**

1. 作用：

* 提供了一种更灵活的方式来指定包的不同入口点，可以根据不同的模块系统和环境来导出不同的文件。
* 可以同时为 CommonJS、ES6 模块、不同的子路径等指定特定的入口文件。

2. 示例：

```json

 "exports": {
 ".": {
 "import": "./esm/index.js",
 "require": "./cjs/index.js"
 },
 "./submodule": {
 "import": "./esm/submodule.js",
 "require": "./cjs/submodule.js"
 }
 }
 ```

* 在这个例子中，对于根路径（`.`），如果是 ES6 模块环境，会加载`./esm/index.js`；如果是 CommonJS 环境，会加载`./cjs/index.js`。对于`./submodule`子路径，也分别指定了不同模块系统的入口文件。

这些配置允许你控制包的导出内容和入口点，以便其他开发者能够正确地引入和使用你的包。根据你的项目结构和目标环境，可以选择合适的配置来确保包的可维护性和兼容性。

## 说一下你对 npm hook 的理解 {#p2-npm-hook}

## npm workspaces 是什么概念， 主要是解决什么问题 {#p2-npm-workspaces}

**一、项目结构管理**

1. **多包项目组织**：

* 在大型项目中，可能包含多个独立的软件包或模块。`npm workspaces`允许将这些包组织在一个统一的项目结构中，方便管理和开发。
* 例如，一个企业级应用可能由一个前端库、一个后端服务和一个共享的工具包组成。使用`npm workspaces`，可以将这些包放在同一个项目目录下，而不是作为独立的项目进行管理。

2. **依赖共享**：

* 多个包之间可能存在共享的依赖项。`npm workspaces`可以自动管理这些共享依赖，避免重复安装和版本冲突。
* 当一个包安装了某个依赖项时，其他包可以直接使用这个依赖，而不需要再次安装。这可以减少项目的体积和安装时间，提高开发效率。

**二、开发效率提升**

1. **单一命令行界面**：

* 使用`npm workspaces`，可以在项目的根目录下使用单一的`npm`命令来管理所有的包。这避免了在每个包的目录下分别运行`npm`命令的繁琐过程。
* 例如，可以在根目录下运行`npm install`来安装所有包的依赖项，或者运行`npm run test`来执行所有包的测试。

2. **同时开发多个包**：

* 开发人员可以在同一个项目中同时开发多个包，而不需要在不同的项目目录之间切换。这可以提高开发效率，特别是在需要频繁修改多个包的情况下。
* 例如，可以在一个编辑器中打开多个包的代码，进行同时编辑和调试。

**三、版本管理和发布**

1. **统一版本控制**：

* 在多包项目中，需要确保各个包的版本保持一致。`npm workspaces`可以帮助管理包的版本，确保在发布时所有的包都使用相同的版本号。
* 可以在项目的根目录下使用`npm version`命令来统一更新所有包的版本号，并生成相应的版本标签。

2. **简化发布流程**：

* 发布多个包时，通常需要分别在每个包的目录下执行发布命令。使用`npm workspaces`，可以在项目的根目录下使用单一的发布命令来发布所有的包。
* 例如，可以使用`npm publish --workspaces`来发布项目中的所有包，而不需要分别进入每个包的目录进行发布。

## pnpm install 和 npm install 有何区别 {#p2-pnpm-install-vs-npm-install}

`pnpm install` 和 `npm install` 都是用于安装 JavaScript 项目依赖的命令，但它们背后的包管理器（分别是 `pnpm` 和 `npm`）在处理依赖安装、存储和优化方面有一些关键区别。

 1. **存储方式的区别**

* **npm**：在每个项目的 `node_modules` 文件夹中分别存储其依赖。这意味着如果你有多个项目，它们共享相同的依赖库，这些依赖库的多个副本将在你的文件系统中的每个项目内分别存储。这样做会占用更多的磁盘空间。

* **pnpm**：采用一种称为**内容寻址文件系统**的方式来存储依赖。所有项目的依赖被存储在一个共享的位置，各个项目中的 `node_modules` 目录通过硬链接（hard links）或符号链接（symlinks）指向这个共享位置。该方法有效地减少了磁盘空间的占用，并加快了依赖的安装速度。

 2. **性能与速度**

* **pnpm**：由于对依赖进行了有效的复用，并且使用硬链接来减少磁盘上的副本数量，通常可以提供比 `npm` 更快的安装速度。

* **npm**：近几个大版本中也进行了许多性能改进，但在多个项目中共享相同依赖时，它可能仍然比 `pnpm` 更慢，尤其是在首次安装依赖时。

 3. **依赖平面结构 vs. 嵌套结构**

* **npm**：自版本 3 以后，默认创建扁平的 `node_modules` 结构（尽可能），这样做是为了避免 Windows 系统中路径过长的问题。但在必要时， `npm` 仍然会创建嵌套的 `node_modules` 目录结构，以解决依赖冲突。

* **pnpm**：通过使用符号链接，`pnpm` 维护了一个严格的嵌套依赖结构，更接近每个包的 `package.json` 文件所声明的依赖树形态。这提供了更高的一致性和在某些情况下更好的包隔离性。

 4. **依赖隔离与安全性**

* **pnpm**：更好地隔离了依赖，每个包只能访问其在 `package.json` 中声明的依赖。这一特性增强了项目的安全性，因为它阻止了未声明的依赖被意外引入的情况。

* **npm**：虽然 `npm` 也遵循 `package.json` 中的声明，但其扁平化的 `node_modules` 结构有时可能会容易地让包访问到未明确声明的依赖。

 5. **命令行界面（CLI）和配置**

* 这两个工具的命令行界面（CLI）和配置都非常直观且类似，但它们的某些命令和选项可能会有细微差别。`pnpm` 为了优化性能和安全性引入了一些特有的命令和配置选项。

总的来说，`pnpm` 在多项目管理、磁盘空间和安装速度方面提供了优于 `npm` 的性能和利益。对于新项目或在寻求性能优化的既存项目，考虑试用 `pnpm` 可能是个不错的选择。

## monorepo 工程有哪些工具架构， 该如何选型 {#p3-monorepo-工程有哪些工具架构-该如何选型}

 工具推荐

| 工具 | **Turborepo** | **Rush** | **Nx** | **Lerna** | **Pnpm Workspace** |
| -------- | ------------- | -------- | ------ | --------- | ------------------ |
| 依赖管理 | ❌ | ✅ | ❌ | ❌ | ✅ |
| 版本管理 | ❌ | ✅ | ❌ | ✅ | ❌ |
| 增量构建 | ✅ | ✅ | ✅ | ❌ | ❌ |
| 插件扩展 | ✅ | ✅ | ✅ | ❌ | ❌ |
| 云端缓存 | ✅ | ✅ | ✅ | ❌ | ❌ |
| Stars | 20.4K | 4.9K | 17K | 34.3K | 22.7K |

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d85551b9ce50496d8403956b571c4635~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=2610&h=1020&s=64366&e=webp&b=fdfdfd)

 工具选型

选择合适的 Monorepo 管理工具对于确保项目的顺利进行是至关重要的。Monorepo 管理工具可以帮助你高效地管理项目依赖、统一代码风格、简化开发流程等。在进行 Monorepo 工具选型时，需要考虑几个重要的因素：

 1. **技术栈的兼容性**

* **Lerna**：与任何技术栈兼容性都很好，特别是与前端项目协同工作时。它对 NPM 和 Yarn 都有良好支持，适用于需要独立版本管理或频繁发布的项目。
* **Yarn Workspaces**：特别适合使用 Yarn 作为包管理器的 JavaScript 或 TypeScript 项目。它非常适合团队中包之间有很多交叉依赖的情形。
* **Nx**：支持多种前端和后端框架，如 Angular、React、NestJS 等。如果项目采用多技术栈，Nx 提供了一套完整的解决方案，包含了构建、测试和 linting 等一站式服务。
* **Rush**：同样适用于大型项目，兼容任何 NPM 包管理器，如 NPM、Yarn、pnpm。Rush 提供了灵活的版本控制策略，非常适合需要精细控制包版本策略的场景。
* **pnpm Workspaces**：具有高效的节点模块解析机制，非常注重节省磁盘空间及速度优化。如果磁盘空间和安装速度是关键考虑因素，pnpm 会是一个不错的选择。

 2. **项目的规模和复杂度**

* 对于大型或复杂项目，**Nx** 和 **Rush** 提供了更多的高级特性，比如增量构建、依赖图可视化等，可以有效提升大团队的开发效率。
* 对于中小型项目，**Lerna**、**Yarn Workspaces** 或 **pnpm Workspaces** 可能更易上手，配置和管理也较为简单。

 3. **构建、测试和部署的需求**

* 如果项目需要复杂的构建、测试流程，**Nx** 提供了一些很好的工具来优化这一过程。Nx 可以智能地只重新构建受影响的项目，节省 CI/CD 的时间和资源。
* **Rush** 强调在大型仓库中提供稳定而灵活的版本策略和发布管理，对于需要精细控制不同环境部署的项目非常有用。

 4. **团队协作和代码共享的便利性**

* 所有这些工具都支持代码共享和重用，但是**Nx** 和 **Rush** 在支持大型团队和多项目协作方面有一些额外的优势，如更智能的依赖管理和版本控制。

 5. **社区支持和文档**

* **Nx** 拥有强大的社区支持和丰富的文档、教程，非常适合于新技术栈的团队。
* **Lerna** 和 **Yarn Workspaces** 受众广泛，网上有很多资源和案例，学习曲线相对平缓。

 推荐策略

如果你的项目非常关注于构建效率和对多种技术栈的支持，**Nx** 是非常好的选择。如果你更关心包的独立发布和版本管理，**Lerna** 和 **Rush** 可以满足你的需求。而对于那些偏好 Yarn 并且注重依赖管理的项目来说，**Yarn Workspaces** 提供了一套简单直接的解决方案。如果磁盘空间和安装速度是你的主要考虑，不妨试试 **pnpm Workspaces**。
