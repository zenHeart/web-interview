# npm

## package.json 依赖申明的方式有哪些， 他们有何却别 {#p2-package-json-dependencies}

**一、`dependencies`（生产依赖）**

1. **定义和用途**：

* `dependencies`用于声明项目在生产环境中运行所必需的依赖项。
* 这些依赖项是项目正常运行所不可或缺的，无论是在开发阶段还是在部署到生产环境后。

2. **示例**：

* 比如，如果你的项目使用了 Express.js 框架来构建服务器，那么 Express.js 就应该被声明在`dependencies`中。
* `"express": "^4.17.1"`表示安装 Express 版本 4.17.1 或更高的兼容版本。

3. **安装和使用**：

* 当你运行`npm install`或`yarn install`时，这些依赖项会被自动安装到项目的`node_modules`目录中。
* 在生产环境中部署项目时，这些依赖项也会被一同部署。

**二、`devDependencies`（开发依赖）**

1. **定义和用途**：

* `devDependencies`用于声明仅在开发过程中需要的依赖项。
* 这些依赖项通常包括开发工具、测试框架、代码格式化工具等，它们不是项目在生产环境中运行所必需的。

2. **示例**：

* 例如，Jest 是一个流行的 JavaScript 测试框架，如果你的项目使用 Jest 进行测试，那么 Jest 应该被声明在`devDependencies`中。
* `"jest": "^26.6.3"`表示安装 Jest 版本 26.6.3 或更高的兼容版本。

3. **安装和使用**：

* 同样，当你运行`npm install`或`yarn install`时，这些依赖项会被安装到项目的`node_modules`目录中。
* 但是，在生产环境中部署项目时，通常不会部署这些开发依赖项，以减小项目的体积和复杂性。

**区别总结**：

1. **使用场景不同**：

* `dependencies`中的依赖项是项目在生产环境中运行所必需的，而`devDependencies`中的依赖项仅在开发过程中使用。

2. **部署方式不同**：

* 生产环境部署时，通常只部署`dependencies`中的依赖项，而不部署`devDependencies`中的依赖项。

3. **影响项目体积和复杂性**：

* 将不必要的依赖项放在`devDependencies`中可以减小项目在生产环境中的体积和复杂性，提高性能和安全性。

**三、`peerDependencies`（对等依赖）**

1. **定义和用途**：

* `peerDependencies` 用于声明当前包所依赖的其他包，但这些依赖项不会被自动安装。
* 它通常用于插件或扩展的场景，表明当前包与特定版本的其他包兼容，并且期望宿主环境已经安装了这些对等依赖。

2. **示例**：

* 假设你正在开发一个 React 插件，你的插件可能需要特定版本的 React 才能正常工作。在这种情况下，你可以在 `package.json` 的 `peerDependencies` 中声明对 React 的依赖。
* `"peerDependencies": { "react": "^17.0.2" }` 表示这个插件期望宿主环境安装了 React 17.0.2 或更高的兼容版本。

3. **安装和使用**：

* 当用户安装你的包时，他们需要确保在自己的项目中手动安装了满足 `peerDependencies` 要求的包。如果没有安装或版本不匹配，可能会导致运行时错误。

**区别总结**：

* **与 `dependencies` 的区别**：
* `dependencies` 中的依赖项会在安装当前包时自动安装，而 `peerDependencies` 中的依赖项不会自动安装，需要用户在宿主项目中自行安装。
* **与 `devDependencies` 的区别**：
* `devDependencies` 是仅在开发过程中使用的依赖项，而 `peerDependencies` 是与当前包在运行时的兼容性相关的依赖项，不一定只在开发过程中使用。

## package.json 里面，表示导出包内容的配置有哪些 {#p1-package-json-export-config}

**一、`main`字段**

1. 作用：

* 指定当你的包被引入时，模块系统应该加载的主要入口文件。
* 对于 CommonJS 和 ES6 模块系统，这个文件将作为默认的入口点。

2. 示例：

* `"main": "dist/index.js"`表示当你的包被引入时，会加载`dist`目录下的`index.js`文件作为主要入口。

**二、`module`字段**

1. 作用：

* 专门为 ES6 模块系统指定入口文件。
* 一些现代的构建工具和环境（如 Webpack、Rollup 等）会优先使用这个字段来确定 ES6 模块的入口点。

2. 示例：

* `"module": "esm/index.js"`表示对于支持 ES6 模块的环境，会加载`esm`目录下的`index.js`文件。

**三、`exports`字段（在 Node.js 12+ 和一些现代构建工具中支持）**

1. 作用：

* 提供了一种更灵活的方式来指定包的不同入口点，可以根据不同的模块系统和环境来导出不同的文件。
* 可以同时为 CommonJS、ES6 模块、不同的子路径等指定特定的入口文件。

2. 示例：

```json

 "exports": {
 ".": {
 "import": "./esm/index.js",
 "require": "./cjs/index.js"
 },
 "./submodule": {
 "import": "./esm/submodule.js",
 "require": "./cjs/submodule.js"
 }
 }
 ```

* 在这个例子中，对于根路径（`.`），如果是 ES6 模块环境，会加载`./esm/index.js`；如果是 CommonJS 环境，会加载`./cjs/index.js`。对于`./submodule`子路径，也分别指定了不同模块系统的入口文件。

这些配置允许你控制包的导出内容和入口点，以便其他开发者能够正确地引入和使用你的包。根据你的项目结构和目标环境，可以选择合适的配置来确保包的可维护性和兼容性。

## 说一下你对 npm hook 的理解 {#p2-npm-hook}

## npm workspaces 是什么概念， 主要是解决什么问题 {#p2-npm-workspaces}

**一、项目结构管理**

1. **多包项目组织**：

* 在大型项目中，可能包含多个独立的软件包或模块。`npm workspaces`允许将这些包组织在一个统一的项目结构中，方便管理和开发。
* 例如，一个企业级应用可能由一个前端库、一个后端服务和一个共享的工具包组成。使用`npm workspaces`，可以将这些包放在同一个项目目录下，而不是作为独立的项目进行管理。

2. **依赖共享**：

* 多个包之间可能存在共享的依赖项。`npm workspaces`可以自动管理这些共享依赖，避免重复安装和版本冲突。
* 当一个包安装了某个依赖项时，其他包可以直接使用这个依赖，而不需要再次安装。这可以减少项目的体积和安装时间，提高开发效率。

**二、开发效率提升**

1. **单一命令行界面**：

* 使用`npm workspaces`，可以在项目的根目录下使用单一的`npm`命令来管理所有的包。这避免了在每个包的目录下分别运行`npm`命令的繁琐过程。
* 例如，可以在根目录下运行`npm install`来安装所有包的依赖项，或者运行`npm run test`来执行所有包的测试。

2. **同时开发多个包**：

* 开发人员可以在同一个项目中同时开发多个包，而不需要在不同的项目目录之间切换。这可以提高开发效率，特别是在需要频繁修改多个包的情况下。
* 例如，可以在一个编辑器中打开多个包的代码，进行同时编辑和调试。

**三、版本管理和发布**

1. **统一版本控制**：

* 在多包项目中，需要确保各个包的版本保持一致。`npm workspaces`可以帮助管理包的版本，确保在发布时所有的包都使用相同的版本号。
* 可以在项目的根目录下使用`npm version`命令来统一更新所有包的版本号，并生成相应的版本标签。

2. **简化发布流程**：

* 发布多个包时，通常需要分别在每个包的目录下执行发布命令。使用`npm workspaces`，可以在项目的根目录下使用单一的发布命令来发布所有的包。
* 例如，可以使用`npm publish --workspaces`来发布项目中的所有包，而不需要分别进入每个包的目录进行发布。
