# 调试能力

## 如果用户说 web 应用感觉很反应慢或者卡顿，该如何排查？ {#p0-debug-jank-slow}

 如果用户觉得 web 应用反应卡顿， 主要从哪几个方面来排查？

* 加载慢
* 资源下载慢
* 首屏并发请求资源过多
* 首屏接口慢
* 首屏对应的 JS 执行慢
* 首屏渲染慢
* 首屏加载静态资源过大
* .......
* 执行过程慢
* 接口慢
* long tasks 太多, 阻塞 JS 执行
* 内存泄漏
* 重绘重排 过多
* 关键节点没有加 节流防抖
* .......

 主要排查手段有哪些

* **通过建立性能监控指标**: 通过真实用户数据反馈， 来判断用户是否卡顿， 包含网络监控、运行时性能监控

* **Chrome devtools: NetWork** 主要排查网络问题
*

 <img width="1469" alt="image" src="https://user-images.githubusercontent.com/22188674/229800903-409009dd-105a-49e2-a7c4-4ed54c92210e.png"/>

* **Chrome devtools: Performance** 主要细查性能运行时性能，包含了 long tasks、render 次数、重排重绘、执行时间线、阻塞场景

<img width="973" alt="image" src="https://user-images.githubusercontent.com/22188674/229800739-3b8099bb-1aca-423a-a2d7-12c151becd47.png"/>
* **Chrome devtools: Performance monitor** 主要监控用户运行时性能，看看是否有内存泄露
  
 <img width="597" alt="image" src="https://user-images.githubusercontent.com/22188674/229800314-4d1ae73a-50a2-47b0-bbf4-57d5ece7d4b7.png"/>

* **React Developer Tools**: 可以用于追踪 react 应用性能、渲染次数、重排重绘
![image](https://user-images.githubusercontent.com/22188674/229801498-3cc4fc25-64a5-4b9e-ace8-5ed7b96e4ac2.png)

* **Lighthouse**: 全面分析网页性能的一个工具、支持浏览器插件
![image](https://user-images.githubusercontent.com/22188674/229803209-505d01da-d780-4a3e-abe7-e56cd942a64b.png)

* **webpack-bundle-analyzer**: 进行产物依赖分析、包大小分析

* **抓包**: 通过抓包的方式， 看看线上请求分析、请求模拟、网络劫持之后仅仅看 JS 执行时间

* **E2E测试**: 通过 E2E 进行性能预检， 每次上线前进行一系列系统操作， 看看时间耗时和线上耗时波动

 主要解决办法和思路

**首屏加载慢的方向**

* 资源加载方向
* 使用 `tree shaking` 减少包体积
* 代码压缩和混淆
* 对于高版本浏览器， 直接使用 ES6 语法，低版本浏览器再使用 ES5（es6 语法代码量会比编译成 es5 代码量小很多， 且执行速度也快）
* 使用 `split chunks` 进行大包拆分、小包复用
* 使用 `gzip`
* 使用 图片压缩
* 使用 雪碧图
* 图标使用 `iconfont` 加载
* 懒加载， 仅加载首屏必要资源
* 使用 `tailwindcss` 等技术， 复用 css
* 使用 `微前端` 技术，首屏仅加载当前子应用页面，可以做到只加载整站很少的一部分代码
* 首屏非必要依赖尽量延后到 FMP 或者 TTI 之后再加载
* 组件微前端化

* 渲染方向
* 尽量减少重排重绘
* 减少重复渲染（useMemo、useCallback、memo 等）
* 减少 setState 次数（多次 setState 可以合并为一次）
* 尽量减少 dom 节点深度

* 网络方向
* 使用流式服务端渲染， 可以查看文档：[资料](https://juejin.cn/post/6953819275941380109)
* 使用服务端渲染， 减少首屏请求
* 使用 SSG 静态站点生成
* 首屏必要数据， 不作客户端请求， 用后端模板注入
* 使用 BFF 进行请求聚合
* 使用 CDN 进行网络请求分发
* DNS Prefetch
* 资源预加载（在闲暇时间加载后续页面所需要的资源和接口，例如：link rel preload）
* 启用 HTTP2 多路复用
* 在业务逻辑上， 首屏必要接口提前（例如在 html 加载的那一瞬间，利用一个非常小的 js 文件将首屏需要的请求发送出去, 然后缓存下来， 到业务使用的时候直接就使用即可）
* 使用缓存技术缓存资源与请求：强缓存、协商缓存、离线缓存、Service Worker 缓存、后端业务缓存

**运行时卡顿方向**

* 查看是否存在有有 `long tasks`， 有计划的拆解 `long tasks`
* 解决项目中复杂度问题： [资料](https://www.jianshu.com/p/ffbb25380904)
* 排查项目是否有内存泄露
* 排查特定业务流程是否有慢接口
* 高复杂计算逻辑放在 service worker 处理

 参考文档

* [资料](https://juejin.cn/post/7096144248713510943)

* [资料](https://juejin.cn/post/6882936217609732110)
* [资料](https://juejin.cn/post/7119074496610304031)
* [资料](https://juejin.cn/post/7159807927908302884)

## 如何定位一个偶现的问题？

第一时间看看有没有较好的现场日志和数据能帮助定位问题
给到相应的设备信息和时间，能否根据描述的现象找到相应的日志定位，反向 push
自己尝试定位复现，找到合适的日志，如果多次操作仍不能马上复现，评估是否要挂起，看问题的出现概率和严重程度
如果是体验相关问题，最终判断概率极低，那么灰度期间，持续观察数据，线上进行监控

## 如何禁止别人调试自己的前端页面代码? {#p4-debug}

* 前端页面防止调试的方法主要是通过不断 `debugger` 来疯狂输出断点，因为 `debugger` 在控制台被打开的时候就会执行
* 由于程序被 `debugger` 阻止，所以无法进行断点调试，所以网页的请求也是看不到的
* 基础代码如下：

```javascript
/**
* 基础禁止调试代码
*/
(() => {
  function ban () {
    setInterval(() => {
      // eslint-disable-next-line
      debugger
    }, 50)
  }
  try {
    ban()
  } catch (err) { }
})()
```

**无限 debugger 的对策**

* 如果仅仅是加上面那么简单的代码，对于一些技术人员而言作用不大
* 可以通过控制台中的 `Deactivate breakpoints` 按钮或者使用快捷键 `Ctrl + F8` 关闭无限 `debugger`
* 这种方式虽然能去掉碍眼的 `debugger`，但是无法通过左侧的行号添加 `breakpoint`

**禁止断点的对策**

* 如果将 `setInterval` 中的代码写在一行，就能禁止用户断点，即使添加 `logpoint` 为 `false` 也无用
* 当然即使有些人想到用左下角的格式化代码，将其变成多行也是没用的

```javascript
(() => {
  function ban () {
    setInterval(() => {
      // debugger
    }, 50)
  }
  try {
    ban()
  } catch (err) { }
})()
```

**忽略执行的代码**

* 通过添加 `add script ignore list` 需要忽略执行代码行或文件
* 也可以达到禁止无限 `debugger`

**忽略执行代码的对策**

* 那如何针对上面操作的恶意用户呢
* 可以通过将 `debugger`改写成 `Function("debugger")();` 的形式来应对
* `Function` 构造器生成的 `debugger` 会在每一次执行时开启一个临时 `js` 文件
* 当然使用的时候，为了更加的安全，最好使用加密后的脚本

```javascript
// 加密前
(() => {
  function ban () {
    setInterval(() => {
      // eslint-disable-next-line
      Function('debugger')()
    }, 50)
  }
  try {
    ban()
  } catch (err) { }
})()

// 加密后
// eslint-disable-next-line
eval(function (c, g, a, b, d, e) { d = String; if (!''.replace(/^/, String)) { for (;a--;)e[a] = b[a] || a; b = [function (f) { return e[f] }]; d = function () { return '\w+' }; a = 1 } for (;a--;)b[a] && (c = c.replace(new RegExp('\b' + d(a) + '\b', 'g'), b[a])); return c }('(()=>{1 0(){2(()=>{3("4")()},5)}6{0()}7(8){}})();', 9, 9, 'block function setInterval Function debugger 50 try catch err'.split(' '), 0, {}))
```

**终极增强防调试代码**

* 为了让自己写出来的代码更加的晦涩难懂，需要对上面的代码再优化一下
* 将 `Function('debugger').call()`改成 `(function(){return false;})['constructor']('debugger')['call']();`
* 并且添加条件，当窗口外部宽高和内部宽高的差值大于一定的值 ，我把 `body` 里的内容换成指定内容
* 当然使用的时候，为了更加的安全，最好加密后再使用

```javascript
(() => {
  function block () {
    if (window.outerHeight - window.innerHeight > 200 || window.outerWidth - window.innerWidth > 200) {
      document.body.innerHTML = '检测到非法调试,请关闭后刷新重试!'
    }
    setInterval(() => {
      (function () {
        return false
      }
        .constructor('debugger')
        .call())
    }, 50)
  }
  try {
    block()
  } catch (err) { }
})()
```

**参考文档**

* [资料](https://juejin.cn/post/7262175454714626108)

## 用户访问页面白屏了， 原因是啥， 如何排查？ {#debug-white}

用户访问页面白屏可能由多种原因引起，以下是一些可能的原因和排查步骤：

1. 网络问题：用户的网络连接可能存在问题，无法正确加载页面内容。可以要求用户检查网络连接，或者自己尝试在不同网络环境下测试页面的加载情况。

2. 服务端问题：服务器未正确响应用户请求，导致页面无法加载。可以检查服务器的状态、日志和错误信息，查看是否有任何异常。同时，可以确认服务器上的相关服务是否正常运行。

3. 前端代码问题：页面的前端代码可能存在错误或异常，导致页面无法正常渲染。可以检查浏览器的开发者工具，查看是否有任何错误信息或警告。同时，可以尝试将页面的JavaScript、CSS和HTML代码分离出来进行单独测试，以确定具体的问题所在。

4. 浏览器兼容性问题：不同浏览器对于某些代码的支持可能不一致，导致页面在某些浏览器中无法正常加载。可以尝试在不同浏览器中测试页面的加载情况，同时使用浏览器的开发者工具检查是否有任何错误或警告。

5. 第三方资源加载问题：页面可能依赖于某些第三方资源（如外部脚本、样式表等），如果这些资源无法加载，可能导致页面白屏。可以检查网络请求是否正常，是否有任何资源加载失败的情况。

6. 缓存问题：浏览器可能在缓存中保存了旧版本的页面或资源，导致新版本无法加载。可以尝试清除浏览器缓存，或者通过添加随机参数或修改文件名的方式强制浏览器重新加载页面和资源。

7. 其他可能原因：页面白屏问题还可能由于安全策略（如CSP、CORS等）限制、跨域问题、DNS解析问题等引起。可以使用浏览器的开发者工具检查网络请求和错误信息，查找可能的问题。

在排查问题时，可以根据具体情况逐步进行排查，并结合浏览器的开发者工具、服务器日志等工具来辅助定位问题所在，并且可以与用户进行进一步沟通以获取更多信息。如果问题无法解决，可以寻求专业的技术支持或咨询。

## jank {#p0-debug-jank}

排查网页卡顿问题时，可以按照以下步骤进行处理：

1. 验证用户反馈：首先，确认用户反馈的卡顿问题是否普遍存在，还是个别用户的特殊情况。可以与其他用户进行沟通或观察其他设备上的表现。

2. 检查网络连接：检查用户的网络连接是否稳定。卡顿问题可能由于网络延迟或不稳定导致。可以要求用户进行网络速度测试，或者与用户确认网络连接是否正常。

3. 检查服务器性能：确认服务器是否能够处理用户的请求。可以检查服务器的负载情况、处理请求的时间以及资源使用情况。如果服务器负载过高，可能导致网页卡顿。

4. 检查前端代码：检查网页的前端代码是否存在问题。主要看是否有内存泄露、long task 等情况；
关于内存泄露和 long task 可以看下面两个文档：

* [JS 内存泄露问题该如何排查？](https://github.com/pro-collection/interview-question/issues/76)

* [Long Tasks 了解多少？](https://github.com/pro-collection/interview-question/issues/255)

5. 优化网页性能：对于前端代码存在性能问题的情况，可以尝试优化网页性能。例如，压缩和合并CSS和JavaScript文件、减少网络请求次数、使用缓存等方法来提高页面加载速度。
可以参考下面文档文档：

* [从哪些方面可以对网站性能优化？](https://github.com/pro-collection/interview-question/issues/89)

6. 做好性能监控：持续监测网页的性能，并定期更新网页的代码和设计，以提升用户体验。

* [`[性能]` 衡量页面性能的指标有哪些？](https://github.com/pro-collection/interview-question/issues/515)

## source map  {#p0-source-map}

 Source Map（源映射）作用

Source Map（源映射）是一种文件，用于将压缩、混淆或编译后的代码映射回原始的源代码，以便在调试过程中能够直接查看和调试源代码。它提供了压缩文件和源文件之间的映射关系，包括每个压缩文件中的代码位置、原始文件的路径和行号等信息。

Source Map的主要作用如下：

1. 调试：在开发过程中，源代码经常会被压缩、合并或转换为其他形式的代码，这使得在调试时直接查看和调试源代码变得困难。Source Map提供了一种方式，通过将压缩代码映射回源代码，开发者可以在调试器中直接查看和调试原始的、易于理解的源代码。

2. 错误追踪：当发生错误或异常时，浏览器或运行环境会提供错误信息，其中包含了压缩后的代码行号和列号。Source Map可以将这些行号和列号映射回源代码的行号和列号，帮助开发者定位和追踪错误。

3. 性能分析：Source Map可以提供压缩文件中每个代码片段对应的原始文件位置信息，这对于性能分析工具来说非常有用。性能分析工具可以使用Source Map来将性能数据映射回源代码，以便更准确地分析和优化代码性能。

Source Map的原理是通过在压缩文件中添加特定的注释或者生成独立的.map文件来存储映射关系。在调试过程中，浏览器或调试器会读取Source Map，并根据其中的映射关系将压缩代码中的行号、列号等信息映射回源代码的对应位置。

 Source Map（源映射）实现原理

Source Map 的实现原理可以简单描述如下：

1. 生成 Source Map：在代码的压缩、混淆或编译过程中，生成器会创建一个 Source Map 对象，并收集相关的映射信息。这些信息包括原始文件路径、行号、列号以及对应的压缩文件中的位置信息。

2. 生成编码字符串：将收集到的映射信息使用 VLQ（Variable Length Quantity）编码进行压缩，将数字转换为可变长度的 Base64 编码字符串。VLQ 编码能够通过特定的规则将数字转换为可变长度的字符串，以减小 Source Map 的体积。

3. 关联 Source Map：在生成的压缩文件中，通过注释或独立的 .map 文件将 Source Map 关联到压缩文件。注释方式可以通过特定的注释语法将编码字符串直接嵌入到压缩文件中，而独立的 .map 文件则将编码字符串保存在一个独立的文件中。

4. 调试时使用 Source Map：在调试过程中，当开发者需要查看或调试源代码时，浏览器或调试工具会加载关联的 Source Map 文件，根据映射关系将压缩文件中的位置信息映射回源代码的对应位置。

通过这种方式，Source Map 实现了将压缩后的代码映射回原始源代码的功能，使得在调试、错误追踪和性能分析时能够更方便地操作和理解源代码。实际上，Source Map 的实现会有更多的细节和规范，但以上是其基本的实现原理概述。

## 内促泄漏定位 {#p0-memory-debug}

内存泄漏主要是指的是内存持续升高，但是如果是正常的内存增长的话，不应该被当作内存泄漏来排查。排查内存泄漏，我们可以借助`Chrome DevTools`的`Performance`和`Memory`选项。举个栗子：

我们新建一个`memory.html`的文件，完整代码如下：

```html
<!DOCTYPE html>
<html lang="en">
<head>
 <meta charset="UTF-8">
 <meta http-equiv="X-UA-Compatible" content="IE=edge">
 <meta name="viewport" content="width=device-width, initial-scale=1.0">
 <title>Document</title>
 <style>
 body {
 text-align: center;
 }
 </style>
</head>
<body>
 <p>检测内存变化</p>
 <button id="btn">开始</button>
 <script>
 const arr = [];
 // 数组中添加100万个数据
 for (let i = 0; i < 10010000; i++) {
 arr.push(i)
 }
 function bind() {
 const obj = {
 str: JSON.stringify(arr) // 浅拷贝的方式创建一个比较大的字符串
 }
 // 每次调用bind函数，都在全局绑定一个onclick监听事件，不一定非要执行
 // 使用绑定事件，主要是为了保持obj被全局标记
 window.addEventListener('click', () => {
 // 引用对象obj
 console.log(obj);
 })
 }
 let n = 0;
 function start() {
 setTimeout(() => {
 bind(); // 调用bind函数
 n++; // 循环次数增加
 if (n < 50) {
 start(); // 循环执行50次，注意这里并没有使用setInterval定时器
 } else {
 alert('done');
 }
 }, 200);
 }
 document.getElementById('btn').addEventListener('click', () => {
 start();
 })
 </script>
</body>
</html>

```

页面上有一个按钮用来开始函数调用，方便我们控制。点击按钮，每个200毫秒执行一次bind函数，即在全局监听click事件，循环次数为50次。

在无法确定是否发生内存泄漏时，我们可以先使用Performance来录制一段页面加载的性能变化，先判断是否有内存泄漏发生。

 Performance

本次案例仅以Chrome浏览器展开描述，其他浏览器可能会有些许差异。首先我们鼠标右键选择检查或者直接F12进入DevTools页面，面板上选择`Performance`，选择后应该是如下页面：

在开始之前，我们先点击一下`Collect garbage`和`clear`来保证内存干净，没有其他遗留内存的干扰。然后我们点击`Record`来开始录制，并且同时我们也要点击页面上的`开始`按钮，让我们的代码跑起来。等到代码结束后，我们再点击`Record`按钮以停止录制，录制的时间跟代码执行的时间相比会有出入，只要保证代码是完全执行完毕的即可。停止录制后，我们会得到如下的结果：

`Performance`的内容很多，我们只需要关注内存的变化，由此图可见，内存这块区域的曲线是在一直升高的并且到达顶点后并没有回落，这就有可能发生了内存泄漏。因为正常的内存变化曲线应该是类似于“锯齿”，也就是有上有下，正常增长后会有一定的回落，但不一定回落到和初始值一样。而且我们还可以隐约看到程序运行结束后，内存从初始的6.2MB增加到了差不多351MB，这个数量级的增加还是挺明显的。我们只是执行了50次循环，如果执行的次数更多，将会耗尽浏览器的内存空间，导致页面卡死。

虽然是有内存泄漏，但是如果我们想进一步看内存泄漏发生的地方，那么`Performance`就不够用了，这个时候我们就需要使用`Memory`面板。

 Memory

DevTools的Memory选项主要是用来录制堆内存的快照，为的是进一步分析内存泄漏的详细信息。有人可能会说，为啥不一开始就直接使用`Memory`呢，反而是先使用`Performance`。因为我们刚开始就说了，内存增长不表示就一定出现了内存泄漏，有可能是正常的增长，直接使用Memory来分析可能得不到正确的结果。

我们先来看一下怎么使用`Memory`：

首先选择`Memory`选项，然后清除缓存，在配置选项中选择堆内存快照。内存快照每次点击录制按钮都会记录当前的内存使用情况，我们可以在程序开始前点击一下记录初始的内存使用，代码结束后再点一下记录最终的内存使用，中间可以点击也可以不点击。最后在快照列表中至少可以得到两个内存记录：

初始内存我们暂时不深究，我们选择列表的最后一条记录，然后在筛选下拉框选择最后一个，即第一个快照和第二个快照的差异。

这里我们重点说一下`Shallow Size`和`Retained Size`的区别：

* Shallow Size：对象自身占用的内存大小，一般来说字符串、数组的Shallow Size都会比较大
* Retained Size：这个是对象自身占用的内存加上无法被GC释放的内存的大小，如果Retained Size和Shallow Size相差不大，基本上可以判定没有发生内存泄漏，但是**如果相差很大**，例如上图的`Object`，这就表明发生了内存泄漏。

我们再来细看一下`Object`，任意展开一个对象，可以在树结构中发现每一个对象都有一个全局事件绑定，并且占用了较大的内存空间。解决本案例涉及的内存泄漏也比较简单，就是及时释放绑定的全局事件。

关于`Performance`和`Memory`的详细使用可以参考：[手把手教你排查Javascript内存泄漏](https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F322356761 "https://zhuanlan.zhihu.com/p/322356761")

大多数情况下，垃圾回收器会帮我们及时释放内存，一般不会发生内存泄漏。但是有些场景是内存泄漏的高发区，我们在使用的时候一定要注意：

* 我们在开发的时候经常会使用`console`在控制台打印信息，但这也会带来一个问题：被`console`使用的对象是不能被垃圾回收的，这就可能会导致内存泄漏。因此在生产环境中不建议使用`console.log()`的理由就又可以加上一条避免内存泄漏了。

* 被全局变量、全局函数引用的对象，在Vue组件销毁时未清除，可能会导致内存泄漏

 ```js
 // Vue3
 <script setup>
 import {onMounted, onBeforeUnmount, reactive} from 'vue'
 const arr = reactive([1,2,3]);
 onMounted(() => {
 window.arr = arr; // 被全局变量引用
 window.arrFunc = () => {
 console.log(arr); // 被全局函数引用
 }
 })
 // 正确的方式
 onBeforeUnmount(() => {
 window.arr = null;
 window.arrFunc = null;
 })
 </script>
 
 ```

* 定时器未及时在Vue组件销毁时清除，可能会导致内存泄漏

 ```js
 // Vue3
 <script setup>
 import {onMounted, onBeforeUnmount, reactive} from 'vue'
 const arr = reactive([1,2,3]);
 const timer = reactive(null);
 onMounted(() => {
 setInterval(() => {
 console.log(arr); // arr被定时器占用，无法被垃圾回收
 }, 200);
 // 正确的方式
 timer = setInterval(() => {
 console.log(arr);
 }, 200);
 })
 // 正确的方式
 onBeforeUnmount(() => {
 if (timer) {
 clearInterval(timer);
 timer = null;
 }
 })
 </script>
 
 ```

 `setTimeout`和`setInterval`两个定时器在使用时都应该注意是否需要清理定时器，特别是`setInterval`，一定要注意清除。

* 绑定的事件未及时在Vue组件销毁时清除，可能会导致内存泄漏

 绑定事件在实际开发中经常遇到，我们一般使用`addEventListener`来创建。

 ```js
 // Vue3
 <script setup>
 import {onMounted, onBeforeUnmount, reactive} from 'vue'
 const arr = reactive([1,2,3]);
 const printArr = () => {
 console.log(arr)
 }
 onMounted(() => {
 // 监听事件绑定的函数为匿名函数，将无法被清除
 window.addEventListener('click', () => {
 console.log(arr); // 全局绑定的click事件，arr被引用，将无法被垃圾回收
 })
 // 正确的方式
 window.addEventListener('click', printArr);
 })
 // 正确的方式
 onBeforeUnmount(() => {
 // 注意清除绑定事件需要前后是同一个函数，如果函数不同将不会清除
 window.removeEventListener('click', printArr);
 })
 </script>
 
 ```

* 被自定义事件引用，在Vue组件销毁时未清除，可能会导致内存泄漏

 自定义事件通过`emit/on`来发起和监听，清除自定义事件和绑定事件差不多，不同的是需要调用`off`方法

 ```js
 // Vue3
 <script setup>
 import {onMounted, onBeforeUnmount, reactive} from 'vue'
 import event from './event.js'; // 自定义事件
 const arr = reactive([1,2,3]);
 const printArr = () => {
 console.log(arr)
 }
 onMounted(() => {
 // 使用匿名函数，会导致自定义事件无法被清除
 event.on('printArr', () => {
 console.log(arr)
 })
 // 正确的方式
 event.on('printArr', printArr)
 })
 // 正确的方式
 onBeforeUnmount(() => {
 // 注意清除自定义事件需要前后是同一个函数，如果函数不同将不会清除
 event.off('printArr', printArr)
 })
 </script>
 
 ```

除了及时清除监听器、事件等，对于全局变量的引用，我们可以选择`WeakMap`、`WeakSet`等弱引用数据类型。这样的话，即使我们引用的对象数据要被垃圾回收，弱引用的全局变量并不会阻止GC。

监控前端页面内存持续增长可以帮助我们及时发现内存泄漏和其他内存问题，从而优化前端页面的性能和稳定性。以下是一些监控前端页面内存持续增长的方法：

1. 使用浏览器开发工具：现代浏览器的开发工具提供了内存监控功能。您可以使用 Chrome 开发者工具、Firefox 开发者工具等浏览器工具来监控内存的使用情况，并在内存使用超过阈值时进行警报。

2. 手动检查页面代码：您可以手动检查页面的代码，特别是 JavaScript 代码和其他 DOM 操作，以查找可能导致内存泄漏的问题。例如，可能存在未清理的定时器、事件监听器、未释放的 DOM 元素等。

3. 使用性能监测工具：性能监测工具，例如 New Relic、AppDynamics 等，可以监测前端页面的性能，并提供关于内存使用的警报和报告。

4. 使用内存检测工具：内存检测工具，例如 memoryjs、heapdump.js 等，可以帮助检测内存泄漏和内存问题。这些工具可以生成内存快照，分析内存使用情况，以及识别潜在的内存泄漏问题。

通过以上方法的一些组合使用，可以帮助您监控前端页面内存持续增长的情况，及时发现和解决内存问题，提升用户体验和网站可靠性。

## crash {#p0-crash}

对于 web 页面线上监控，如果页面崩溃了，通常会出现 500 或 404 状态码，或者页面停止响应或显示白屏等情况。

以下是一些监控崩溃的方法：

1. 使用网站性能监测工具：这些工具可以检测页面的状态码和响应时间，如果页面崩溃了，就会发出警报。一些流行的性能监测工具包括 New Relic, Pingdom, 和 UptimeRobot 等。

2. 设置异常检测：异常检测可以监测页面异常的行为，例如页面响应时间超过特定时间限制，或者页面元素加载失败等。通过设置这些异常检测，可以在页面崩溃时自动触发警报。

3. 实时用户行为监测：实时监测用户行为可以帮助识别用户在页面上的行为，例如页面停留时间，点击按钮的位置等，以便检测页面异常行为。这些监测可以使用 Google Analytics, Mixpanel 等网站分析工具实现。

4. 前端代码错误监测：使用前端监测工具，例如 Sentry, Raygun, 和 Bugsnag 等，可以监测前端代码错误，包括 JavaScript 和 CSS 错误，以便快速识别和解决问题。

通过以上方法的一些组合使用，可以帮助您监控 web 页面的崩溃，及时发现和解决问题，提升用户体验和网站可靠性。

 如果是页面运行时页面崩溃， 如何监控？

如果在运行时发生页面崩溃，可以使用以下方法进行监控：

1. 实时监控日志：可以设置日志监控，将日志实时发送到日志收集工具，例如 ELK Stack、Splunk 等。这些工具可以分析和提取有关页面崩溃的信息，例如错误消息、堆栈跟踪等，以便快速识别和解决问题。

2. 页面截图：当页面崩溃时，可以使用截图工具进行截屏，以捕获页面的当前状态。这些截图可以用于快速检查页面崩溃的根本原因。

3. 人工检测：可以雇用专业的质量测试人员或专业服务公司进行页面质量测试，以便在页面崩溃时进行手动检测和识别。

4. 实时异常检测：实时监测页面异常的行为，例如页面响应时间超过特定时间限制，或者页面元素加载失败等。通过设置这些异常检测，可以在页面崩溃时自动触发警报。

通过以上方法的一些组合使用，可以帮助您在运行时监控 web 页面的崩溃，及时发现和解决问题，提升用户体验和网站可靠性。
