# 调试能力

## 如何定位一个偶现的问题？

第一时间看看有没有较好的现场日志和数据能帮助定位问题
给到相应的设备信息和时间，能否根据描述的现象找到相应的日志定位，反向 push
自己尝试定位复现，找到合适的日志，如果多次操作仍不能马上复现，评估是否要挂起，看问题的出现概率和严重程度
如果是体验相关问题，最终判断概率极低，那么灰度期间，持续观察数据，线上进行监控

## 如何禁止别人调试自己的前端页面代码? {#p4-debug}

* 前端页面防止调试的方法主要是通过不断 `debugger` 来疯狂输出断点，因为 `debugger` 在控制台被打开的时候就会执行
* 由于程序被 `debugger` 阻止，所以无法进行断点调试，所以网页的请求也是看不到的
* 基础代码如下：

```javascript
/**
* 基础禁止调试代码
*/
(() => {
  function ban () {
    setInterval(() => {
      // eslint-disable-next-line
      debugger
    }, 50)
  }
  try {
    ban()
  } catch (err) { }
})()
```

**无限 debugger 的对策**

* 如果仅仅是加上面那么简单的代码，对于一些技术人员而言作用不大
* 可以通过控制台中的 `Deactivate breakpoints` 按钮或者使用快捷键 `Ctrl + F8` 关闭无限 `debugger`
* 这种方式虽然能去掉碍眼的 `debugger`，但是无法通过左侧的行号添加 `breakpoint`

**禁止断点的对策**

* 如果将 `setInterval` 中的代码写在一行，就能禁止用户断点，即使添加 `logpoint` 为 `false` 也无用
* 当然即使有些人想到用左下角的格式化代码，将其变成多行也是没用的

```javascript
(() => {
  function ban () {
    setInterval(() => {
      // debugger
    }, 50)
  }
  try {
    ban()
  } catch (err) { }
})()
```

**忽略执行的代码**

* 通过添加 `add script ignore list` 需要忽略执行代码行或文件
* 也可以达到禁止无限 `debugger`

**忽略执行代码的对策**

* 那如何针对上面操作的恶意用户呢
* 可以通过将 `debugger`改写成 `Function("debugger")();` 的形式来应对
* `Function` 构造器生成的 `debugger` 会在每一次执行时开启一个临时 `js` 文件
* 当然使用的时候，为了更加的安全，最好使用加密后的脚本

```javascript
// 加密前
(() => {
  function ban () {
    setInterval(() => {
      // eslint-disable-next-line
      Function('debugger')()
    }, 50)
  }
  try {
    ban()
  } catch (err) { }
})()

// 加密后
// eslint-disable-next-line
eval(function (c, g, a, b, d, e) { d = String; if (!''.replace(/^/, String)) { for (;a--;)e[a] = b[a] || a; b = [function (f) { return e[f] }]; d = function () { return '\w+' }; a = 1 } for (;a--;)b[a] && (c = c.replace(new RegExp('\b' + d(a) + '\b', 'g'), b[a])); return c }('(()=>{1 0(){2(()=>{3("4")()},5)}6{0()}7(8){}})();', 9, 9, 'block function setInterval Function debugger 50 try catch err'.split(' '), 0, {}))
```

**终极增强防调试代码**

* 为了让自己写出来的代码更加的晦涩难懂，需要对上面的代码再优化一下
* 将 `Function('debugger').call()`改成 `(function(){return false;})['constructor']('debugger')['call']();`
* 并且添加条件，当窗口外部宽高和内部宽高的差值大于一定的值 ，我把 `body` 里的内容换成指定内容
* 当然使用的时候，为了更加的安全，最好加密后再使用

```javascript
(() => {
  function block () {
    if (window.outerHeight - window.innerHeight > 200 || window.outerWidth - window.innerWidth > 200) {
      document.body.innerHTML = '检测到非法调试,请关闭后刷新重试!'
    }
    setInterval(() => {
      (function () {
        return false
      }
        .constructor('debugger')
        .call())
    }, 50)
  }
  try {
    block()
  } catch (err) { }
})()
```

**参考文档**

* [资料](https://juejin.cn/post/7262175454714626108)

## 用户访问页面白屏了， 原因是啥， 如何排查？ {#debug-white}

用户访问页面白屏可能由多种原因引起，以下是一些可能的原因和排查步骤：

1. 网络问题：用户的网络连接可能存在问题，无法正确加载页面内容。可以要求用户检查网络连接，或者自己尝试在不同网络环境下测试页面的加载情况。

2. 服务端问题：服务器未正确响应用户请求，导致页面无法加载。可以检查服务器的状态、日志和错误信息，查看是否有任何异常。同时，可以确认服务器上的相关服务是否正常运行。

3. 前端代码问题：页面的前端代码可能存在错误或异常，导致页面无法正常渲染。可以检查浏览器的开发者工具，查看是否有任何错误信息或警告。同时，可以尝试将页面的JavaScript、CSS和HTML代码分离出来进行单独测试，以确定具体的问题所在。

4. 浏览器兼容性问题：不同浏览器对于某些代码的支持可能不一致，导致页面在某些浏览器中无法正常加载。可以尝试在不同浏览器中测试页面的加载情况，同时使用浏览器的开发者工具检查是否有任何错误或警告。

5. 第三方资源加载问题：页面可能依赖于某些第三方资源（如外部脚本、样式表等），如果这些资源无法加载，可能导致页面白屏。可以检查网络请求是否正常，是否有任何资源加载失败的情况。

6. 缓存问题：浏览器可能在缓存中保存了旧版本的页面或资源，导致新版本无法加载。可以尝试清除浏览器缓存，或者通过添加随机参数或修改文件名的方式强制浏览器重新加载页面和资源。

7. 其他可能原因：页面白屏问题还可能由于安全策略（如CSP、CORS等）限制、跨域问题、DNS解析问题等引起。可以使用浏览器的开发者工具检查网络请求和错误信息，查找可能的问题。

在排查问题时，可以根据具体情况逐步进行排查，并结合浏览器的开发者工具、服务器日志等工具来辅助定位问题所在，并且可以与用户进行进一步沟通以获取更多信息。如果问题无法解决，可以寻求专业的技术支持或咨询。

## jank {#p0-debug-jank}

排查网页卡顿问题时，可以按照以下步骤进行处理：

1. 验证用户反馈：首先，确认用户反馈的卡顿问题是否普遍存在，还是个别用户的特殊情况。可以与其他用户进行沟通或观察其他设备上的表现。

2. 检查网络连接：检查用户的网络连接是否稳定。卡顿问题可能由于网络延迟或不稳定导致。可以要求用户进行网络速度测试，或者与用户确认网络连接是否正常。

3. 检查服务器性能：确认服务器是否能够处理用户的请求。可以检查服务器的负载情况、处理请求的时间以及资源使用情况。如果服务器负载过高，可能导致网页卡顿。

4. 检查前端代码：检查网页的前端代码是否存在问题。主要看是否有内存泄露、long task 等情况；
关于内存泄露和 long task 可以看下面两个文档：

* [JS 内存泄露问题该如何排查？](https://github.com/pro-collection/interview-question/issues/76)

* [Long Tasks 了解多少？](https://github.com/pro-collection/interview-question/issues/255)

5. 优化网页性能：对于前端代码存在性能问题的情况，可以尝试优化网页性能。例如，压缩和合并CSS和JavaScript文件、减少网络请求次数、使用缓存等方法来提高页面加载速度。
可以参考下面文档文档：

* [从哪些方面可以对网站性能优化？](https://github.com/pro-collection/interview-question/issues/89)

6. 做好性能监控：持续监测网页的性能，并定期更新网页的代码和设计，以提升用户体验。

* [`[性能]` 衡量页面性能的指标有哪些？](https://github.com/pro-collection/interview-question/issues/515)

## source map  {#p0-source-map}

 Source Map（源映射）作用

Source Map（源映射）是一种文件，用于将压缩、混淆或编译后的代码映射回原始的源代码，以便在调试过程中能够直接查看和调试源代码。它提供了压缩文件和源文件之间的映射关系，包括每个压缩文件中的代码位置、原始文件的路径和行号等信息。

Source Map的主要作用如下：

1. 调试：在开发过程中，源代码经常会被压缩、合并或转换为其他形式的代码，这使得在调试时直接查看和调试源代码变得困难。Source Map提供了一种方式，通过将压缩代码映射回源代码，开发者可以在调试器中直接查看和调试原始的、易于理解的源代码。

2. 错误追踪：当发生错误或异常时，浏览器或运行环境会提供错误信息，其中包含了压缩后的代码行号和列号。Source Map可以将这些行号和列号映射回源代码的行号和列号，帮助开发者定位和追踪错误。

3. 性能分析：Source Map可以提供压缩文件中每个代码片段对应的原始文件位置信息，这对于性能分析工具来说非常有用。性能分析工具可以使用Source Map来将性能数据映射回源代码，以便更准确地分析和优化代码性能。

Source Map的原理是通过在压缩文件中添加特定的注释或者生成独立的.map文件来存储映射关系。在调试过程中，浏览器或调试器会读取Source Map，并根据其中的映射关系将压缩代码中的行号、列号等信息映射回源代码的对应位置。

 Source Map（源映射）实现原理

Source Map 的实现原理可以简单描述如下：

1. 生成 Source Map：在代码的压缩、混淆或编译过程中，生成器会创建一个 Source Map 对象，并收集相关的映射信息。这些信息包括原始文件路径、行号、列号以及对应的压缩文件中的位置信息。

2. 生成编码字符串：将收集到的映射信息使用 VLQ（Variable Length Quantity）编码进行压缩，将数字转换为可变长度的 Base64 编码字符串。VLQ 编码能够通过特定的规则将数字转换为可变长度的字符串，以减小 Source Map 的体积。

3. 关联 Source Map：在生成的压缩文件中，通过注释或独立的 .map 文件将 Source Map 关联到压缩文件。注释方式可以通过特定的注释语法将编码字符串直接嵌入到压缩文件中，而独立的 .map 文件则将编码字符串保存在一个独立的文件中。

4. 调试时使用 Source Map：在调试过程中，当开发者需要查看或调试源代码时，浏览器或调试工具会加载关联的 Source Map 文件，根据映射关系将压缩文件中的位置信息映射回源代码的对应位置。

通过这种方式，Source Map 实现了将压缩后的代码映射回原始源代码的功能，使得在调试、错误追踪和性能分析时能够更方便地操作和理解源代码。实际上，Source Map 的实现会有更多的细节和规范，但以上是其基本的实现原理概述。
