# git

## 常用的 git 命令

## 什么是 semver 规范，~1.2.3 与 ^1.2.3 的版本号范围是多少 {#p2-semver-version-range}

SemVer（Semantic Versioning，语义化版本）是一种规范，用于管理软件版本号的命名和变更。它的目的是通过明确的版本号规则，让开发者和用户能够更好地理解软件的变化和兼容性。

SemVer 版本号由三个部分组成：主版本号（major）、次版本号（minor）和修订版本号（patch），格式为`major.minor.patch`。

* 主版本号：当进行不兼容的 API 更改时增加。
* 次版本号：当添加向后兼容的新功能时增加。
* 修订版本号：当进行向后兼容的错误修复时增加。

**`~1.2.3`的版本号范围**：

* 这表示匹配大于等于 1.2.3 且小于 1.3.0 的版本。
* 它会优先更新修订版本号，即如果有 1.2.4、1.2.5 等版本，会优先选择这些版本进行安装，但不会安装 1.3.0 及以上版本。

**`^1.2.3`的版本号范围**：

* 表示匹配大于等于 1.2.3 且小于 2.0.0 的版本。
* 它会优先更新次版本号和修订版本号。例如，如果有 1.3.0、1.4.2 等版本，会优先选择这些版本进行安装，但不会安装 2.0.0 及以上版本。

## 在开发过程中，想做 git 代码暂存，该如何做 {#p2-git-stash}

在 Git 中，如果你想要暂存当前的工作进度，可以使用`git stash`命令。这个命令会将你的工作目录中的修改（已追踪文件的修改和暂存的改动）保存到一个未完成工作的栈中，同时将你的工作目录恢复到上次提交的状态，从而让你可以转而处理其他工作，之后再回来继续刚才的工作。

 基本用法

* **暂存当前的工作**

```bash
git stash
```

或者，为这次暂存操作添加一个描述，以便之后更容易识别：

```bash
git stash save "特征X的进度"
```

* **查看暂存列表**

```bash
git stash list
```

这个命令会显示所有被暂存的进度列表。

* **应用最近的暂存**

```bash
git stash apply
```

默认情况下，`git stash apply`将重新应用最近暂存的进度。如果你有多个暂存进度，可以通过指定 stash 的名称（例如：`stash@{0}`）来选择具体的一个进度使用。

```bash
git stash apply stash@{0}
```

* **弹出最近的暂存**

```bash
git stash pop
```

这个命令将应用最近的暂存进度，并将这个暂存记录从暂存的栈中移除。

* **删除一个指定的暂存**

```bash
git stash drop stash@{0}
```

* **清除所有暂存**

```bash
git stash clear
```

 进阶用法

* **暂存未追踪的文件**

如果你还想暂存那些新添加到工作目录中但还没有加入版本控制的文件（即未追踪文件），可以使用`-u`或`--include-untracked`选项：

```bash
git stash -u
```

或

```bash
git stash --include-untracked
```

* **暂存忽略文件**

默认`git stash`不会暂存`.gitignore`中忽略的文件。如果你希望连同这些文件一起暂存，可以使用`-a`或`--all`选项：

```bash
git stash -a
```

git stash 是一个非常有用的功能，特别是当你需要快速切换到另一个分支处理一些工作，而你的当前分支有未完成的工作时。它允许你临时保管你的工作进度，防止未完工的更改妨碍其他任务的进行。

## git-rebase {#p2-git-rebase}

将多次提交压缩成一次提交在 Git 中被称为“squash”。这通常在你完成一段工作后，想要将这段时间内的多个提交整理为一个更干净、更整洁的提交记录时使用。Git 提供了几种方法来实现提交的压缩，最常用的是通过 `git rebase` 命令配合交互模式（interactive mode）来实现。

 使用 `git rebase -i` 进行交互式压缩

假设你想压缩最近的 N 次提交。首先，你需要确定从哪个提交开始进行操作。可以通过 `git log` 查看提交历史，然后选择你想要压缩的提交的前一个提交作为起点。

1. **启动交互式 rebase 会话**：

 ```bash
 git rebase -i HEAD~N
 ```

 其中 `N` 是你想要压缩的提交数量。例如，如果你想要压缩最近的 3 次提交，你应该使用 `git rebase -i HEAD~3`。

2. **编辑 rebase 会话中出现的命令列表**：

 执行上述命令后，你的默认文本编辑器会打开一个带有待压缩提交列表的文件。这些提交被列出来，前面默认是 `pick` 命令。

 ```plaintext
 pick e3a1b35 第一次提交的消息
 pick 7ac9a67 第二次提交的消息
 pick 1d2a3f4 第三次提交的消息
 ```

 将除了第一个提交之外的所有 `pick` 命令改为 `squash` 或简写 `s`，表示这些提交将被压缩到前一个提交中。

 ```plaintext
 pick e3a1b35 第一次提交的消息
 squash 7ac9a67 第二次提交的消息
 squash 1d2a3f4 第三次提交的消息
 ```

3. **保存并退出编辑器**：

 一旦保存并关闭编辑器，Git 将开始 rebase 过程，并可能会要求你解决任何合并冲突。然后，它会打开你的文本编辑器，让你编辑最终的提交消息。默认情况下，这会包含你压缩的所有原始提交消息。

4. **完成 rebase 过程**：

 解决完所有冲突（如果有的话）并保存你的最终提交消息之后，你可以完成 rebase 过程。

5. **推送更改到远端仓库（如果需要）**：

 如果你已经将提交推送到了远端仓库，你可能需要使用 `--force` 参数来强制推送更改，**但请注意，这可以覆盖远端仓库的历史，因此仅在确保不会影响他人工作的情况下使用**。

 ```bash
 git push origin your-branch-name --force
 ```

通过这种方法，你可以将多个提交压缩成一个更整洁的提交，以保持项目历史的清晰。

移除某一个指定的 `commit` 通常意味着要在版本控制系统如 Git 中更改历史记录，这通常涉及到一些操作风险，尤其是当这个 `commit` 已经被推送到远程仓库且被其他人使用。下面是几种常见的移除指定 `commit` 的方法，但在进行这些操作前，请确保备份你的代码，以防不测：

 使用 `git rebase` 交互式命令

1. 打开终端或命令行界面。
2. 定位到你的 Git 项目路径下。
3. 执行 `git rebase -i HEAD~X` 命令，`X` 是从当前回到你想要移除的 `commit` 的数量加 1。这条命令会打开一个交互式界面，列出最近的 `X` 次提交。
4. 找到你想要移除的 `commit`，并将其前面的 `pick` 改为 `drop`。或者干脆删除那一行。
5. 保存并关闭编辑器，Git 会自动开始 rebase 进程。

 如果你只是想修改最近的一次 `commit`

如果你仅仅是想移除最近的一次提交，可以这样做：

1. 使用命令 `git reset --soft HEAD~1` 将最后一次提交回退到暂存状态，不影响工作目录。
2. 使用命令 `git reset --hard HEAD~1` 将最后一次提交完全撤销，包括工作目录和暂存区的改变。

 警告

* 修改已经被推送到远程仓库的历史是非常危险的，如果其他人已经基于这些提交做了开发，这将引起合并冲突。
* 如果你需要修改已经推送过的提交，完成上述操作后，需要使用 `git push --force` 来强制推送到远程仓库，这样也会影响到其他协作者的开发进程。

## git bisect {#p4-git-bisect}

确实，当你不确定哪个提交(commit)引入了错误时，Git 提供了一个非常强大的工具 `git bisect` 来帮助你通过二分法快速定位出问题的提交。这个命令通过逐步缩小导致问题的提交范围，最终帮助你找出导致错误的具体提交。使用方法如下：

 如何使用 git bisect

1. **开始 bisect 会话**：
 打开终端或命令行，切换到你的项目目录下，然后使用命令开始一个 bisect 会话：

```shell
git bisect start
```

2. **标记一个坏的提交**：
 使用下面的命令标记当前最新的提交为'坏'的（假设当前分支上的最新提交包含了错误）：

```shell
git bisect bad
```

如果你已经知道一个特定的坏提交，可以指定它：`git bisect bad [坏的提交id]`

3. **标记一个好的提交**：
 接下来，使用以下命令标记一个'好'的提交，即一个没有问题的旧版本：

```shell
git bisect good [好的提交id]
```

这个好的提交应该是你确定不包含当前问题的一次提交。

完成以上步骤之后，`git bisect` 将自动检出一个中间的提交供你测试。你需要编译（如果必要的话）并测试这个版本，然后根据运行结果告诉 Git 这是好是坏：

* 如果这个提交版本没有问题，使用 `git bisect good`。
* 如果这个提交版本有问题，使用 `git bisect bad`。

每次你输入结果后，Git 会继续选择另一个提交进行测试，直至找到第一个'坏'的提交。

 结束 bisect 会话

一旦找到了问题提交，别忘了结束 bisect 会话，释放由 `git bisect` 占用的资源：

```shell
git bisect reset
```

这将会把你的工作目录恢复到 `git bisect` 开始之前的状态。

 注意事项

* 使用 `git bisect` 时，确保有足够的测试覆盖，以准确判断某个提交是好是坏。
* 一旦找到问题提交，你可以通过查看该提交的详情(`git show [提交id]`)来了解更多信息，从而帮助你理解为何会引入错误。

 更加详细的介绍， 可以参考下面文章链接

[资料](https://juejin.cn/post/7232591499069653051)

## git pull 和 git fetch 区别 {#p2-diff-pull-fetch}

`git pull` 和 `git fetch` 是 Git 版本控制系统中的两个基本命令，它们都用于从远程仓库更新本地仓库的信息，但执行的具体操作不同。

 git fetch

* `git fetch` 下载远程仓库最新的内容到你的本地仓库，但它并不自动合并或修改你当前的工作。它取回了远程仓库的所有分支和标签（tags）。
* 运行 `git fetch` 后，你可以在需要时手动执行合并操作（使用 `git merge`）或者重新基于远程仓库的内容进行修改。

* `fetch` 只是将远程变更下载到本地的远程分支跟踪副本中，例如 `origin/master`。

 git pull

* `git pull` 实际上是 `git fetch` 操作之后紧跟一个 `git merge` 操作，它会自动拉取远程仓库的新变更，并尝试合并到当前所在的本地分支中。

* 当你使用 `git pull`，Git 会尝试自动合并变更。这可能会引起冲突（conflicts），当然冲突需要手动解决。

* `git pull` 等价于执行了 `git fetch` 和 `git merge FETCH_HEAD` 的组合。

 使用场景

* 当你仅仅想要查看远程仓库的变动而不立即合并到你的工作，可以使用 `git fetch`。

* 而当你想要立即获取远程的最新变动并快速合并到你的工作中，则可以使用 `git pull`。
