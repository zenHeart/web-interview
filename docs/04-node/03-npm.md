# npm

## package.json 依赖申明的方式有哪些， 他们有何却别 {#p2-package-json-dependencies}

**一、`dependencies`（生产依赖）**

1. **定义和用途**：

* `dependencies`用于声明项目在生产环境中运行所必需的依赖项。
* 这些依赖项是项目正常运行所不可或缺的，无论是在开发阶段还是在部署到生产环境后。

2. **示例**：

* 比如，如果你的项目使用了 Express.js 框架来构建服务器，那么 Express.js 就应该被声明在`dependencies`中。
* `"express": "^4.17.1"`表示安装 Express 版本 4.17.1 或更高的兼容版本。

3. **安装和使用**：

* 当你运行`npm install`或`yarn install`时，这些依赖项会被自动安装到项目的`node_modules`目录中。
* 在生产环境中部署项目时，这些依赖项也会被一同部署。

**二、`devDependencies`（开发依赖）**

1. **定义和用途**：

* `devDependencies`用于声明仅在开发过程中需要的依赖项。
* 这些依赖项通常包括开发工具、测试框架、代码格式化工具等，它们不是项目在生产环境中运行所必需的。

2. **示例**：

* 例如，Jest 是一个流行的 JavaScript 测试框架，如果你的项目使用 Jest 进行测试，那么 Jest 应该被声明在`devDependencies`中。
* `"jest": "^26.6.3"`表示安装 Jest 版本 26.6.3 或更高的兼容版本。

3. **安装和使用**：

* 同样，当你运行`npm install`或`yarn install`时，这些依赖项会被安装到项目的`node_modules`目录中。
* 但是，在生产环境中部署项目时，通常不会部署这些开发依赖项，以减小项目的体积和复杂性。

**区别总结**：

1. **使用场景不同**：

* `dependencies`中的依赖项是项目在生产环境中运行所必需的，而`devDependencies`中的依赖项仅在开发过程中使用。

2. **部署方式不同**：

* 生产环境部署时，通常只部署`dependencies`中的依赖项，而不部署`devDependencies`中的依赖项。

3. **影响项目体积和复杂性**：

* 将不必要的依赖项放在`devDependencies`中可以减小项目在生产环境中的体积和复杂性，提高性能和安全性。

**三、`peerDependencies`（对等依赖）**

1. **定义和用途**：

* `peerDependencies` 用于声明当前包所依赖的其他包，但这些依赖项不会被自动安装。
* 它通常用于插件或扩展的场景，表明当前包与特定版本的其他包兼容，并且期望宿主环境已经安装了这些对等依赖。

2. **示例**：

* 假设你正在开发一个 React 插件，你的插件可能需要特定版本的 React 才能正常工作。在这种情况下，你可以在 `package.json` 的 `peerDependencies` 中声明对 React 的依赖。
* `"peerDependencies": { "react": "^17.0.2" }` 表示这个插件期望宿主环境安装了 React 17.0.2 或更高的兼容版本。

3. **安装和使用**：

* 当用户安装你的包时，他们需要确保在自己的项目中手动安装了满足 `peerDependencies` 要求的包。如果没有安装或版本不匹配，可能会导致运行时错误。

**区别总结**：

* **与 `dependencies` 的区别**：
* `dependencies` 中的依赖项会在安装当前包时自动安装，而 `peerDependencies` 中的依赖项不会自动安装，需要用户在宿主项目中自行安装。
* **与 `devDependencies` 的区别**：
* `devDependencies` 是仅在开发过程中使用的依赖项，而 `peerDependencies` 是与当前包在运行时的兼容性相关的依赖项，不一定只在开发过程中使用。

## package.json 里面，表示导出包内容的配置有哪些 {#p1-package-json-export-config}

**一、`main`字段**

1. 作用：

* 指定当你的包被引入时，模块系统应该加载的主要入口文件。
* 对于 CommonJS 和 ES6 模块系统，这个文件将作为默认的入口点。

2. 示例：

* `"main": "dist/index.js"`表示当你的包被引入时，会加载`dist`目录下的`index.js`文件作为主要入口。

**二、`module`字段**

1. 作用：

* 专门为 ES6 模块系统指定入口文件。
* 一些现代的构建工具和环境（如 Webpack、Rollup 等）会优先使用这个字段来确定 ES6 模块的入口点。

2. 示例：

* `"module": "esm/index.js"`表示对于支持 ES6 模块的环境，会加载`esm`目录下的`index.js`文件。

**三、`exports`字段（在 Node.js 12+ 和一些现代构建工具中支持）**

1. 作用：

* 提供了一种更灵活的方式来指定包的不同入口点，可以根据不同的模块系统和环境来导出不同的文件。
* 可以同时为 CommonJS、ES6 模块、不同的子路径等指定特定的入口文件。

2. 示例：

```json

 "exports": {
 ".": {
 "import": "./esm/index.js",
 "require": "./cjs/index.js"
 },
 "./submodule": {
 "import": "./esm/submodule.js",
 "require": "./cjs/submodule.js"
 }
 }
 ```

* 在这个例子中，对于根路径（`.`），如果是 ES6 模块环境，会加载`./esm/index.js`；如果是 CommonJS 环境，会加载`./cjs/index.js`。对于`./submodule`子路径，也分别指定了不同模块系统的入口文件。

这些配置允许你控制包的导出内容和入口点，以便其他开发者能够正确地引入和使用你的包。根据你的项目结构和目标环境，可以选择合适的配置来确保包的可维护性和兼容性。

## 说一下你对 npm hook 的理解 {#p2-npm-hook}

| 脚本名称 | 阶段 | 描述 | 执行时机 |
|-----------------|--------------|-------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------|
| preinstall | pre | 在 npm install 执行前运行，用于执行一些安装前的准备工作，例如检查依赖项或设置环境变量。 | 安装前 |
| install, postinstall | install | 在模块安装后执行，通常用于构建项目或者为其生成某些必须的文件，例如安装完毕后自动编译 TypeScript、ES6 等。 | 安装后 |
| preuninstall | pre | 在 npm uninstall 执行前运行，用于执行一些卸载前的准备工作。 | 卸载前 |
| uninstall | post | 在 npm uninstall 执行后运行，用于清理卸载后的一些操作。 | 卸载后 |
| postuninstall | post | 在 npm uninstall 执行后运行，用于执行一些卸载后的操作。 | 卸载后 |

 发布和更新版本

| 脚本名称 | 阶段 | 描述 | 执行时机 |
|-----------------|--------------|-------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------|
| prepublish | pre | 在 publish（npm发布）执行前，运行 npm pack。 | 发布前 |
| prepare | pre | 在包被发布前或安装前执行，可以用来设置编译或验证文件的操作。 | 发布前、安装前 |
| prepublishOnly | pre | 在 npm publish 执行前运行，用于确保在 publish 命令执行时不会意外发布不必要的文件。 | 发布前 |
| prepack | pre | 在 npm pack（打包命令）执行前运行，用于执行一些打包前的准备工作。 | 打包前 |
| postpack | post | 在 npm pack 执行后运行，用于清理和重置打包相关的操作。 | 打包后 |
| publish | post | 在包被成功发布后执行。 | 发布后 |
| postpublish | post | 在包被成功发布后执行，用于执行一些发布后的操作。 | 发布后 |
| preversion | pre | 在项目版本号更新（npm version）之前执行。 | 更新版本号前 |
| version | post | 在 npm version 执行后执行，用于执行一些版本更新后的操作。 | 更新版本号后 |
| postversion | post | 在项目版本号更新（npm version）之后执行。 | 更新版本号后 |

 测试和运行

| 脚本名称 | 阶段 | 描述 | 执行时机 |
|-----------------|--------------|-------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------|
| pretest | pre | 在 npm test 执行前执行，用于执行某些测试前的准备工作。 | 测试前 |
| test | test | 执行 npm run test 命令时执行。通常用于执行单元测试，并返回任何错误状态。 | 默认测试阶段 |
| posttest | post | 在 npm test 执行后执行，用于执行某些测试后的操作。 | 测试后 |
| prestart | pre | 在 npm start 执行前运行，用于执行某些启动进程前的准备工作。 | 启动前 |
| start | start | 执行 npm start 命令时执行，通常用于启动 Web 服务器、Node 服务器、实时编译器等。 | 默认启动阶段 |
| poststart | post | 在 npm start 执行后执行，用于执行某些启动进程后的操作。 | 启动后 |
| prerestart | pre | 在 npm restart 执行前执行，用于执行一些重新启动进程前的准备工作。 | 重新启动前 |
| restart | stop/start | 执行 npm restart 命令时执行，通常用于停止正在运行的 Node 服务器、Web 服务器等，然后以更新的源码重新启动服务。 | 默认重新启动阶段，但是该命令会触发停止和启动两个标准阶段 |
| postrestart | post | 在 npm restart 执行后执行，用于执行一些重新启动进程后的操作。 | 重新启动后 |

 其他生命周期

| 脚本名称 | 阶段 | 描述 | 执行时机 |
|-----------------|--------------|-------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------|
| prestop | pre | 在 npm stop 执行前运行，用于执行某些停止进程前的准备工作。 | 停止前 |
| stop | stop | 执行 npm stop 命令时执行，通常用于停止正在运行的 Web 服务器、Node 服务器、实时编译器等。 | 默认停止阶段 |
| poststop | post | 在 npm stop 执行后执行，用于执行某些停止进程后的操作。 | 停止后 |

## npm workspaces 是什么概念， 主要是解决什么问题 {#p2-npm-workspaces}

**一、项目结构管理**

1. **多包项目组织**：

* 在大型项目中，可能包含多个独立的软件包或模块。`npm workspaces`允许将这些包组织在一个统一的项目结构中，方便管理和开发。
* 例如，一个企业级应用可能由一个前端库、一个后端服务和一个共享的工具包组成。使用`npm workspaces`，可以将这些包放在同一个项目目录下，而不是作为独立的项目进行管理。

2. **依赖共享**：

* 多个包之间可能存在共享的依赖项。`npm workspaces`可以自动管理这些共享依赖，避免重复安装和版本冲突。
* 当一个包安装了某个依赖项时，其他包可以直接使用这个依赖，而不需要再次安装。这可以减少项目的体积和安装时间，提高开发效率。

**二、开发效率提升**

1. **单一命令行界面**：

* 使用`npm workspaces`，可以在项目的根目录下使用单一的`npm`命令来管理所有的包。这避免了在每个包的目录下分别运行`npm`命令的繁琐过程。
* 例如，可以在根目录下运行`npm install`来安装所有包的依赖项，或者运行`npm run test`来执行所有包的测试。

2. **同时开发多个包**：

* 开发人员可以在同一个项目中同时开发多个包，而不需要在不同的项目目录之间切换。这可以提高开发效率，特别是在需要频繁修改多个包的情况下。
* 例如，可以在一个编辑器中打开多个包的代码，进行同时编辑和调试。

**三、版本管理和发布**

1. **统一版本控制**：

* 在多包项目中，需要确保各个包的版本保持一致。`npm workspaces`可以帮助管理包的版本，确保在发布时所有的包都使用相同的版本号。
* 可以在项目的根目录下使用`npm version`命令来统一更新所有包的版本号，并生成相应的版本标签。

2. **简化发布流程**：

* 发布多个包时，通常需要分别在每个包的目录下执行发布命令。使用`npm workspaces`，可以在项目的根目录下使用单一的发布命令来发布所有的包。
* 例如，可以使用`npm publish --workspaces`来发布项目中的所有包，而不需要分别进入每个包的目录进行发布。

## pnpm install 和 npm install 有何区别 {#p2-pnpm-install-vs-npm-install}

`pnpm install` 和 `npm install` 都是用于安装 JavaScript 项目依赖的命令，但它们背后的包管理器（分别是 `pnpm` 和 `npm`）在处理依赖安装、存储和优化方面有一些关键区别。

 1. **存储方式的区别**

* **npm**：在每个项目的 `node_modules` 文件夹中分别存储其依赖。这意味着如果你有多个项目，它们共享相同的依赖库，这些依赖库的多个副本将在你的文件系统中的每个项目内分别存储。这样做会占用更多的磁盘空间。

* **pnpm**：采用一种称为**内容寻址文件系统**的方式来存储依赖。所有项目的依赖被存储在一个共享的位置，各个项目中的 `node_modules` 目录通过硬链接（hard links）或符号链接（symlinks）指向这个共享位置。该方法有效地减少了磁盘空间的占用，并加快了依赖的安装速度。

 2. **性能与速度**

* **pnpm**：由于对依赖进行了有效的复用，并且使用硬链接来减少磁盘上的副本数量，通常可以提供比 `npm` 更快的安装速度。

* **npm**：近几个大版本中也进行了许多性能改进，但在多个项目中共享相同依赖时，它可能仍然比 `pnpm` 更慢，尤其是在首次安装依赖时。

 3. **依赖平面结构 vs. 嵌套结构**

* **npm**：自版本 3 以后，默认创建扁平的 `node_modules` 结构（尽可能），这样做是为了避免 Windows 系统中路径过长的问题。但在必要时， `npm` 仍然会创建嵌套的 `node_modules` 目录结构，以解决依赖冲突。

* **pnpm**：通过使用符号链接，`pnpm` 维护了一个严格的嵌套依赖结构，更接近每个包的 `package.json` 文件所声明的依赖树形态。这提供了更高的一致性和在某些情况下更好的包隔离性。

 4. **依赖隔离与安全性**

* **pnpm**：更好地隔离了依赖，每个包只能访问其在 `package.json` 中声明的依赖。这一特性增强了项目的安全性，因为它阻止了未声明的依赖被意外引入的情况。

* **npm**：虽然 `npm` 也遵循 `package.json` 中的声明，但其扁平化的 `node_modules` 结构有时可能会容易地让包访问到未明确声明的依赖。

 5. **命令行界面（CLI）和配置**

* 这两个工具的命令行界面（CLI）和配置都非常直观且类似，但它们的某些命令和选项可能会有细微差别。`pnpm` 为了优化性能和安全性引入了一些特有的命令和配置选项。

总的来说，`pnpm` 在多项目管理、磁盘空间和安装速度方面提供了优于 `npm` 的性能和利益。对于新项目或在寻求性能优化的既存项目，考虑试用 `pnpm` 可能是个不错的选择。

## monorepo 工程有哪些工具架构， 该如何选型 {#p3-monorepo-工程有哪些工具架构-该如何选型}

 工具推荐

| 工具 | **Turborepo** | **Rush** | **Nx** | **Lerna** | **Pnpm Workspace** |
| -------- | ------------- | -------- | ------ | --------- | ------------------ |
| 依赖管理 | ❌ | ✅ | ❌ | ❌ | ✅ |
| 版本管理 | ❌ | ✅ | ❌ | ✅ | ❌ |
| 增量构建 | ✅ | ✅ | ✅ | ❌ | ❌ |
| 插件扩展 | ✅ | ✅ | ✅ | ❌ | ❌ |
| 云端缓存 | ✅ | ✅ | ✅ | ❌ | ❌ |
| Stars | 20.4K | 4.9K | 17K | 34.3K | 22.7K |

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d85551b9ce50496d8403956b571c4635~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=2610&h=1020&s=64366&e=webp&b=fdfdfd)

 工具选型

选择合适的 Monorepo 管理工具对于确保项目的顺利进行是至关重要的。Monorepo 管理工具可以帮助你高效地管理项目依赖、统一代码风格、简化开发流程等。在进行 Monorepo 工具选型时，需要考虑几个重要的因素：

 1. **技术栈的兼容性**

* **Lerna**：与任何技术栈兼容性都很好，特别是与前端项目协同工作时。它对 NPM 和 Yarn 都有良好支持，适用于需要独立版本管理或频繁发布的项目。
* **Yarn Workspaces**：特别适合使用 Yarn 作为包管理器的 JavaScript 或 TypeScript 项目。它非常适合团队中包之间有很多交叉依赖的情形。
* **Nx**：支持多种前端和后端框架，如 Angular、React、NestJS 等。如果项目采用多技术栈，Nx 提供了一套完整的解决方案，包含了构建、测试和 linting 等一站式服务。
* **Rush**：同样适用于大型项目，兼容任何 NPM 包管理器，如 NPM、Yarn、pnpm。Rush 提供了灵活的版本控制策略，非常适合需要精细控制包版本策略的场景。
* **pnpm Workspaces**：具有高效的节点模块解析机制，非常注重节省磁盘空间及速度优化。如果磁盘空间和安装速度是关键考虑因素，pnpm 会是一个不错的选择。

 2. **项目的规模和复杂度**

* 对于大型或复杂项目，**Nx** 和 **Rush** 提供了更多的高级特性，比如增量构建、依赖图可视化等，可以有效提升大团队的开发效率。
* 对于中小型项目，**Lerna**、**Yarn Workspaces** 或 **pnpm Workspaces** 可能更易上手，配置和管理也较为简单。

 3. **构建、测试和部署的需求**

* 如果项目需要复杂的构建、测试流程，**Nx** 提供了一些很好的工具来优化这一过程。Nx 可以智能地只重新构建受影响的项目，节省 CI/CD 的时间和资源。
* **Rush** 强调在大型仓库中提供稳定而灵活的版本策略和发布管理，对于需要精细控制不同环境部署的项目非常有用。

 4. **团队协作和代码共享的便利性**

* 所有这些工具都支持代码共享和重用，但是**Nx** 和 **Rush** 在支持大型团队和多项目协作方面有一些额外的优势，如更智能的依赖管理和版本控制。

 5. **社区支持和文档**

* **Nx** 拥有强大的社区支持和丰富的文档、教程，非常适合于新技术栈的团队。
* **Lerna** 和 **Yarn Workspaces** 受众广泛，网上有很多资源和案例，学习曲线相对平缓。

 推荐策略

如果你的项目非常关注于构建效率和对多种技术栈的支持，**Nx** 是非常好的选择。如果你更关心包的独立发布和版本管理，**Lerna** 和 **Rush** 可以满足你的需求。而对于那些偏好 Yarn 并且注重依赖管理的项目来说，**Yarn Workspaces** 提供了一套简单直接的解决方案。如果磁盘空间和安装速度是你的主要考虑，不妨试试 **pnpm Workspaces**。

## 幽灵依赖是什么 {#p0-ghost-dependency}

"幽灵依赖"（Ghost Dependency）是指在项目的`node_modules`目录中存在但未被实际使用的依赖包。

在使用 npm 或者其他包管理工具安装依赖包时，有时会出现安装了一些不需要的或者不正确的依赖包的情况。这些依赖包在项目中没有被显式地引用或使用，但仍然存在于`node_modules`目录中，占用了项目的存储空间。

幽灵依赖可能会产生以下问题：

1. 占用存储空间：未使用的依赖包会增加项目的体积，占用存储空间。对于大型项目或频繁部署的项目来说，这可能会造成不必要的存储资源浪费。

2. 增加构建时间：未使用的依赖包可能会增加构建过程中的解析和处理时间，导致构建过程变慢。这会影响开发人员的开发效率和项目的部署速度。

3. 潜在的安全风险：未使用的依赖包可能包含漏洞或安全风险，但由于没有使用，可能没有及时更新或修复这些问题，增加了项目的安全隐患。

为了解决幽灵依赖的问题，可以采取以下措施：

1. 定期检查依赖：定期检查项目的依赖，识别和删除未使用的依赖包。可以使用工具如`npm-check-unused`、`depcheck`等来帮助检测和清理未使用的依赖。

2. 精简依赖：审查项目的依赖关系，仅安装和保留必要的依赖包。避免过度依赖，只安装项目所需的模块，减少项目体积和构建时间。

3. 更新依赖包：确保项目中使用的依赖包都是最新版本，并及时更新已知的安全漏洞和问题。这可以通过定期检查依赖包的更新和使用工具如`npm audit`来实现。

通过处理幽灵依赖，可以提高项目的整洁性、性能和安全性，并减少不必要的开销和风险。

 pnpm 是如何解决幽灵依赖问题的

pnpm 是一个基于 npm 的包管理工具，它采用了一种称为"快速硬链接（Fast Hard Links）"的机制来解决幽灵依赖问题。

传统的 npm 或 yarn 安装依赖时，每个项目都会在`node_modules`目录下创建依赖包的副本。这导致了大量的重复文件，尤其是对于多个项目都使用同一依赖包时。

而 pnpm 通过使用快速硬链接机制，在全局的存储位置（默认为`~/.pnpm-store`）只保存一份依赖包，而不是为每个项目都复制一份。这样就避免了幽灵依赖问题，减少了存储空间的占用。

当使用 pnpm 安装依赖时，它会在项目的`node_modules`目录下创建一个`.modules.yaml`文件，记录项目所需的依赖包和版本信息。实际的依赖包文件通过硬链接指向全局存储位置中的依赖包。这意味着不同项目之间可以共享相同的依赖包，但每个项目都拥有自己的依赖版本。

通过这种方式，pnpm 解决了幽灵依赖的问题，同时减少了存储空间的使用。它还具有一些其他的优点，如更快的安装速度、更少的网络传输和更好的缓存利用率。

需要注意的是，pnpm 仍然会将项目中的所有依赖安装在`node_modules`目录下，但它使用硬链接的方式避免了重复文件的复制，从而解决了幽灵依赖问题。

## pnpm、npm、yarn 特性 {#p1-package}

| 功能 | pnpm | Yarn | npm |
|--------------------------------|------------------------------------------------------------------------------------------------|--------------------------------------------------------|------------------------------------------------------|
| 工作区支持 | ✔️ | ✔️ | ✔️ |
| 隔离的 node_modules | ✔️ - 默认支持 | ✔️ | ✔️ |
| 提升的 node_modules | ✔️ | ✔️ | ✔️ - 默认支持 |
| 自动安装对等依赖 | ✔️ | ❌ | ✔️ |
| Plug'n'Play | ✔️ | ✔️ - 默认支持 | ❌ |
| 零安装 | ❌ | ✔️ | ❌ |
| 修补依赖 | ✔️ | ✔️ | ❌ |
| 管理 Node.js 版本 | ✔️ | ❌ | ❌ |
| 有一个锁文件 | ✔️ - 使用 pnpm-lock.yaml | ✔️ - 使用 yarn.lock | ✔️ - 使用 package-lock.json |
| 覆盖支持 | ✔️ | ✔️ - 通过 resolutions 配置 | ✔️ |
| 可寻址存储 | ✔️ | ❌ | ❌ |
| 动态包执行 | ✔️ - 通过 pnpm dlx | ✔️ - 通过 yarn dlx | ✔️ - 通过 npx |
| 副作用缓存 | ✔️ | ❌ | ❌ |
| 列出许可证 | ✔️ - 通过 pnpm licenses list | ✔️ - 通过插件 | ❌ |
