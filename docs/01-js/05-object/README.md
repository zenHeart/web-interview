# 对象

## 原始封装类型

## 对象的可变和不可变

## 深拷贝

所谓深拷贝的重点是循环克隆值。

1. 采用 `JSON.parse(JSON.stringfy(obj))` 的方式解决,该解决方案存在如下漏洞
   1. 键值为 undefined 的项会被忽略
   2. 键名为 Symbol 类型会被忽略
   3. 不能序列化函数
   4. 不能解决循环引用对象

详见此文 [javascript 深拷贝](https://dassur.ma/things/deep-copy/)

## 浅拷贝

1. Object.assign()
2. 对象扩展

## instanceof 的使用

## 手写实现四种继承

## Object.create 实现原型继承

### 原型链？ ⭐️⭐️⭐️⭐️⭐️

根据 [ECMAScript 规范对象原型链的描述](https://tc39.es/ecma262/#sec-objects)概念如下: 每一个通过构造器创建的对象都会有一个隐式索引,值指向构造器的 **prototype(原型)** 属性值。此外该原型可能包含一个值为非空的隐式索引指向它自己的原型,依次类推称为原型链。当查找某个对象属性时会顺着原型链检查,返回匹配的第一个相同属性值。

基于上述概念原型链具有如下特性

1. 在访问对象属性和方法时,js 引擎会遍历对象的自有属性和递归遍历内部  `__proto__` 索引指向的对象返回第一个查找到的值
2. 采用构造函数初始化对象时,实例的 `__proto__` 属性指向构造函数的 `prototype`
