# 语言特性

## 解构复制对象， 是深拷贝还是浅拷贝 {#p2-destructuring-copy-object}

**浅拷贝**

举例：

```javascript
const obj = {
  prop1: 'value1',
  prop2: {
    nestedProp: 'nestedValue'
  }
}

// 使用扩展运算符进行复制
const obj2 = { ...obj }

console.log('原始对象 obj:', obj)
console.log('复制后的对象 obj2:', obj2)

// 修改基本类型属性
obj2.prop1 = 'newValue1'
console.log('修改基本类型属性后：')
console.log('原始对象 obj:', obj)
console.log('复制后的对象 obj2:', obj2)

// 修改嵌套对象的属性
obj2.prop2.nestedProp = 'newNestedValue'
console.log('修改嵌套对象属性后：')
console.log('原始对象 obj:', obj)
console.log('复制后的对象 obj2:', obj2)
```

解释如下：

1. 首先定义了一个对象`obj`，它包含一个基本类型属性`prop1`和一个嵌套对象属性`prop2`。
2. 使用扩展运算符`{...obj}`创建了一个新的对象`obj2`，这看起来像是对`obj`进行了复制。
3. 当修改`obj2`的基本类型属性`prop1`时，原始对象`obj`的`prop1`不受影响。这是因为基本类型的值在复制时是按值复制的。
4. 然而，当修改`obj2`的嵌套对象属性`prop2.nestedProp`时，原始对象`obj`的`prop2.nestedProp`也被修改了。这是因为扩展运算符对于嵌套对象只是复制了引用，而不是创建一个全新的嵌套对象副本，所以这是浅拷贝的行为。

## for...of、for...in、for 循环， 三者有什么区别 {#p0-loop}

**关键词**：for...in遍历、for...of遍历

以下是 `for...of`、`for...in` 和 `for` 循环的区别对比表格：

| 特性 | for...of 循环 | for...in 循环 | for 循环 |
|------------------|----------------------------------------------------------------|-----------------------------------------------------------|------------------------------------------------------------|
| 遍历对象类型 | 可以遍历可迭代对象（如数组、字符串、Set、Map、Generator 等） | 可以遍历对象的可枚举属性 | 不适用于直接遍历对象，适用于遍历数组或固定个数的循环 |
| 遍历数组 | 遍历数组的元素 | 遍历数组的索引 | 遍历数组的索引或值 |
| 遍历字符串 | 遍历字符串的字符 | 遍历字符串的索引 | 遍历字符串的索引或字符 |
| 遍历 Set | 遍历 Set 的值 | 不适用 | 不适用 |
| 遍历 Map | 遍历 Map 的键值对 | 不适用 | 不适用 |
| 遍历对象 | 不适用 | 遍历对象的可枚举属性及其对应的值 | 不适用 |
| 遍历 Generator | 遍历 Generator 生成的值 | 不适用 | 不适用 |
| 遍历可迭代对象 | 遍历可迭代对象的元素 | 不适用 | 不适用 |
| 适用范围 | 适用于需要遍历可迭代对象的场景 | 适用于需要遍历对象的可枚举属性的场景 | 适用于需要手动控制循环次数的场景 |
| 遍历顺序 | 按照可迭代对象的顺序进行遍历 | 不保证顺序 | 按照循环次数进行遍历 |

需要注意的是，`for...of` 循环只能用于可迭代对象，并且会遍历对象的迭代器方法（即 `Symbol.iterator`），而 `for...in` 循环会遍历对象的所有可枚举属性，包括原型链上的属性。

对于遍历数组的场景，可以使用 `for...of` 循环遍历数组的元素，也可以使用 `for` 循环遍历数组的索引或值。具体选择哪种方式取决于遍历的目的和需求。

以下是一个使用不同循环方式遍历数组的示例：

```javascript
const arr = [1, 2, 3]

console.log('for...of 循环:')
for (const element of arr) {
  console.log(element)
}

console.log('for...in 循环:')
for (const index in arr) {
  console.log(arr[index])
}

console.log('for 循环:')
for (let i = 0; i < arr.length; i++) {
  console.log(arr[i])
}
```

输出结果为：

```
for...of 循环:
1
2
3
for...in 循环:
1
2
3
for 循环:
1
2
3
```

## 对象冻结 {#p0-freeze}

**冻结对象**

要冻结一个 JavaScript 对象，以防止别人更改它，可以使用`Object.freeze()`方法。`Object.freeze()`方法会递归地冻结一个对象的所有属性，使其变为只读的，并防止更改、删除或添加新属性。以下是使用`Object.freeze()`方法冻结对象的示例：

```javascript
const obj = {
  prop1: 1,
  prop2: 'Hello'
}

Object.freeze(obj)

// 尝试更改属性的值
obj.prop1 = 2 // 不会生效，obj.prop1仍然为1

// 尝试删除属性
delete obj.prop2 // 不会生效，obj仍然包含prop2属性

// 尝试添加新属性
obj.prop3 = true // 不会生效，obj不会添加新属性

console.log(obj)
```

在上述示例中，通过调用`Object.freeze(obj)`方法，将`obj`对象冻结，使其变为只读。此后，无论是更改、删除还是添加属性，都不会对对象产生任何影响。最后，通过`console.log(obj)`输出对象，可以看到对象保持不变，即使尝试进行更改。

需要注意的是，`Object.freeze()`方法只会冻结对象的直接属性，而不会冻结嵌套对象的属性。如果需要递归地冻结嵌套对象的属性，可以编写一个递归函数来处理。

**深度冻结**

要冻结嵌套属性，可以使用一个递归函数来处理。该函数会遍历对象的所有属性，并对每个属性进行冻结。以下是一个示例：

```javascript
function deepFreeze (obj) {
  // 首先冻结当前对象
  Object.freeze(obj)

  // 遍历对象的所有属性
  for (const key of Object.keys(obj)) {
    const value = obj[key]

    // 如果属性是对象类型，则递归调用deepFreeze函数
    if (typeof value === 'object' && value !== null) {
      deepFreeze(value)
    }
  }

  return obj
}

const obj = {
  prop1: 1,
  prop2: {
    nestedProp1: 'Hello',
    nestedProp2: [1, 2, 3]
  }
}

const frozenObj = deepFreeze(obj)

// 尝试更改嵌套属性的值
frozenObj.prop2.nestedProp1 = 'World' // 不会生效，嵌套属性仍然为'Hello'

console.log(frozenObj)
```

在上述示例中，我们定义了一个名为`deepFreeze`的递归函数。该函数首先会对当前对象进行冻结（调用`Object.freeze(obj)`），然后遍历对象的所有属性。如果属性是对象类型，则递归调用`deepFreeze`函数，对嵌套对象进行冻结。

通过调用`deepFreeze(obj)`函数，我们将`obj`对象及其嵌套属性都冻结，并将结果赋值给`frozenObj`。尝试更改嵌套属性的值后，输出`frozenObj`，可以看到对象保持不变，嵌套属性的值没有被更改。

需要注意的是，`deepFreeze`函数并不会修改原始对象，而是返回一个新的冻结对象。如果需要修改原始对象，可以将冻结的属性逐个复制到一个新对象中。

## eval 了解多少？ {#p1-eval}

`eval()` 是 JavaScript 的一个全局函数，用于解析并执行字符串代码。

它接受一个字符串参数，该字符串包含 JavaScript 表达式或语句。在 `eval` 函数执行期间，该字符串的内容将被视为有效 JavaScript 代码，并运行当前作用域中的变量和函数。`eval()` 函数返回执行结果的值。

举个例子：

```js
const x = 1
const y = 2
const result = eval('x + y') // 将字符串作为代码执行
console.log(result) // 输出 3
```

`eval()` 常被认为是一个危险的函数，原因是它可以执行任何字符串。如果 `eval()` 执行了用户输入的文本，攻击者可能会注入恶意代码，从而窃取敏感信息或操纵应用程序。因此，最好不要在程序中使用 `eval()` 函数，除非你非常明确及了解其潜在风险。

除了 `eval()`，JavaScript 还提供了其他如 `Function()` 构造函数或 `setTimeout()` 等能够执行字符代码的方法，但它们的使用都需要非常小心。

 eval 的性能为何比静态编写和编译的代码要慢

`eval()` 函数解析并执行动态的字符串代码，因此在运行时需要进行代码分析和编译。每次调用 `eval()` 都需要重复执行这些操作，这对性能的影响非常大。同时，由于 `eval()` 执行的代码是字符串形式并不是预编译的机器代码，在执行时可能需要使用更多的内存和 CPU 资源。

相比之下，静态编写的代码在编译时已经被转化为机器代码，因此执行速度会更快。编译器可以进行多项优化，例如移除无用的代码，减少内存分配等。这些优化在运行时是不可能完成的，因此 `eval()` 函数的性能相对较低。

 eval 性能一定就很差吗

不是所有情况下 `eval()` 函数的性能都很差。在某些情况下，`eval()` 的性能可能与静态编写的代码相当。例如，如果动态代码比较简单，并且在程序运行期间只会执行一次，那么使用 `eval()` 不会造成显著的性能损失。但是如果动态代码比较复杂，并且需要经常执行，那么使用 `eval()` 的性能就会显著低于静态编写的代码。

另外，`eval()` 的性能问题还取决于运行时环境的不同。在某些浏览器中，使用 `eval()` 时会导致缓慢的 JavaScript 执行，而在其他浏览器中则表现良好。因此，在编写代码时，应该始终将性能作为一个重要的因素进行考虑，并根据实际情况来选择使用 `eval()` 或其他适当的解决方案。

 eval 有什么优势

`eval()` 函数有以下几个优势：

1. 动态执行代码：`eval()` 函数可以动态地将字符串解析为 JavaScript 代码并执行，从而可以在运行时动态生成代码并执行。这种动态性使得 `eval()` 函数在一些特定的编程场景中非常有用，例如动态计算表达式、动态生成函数等。

2. 灵活性高：由于 `eval()` 函数可以动态解析字符串并执行其中的 JavaScript 代码，因此可以根据需要在运行时动态生成代码，而不必在编写代码时预先定义。这种灵活性使得 `eval()` 函数在一些需要动态生成代码的场景中非常有用。

3. 命名空间：由于 `eval()` 函数会执行其中的 JavaScript 代码，因此代码可以利用当前作用域中的变量和函数，从而可以有效地利用命名空间并提高代码的复用性。

**缺点**

虽然 `eval()` 函数具有上述优势，但它也存在潜在的安全隐患，因此应当避免在应用程序中过度使用 `eval()` 函数，并在使用时注重安全性和可控性。
